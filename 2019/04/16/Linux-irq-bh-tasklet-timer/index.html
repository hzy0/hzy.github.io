<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Linux中断下半部之timer、tasklet | JoyYoung&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习linux内核定时器和小任务的实现">
<meta name="keywords" content="Linux,学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux中断下半部之timer、tasklet">
<meta property="og:url" content="http://yoursite.com/2019/04/16/Linux-irq-bh-tasklet-timer/index.html">
<meta property="og:site_name" content="JoyYoung&#39;s blog">
<meta property="og:description" content="学习linux内核定时器和小任务的实现">
<meta property="og:locale" content="default">
<meta property="og:updated_time" content="2019-06-21T16:18:14.902Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux中断下半部之timer、tasklet">
<meta name="twitter:description" content="学习linux内核定时器和小任务的实现">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoyYoung&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Linux-irq-bh-tasklet-timer" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/16/Linux-irq-bh-tasklet-timer/" class="article-date">
  <time datetime="2019-04-16T15:47:44.000Z" itemprop="datePublished">2019-04-16</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux中断下半部之timer、tasklet
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>之前整理Linux软中断的工作流程时也提到，对于中断处理而言，linux将其分成了两个部分：一个叫做中断handler（top half），是全程关闭中断的；另外一部分是deferable task（bottom half），属于不那么紧急需要处理的事情，在执行bottom half的时候，是开中断的。有多种bottom half的机制，例如：softirq、tasklet、workqueue或是直接创建一个kernel thread来执行bottom half。tasklet和timer是基于softirq的，也是这里主要的学习对象；不过不是面面俱到的深入学习，主要整理相关的数据结构和大的工作流程！</p>
<h2 id="timer"><a href="#timer" class="headerlink" title="timer"></a>timer</h2><p>内核定时器的实现主要在kernel/time/timer.c中。不过我们先来看看内核对定时器对象的抽象timer_list，定时器的工作是围绕这个结构体展开的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> &#123;</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * All fields that change during normal runtime grouped to the</span></span><br><span class="line"><span class="comment">	 * same cacheline</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// 用来将多个定时器连接成一条双向循环队列。</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">entry</span>;</span></span><br><span class="line">    <span class="comment">// 指定定时器超时的时间戳，当expires小于jiffies（当前时间戳）时，这个定时器就超时了</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		expires;</span><br><span class="line">    <span class="comment">// 定时器超时后的回调函数</span></span><br><span class="line">	<span class="keyword">void</span>			(*function)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">    <span class="comment">// 用作定时器超时回调函数的参数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		data;</span><br><span class="line">    <span class="comment">// 定时器的特性标志位，内核中可以找到定义，稍后附上</span></span><br><span class="line">	u32			flags;</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>关于timer_list中的flags，内核中有以下几种flag的申明：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * A deferrable timer will work normally when the system is busy, but</span></span><br><span class="line"><span class="comment"> * will not cause a CPU to come out of idle just to service it; instead,</span></span><br><span class="line"><span class="comment"> * the timer will be serviced when the CPU eventually wakes up with a</span></span><br><span class="line"><span class="comment"> * subsequent non-deferrable timer.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * An irqsafe timer is executed with IRQ disabled and it's safe to wait for</span></span><br><span class="line"><span class="comment"> * the completion of the running instance from IRQ handlers, for example,</span></span><br><span class="line"><span class="comment"> * by calling del_timer_sync().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note: The irq disabled callback execution is a special case for</span></span><br><span class="line"><span class="comment"> * workqueue locking issues. It's not meant for executing random crap</span></span><br><span class="line"><span class="comment"> * with interrupts disabled. Abuse is monitored!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_CPUMASK		0x0003FFFF</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_MIGRATING		0x00040000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_BASEMASK		(TIMER_CPUMASK | TIMER_MIGRATING)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_DEFERRABLE	0x00080000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_PINNED		0x00100000</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_IRQSAFE		0x00200000 <span class="comment">//从上面的注释中断安全的定时在在执行时，是关闭中断的</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_ARRAYSHIFT	22</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> TIMER_ARRAYMASK		0xFFC00000</span></span><br></pre></td></tr></table></figure>

<h4 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h4><p>以我们之前分析的高通的看门狗驱动为例，看看喂狗定时器的申请和工作，了解timer的使用方法。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line">	init_timer(&amp;wdog_dd-&gt;pet_timer);<span class="comment">//初始化，默认flags为0</span></span><br><span class="line">	wdog_dd-&gt;pet_timer.data = (<span class="keyword">unsigned</span> <span class="keyword">long</span>)wdog_dd;</span><br><span class="line">	wdog_dd-&gt;pet_timer.function = pet_task_wakeup;</span><br><span class="line">	wdog_dd-&gt;pet_timer.expires = jiffies + delay_time;</span><br><span class="line">	add_timer(&amp;wdog_dd-&gt;pet_timer);<span class="comment">//添加后开始工作</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//init_timer可以好几种，Timer.h</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_timer(timer)						\</span></span><br><span class="line">	__init_timer((timer), <span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_timer_pinned(timer)					\</span></span><br><span class="line">	__init_timer((timer), TIMER_PINNED)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_timer_deferrable(timer)					\</span></span><br><span class="line">	__init_timer((timer), TIMER_DEFERRABLE)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_timer_pinned_deferrable(timer)				\</span></span><br><span class="line">	__init_timer((timer), TIMER_DEFERRABLE | TIMER_PINNED)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> init_timer_on_stack(timer)					\</span></span><br><span class="line">	__init_timer_on_stack((timer), <span class="number">0</span>)</span><br><span class="line"><span class="comment">//也可以通过setup灵活初始化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __setup_timer(_timer, _fn, _data, _flags)			\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		__init_timer((_timer), (_flags));			\</span><br><span class="line">		(_timer)-&gt;function = (_fn);				\</span><br><span class="line">		(_timer)-&gt;data = (_data);				\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继续高通的代码：</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">pet_task_wakeup</span><span class="params">(<span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">msm_watchdog_data</span> *<span class="title">wdog_dd</span> =</span></span><br><span class="line"><span class="class">		(<span class="title">struct</span> <span class="title">msm_watchdog_data</span> *)<span class="title">data</span>;</span></span><br><span class="line">	wdog_dd-&gt;timer_expired = <span class="literal">true</span>;</span><br><span class="line">	wake_up(&amp;wdog_dd-&gt;pet_complete);<span class="comment">//唤醒等待队列上的喂狗线程</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 喂狗线程处理完喂狗事务之后，会修改定时器，定时器开始重新定时</span></span><br><span class="line">		<span class="comment">/* Check again before scheduling</span></span><br><span class="line"><span class="comment">		 * Could have been changed on other cpu</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		mod_timer(&amp;wdog_dd-&gt;pet_timer, jiffies + delay_time);</span><br></pre></td></tr></table></figure>

<h4 id="处理流程"><a href="#处理流程" class="headerlink" title="处理流程"></a>处理流程</h4><p>定时器的定时功能依赖于cpu的时钟中断的，这块不做分析。主要看看定时器到期后是怎么被调度的。首先定时器是基于软中断的，内核初始化流程中会调用init_timers初始化定时器模块。可以看到open_softirq函数打开了软中断TIMER_SOFTIRQ。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">void</span> __<span class="function">init <span class="title">init_timers</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	init_timer_cpus();</span><br><span class="line">	open_softirq(TIMER_SOFTIRQ, run_timer_softirq);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>所以我们看看run_timer_softirq的处理流程，每个cpu都有自己的timer_base，定时器是可以绑定cpu的；也是可以迁移的、可延迟的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">latent_entropy <span class="keyword">void</span> <span class="title">run_timer_softirq</span><span class="params">(struct softirq_action *h)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_base</span> *<span class="title">base</span> = <span class="title">this_cpu_ptr</span>(&amp;<span class="title">timer_bases</span>[<span class="title">BASE_STD</span>]);</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * must_forward_clk must be cleared before running timers so that any</span></span><br><span class="line"><span class="comment">	 * timer functions that call mod_timer will not try to forward the</span></span><br><span class="line"><span class="comment">	 * base. idle trcking / clock forwarding logic is only used with</span></span><br><span class="line"><span class="comment">	 * BASE_STD timers.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The deferrable base does not do idle tracking at all, so we do</span></span><br><span class="line"><span class="comment">	 * not forward it. This can result in very large variations in</span></span><br><span class="line"><span class="comment">	 * granularity for deferrable timers, but they can be deferred for</span></span><br><span class="line"><span class="comment">	 * long periods due to idle.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	base-&gt;must_forward_clk = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	__run_timers(base);</span><br><span class="line">	<span class="keyword">if</span> (IS_ENABLED(CONFIG_NO_HZ_COMMON))</span><br><span class="line">		__run_timers(this_cpu_ptr(&amp;timer_bases[BASE_DEF]));</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> ((atomic_cmpxchg(&amp;deferrable_pending, <span class="number">1</span>, <span class="number">0</span>) &amp;&amp;</span><br><span class="line">		tick_do_timer_cpu == TICK_DO_TIMER_NONE) ||</span><br><span class="line">		tick_do_timer_cpu == smp_processor_id())</span><br><span class="line">		__run_timers(&amp;timer_base_deferrable);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>接下来看看__run_timers函数；这个函数会调度这个cpu上的所有已经超时的timer。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * __run_timers - run all expired timers (if any) on this CPU.</span></span><br><span class="line"><span class="comment"> * @base: the timer vector to be processed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __run_timers(struct timer_base *base)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_head</span> <span class="title">heads</span>[<span class="title">LVL_DEPTH</span>];</span></span><br><span class="line">	<span class="keyword">int</span> levels;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!time_after_eq(jiffies, base-&gt;clk))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;base-&gt;lock);<span class="comment">//关闭中断、关闭抢占、获取自旋锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (time_after_eq(jiffies, base-&gt;clk)) &#123;</span><br><span class="line"></span><br><span class="line">		levels = collect_expired_timers(base, heads);</span><br><span class="line">		base-&gt;clk++;</span><br><span class="line">        <span class="comment">// 遍历所有超时的timer</span></span><br><span class="line">		<span class="keyword">while</span> (levels--)</span><br><span class="line">			expire_timers(base, heads + levels);</span><br><span class="line">	&#125;</span><br><span class="line">	base-&gt;running_timer = <span class="literal">NULL</span>;</span><br><span class="line">	spin_unlock_irq(&amp;base-&gt;lock);<span class="comment">//开启中断、开启抢占、释放自旋锁</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>expire_timers函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">expire_timers</span><span class="params">(struct timer_base *base, struct hlist_head *head)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">while</span> (!hlist_empty(head)) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> *<span class="title">timer</span>;</span></span><br><span class="line">		<span class="keyword">void</span> (*fn)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);</span><br><span class="line">		<span class="keyword">unsigned</span> <span class="keyword">long</span> data;</span><br><span class="line"></span><br><span class="line">		timer = hlist_entry(head-&gt;first, struct timer_list, entry);</span><br><span class="line"></span><br><span class="line">		base-&gt;running_timer = timer;</span><br><span class="line">		detach_timer(timer, <span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">		fn = timer-&gt;function;</span><br><span class="line">		data = timer-&gt;data;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (timer-&gt;flags &amp; TIMER_IRQSAFE) &#123; <span class="comment">// 中断安全的timer，延迟工作队列用到，关中断的状态下回调</span></span><br><span class="line">			spin_unlock(&amp;base-&gt;lock);</span><br><span class="line">			call_timer_fn(timer, fn, data);</span><br><span class="line">			spin_lock(&amp;base-&gt;lock);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//其他的timer是普通的工作环境，开启中断、允许抢占、不持有自旋锁</span></span><br><span class="line">			spin_unlock_irq(&amp;base-&gt;lock);</span><br><span class="line">			call_timer_fn(timer, fn, data);</span><br><span class="line">			spin_lock_irq(&amp;base-&gt;lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="tasklet"><a href="#tasklet" class="headerlink" title="tasklet"></a>tasklet</h2><p>从软中断的初始化softirq_init可以看到，tasklet分普通的TASKLET_SOFTIRQ和高优先级的HI_SOFTIRQ两种。一个tasklet用tasklet_struct结构体表示。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">next</span>;</span><span class="comment">//指向下一个tasklet，形成链表</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> state; <span class="comment">//tasklet的状态，TASKLET_STATE_SCHED表明tasklet已经被调度，正准备投入运行，TASKLET_STATE_RUN表示该tasklet正在运行。</span></span><br><span class="line">	<span class="keyword">atomic_t</span> count;      <span class="comment">//tasklet的引用计数，如果它不为0，则tasklet被禁止，不允许执行；只有当它为0时，tasklet才被激活，并且在被设置为挂起（TASKLET_STATE_SCHED）状态时，该tasklet才能够被执行。</span></span><br><span class="line">	<span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>);<span class="comment">//tasklet回调函数</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> data;<span class="comment">//回调时的参数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="使用-1"><a href="#使用-1" class="headerlink" title="使用"></a>使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//tasklet_init动态创建</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_init</span><span class="params">(struct tasklet_struct *t,</span></span></span><br><span class="line"><span class="function"><span class="params">		  <span class="keyword">void</span> (*func)(<span class="keyword">unsigned</span> <span class="keyword">long</span>), <span class="keyword">unsigned</span> <span class="keyword">long</span> data)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">	t-&gt;state = <span class="number">0</span>;</span><br><span class="line">	atomic_set(&amp;t-&gt;count, <span class="number">0</span>);</span><br><span class="line">	t-&gt;func = func;</span><br><span class="line">	t-&gt;data = data;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//适当的时候调度</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">tasklet_schedule</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state))</span><br><span class="line">		__tasklet_schedule(t);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">void</span> __tasklet_schedule(struct tasklet_struct *t)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">	local_irq_save(flags);<span class="comment">//禁用中断并保存中断标志位</span></span><br><span class="line">	t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// 将tasklet放入本cpu的tasklet_head中</span></span><br><span class="line">	*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">	__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line">	raise_softirq_irqoff(TASKLET_SOFTIRQ);<span class="comment">//触发TASKLET_SOFTIRQ软中断，takslet在下次中断退出或者ksoftirqd中被调度</span></span><br><span class="line">	local_irq_restore(flags);<span class="comment">//开启中断并恢复中断标志位</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//删除tasklet，tasklet_kill 则用于清掉tasklet_struct成员变量的state的TASKLET_STATE_SCHED位。来禁止这个tasklet被调度运行.</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">tasklet_kill</span><span class="params">(struct tasklet_struct *t)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">//tasklet_kill 可以被用于中断环境中，且如果是中断环境中则打印下面的log.</span></span><br><span class="line">	<span class="keyword">if</span> (in_interrupt())</span><br><span class="line">		pr_notice(<span class="string">"Attempt to kill tasklet from interrupt\n"</span>);</span><br><span class="line">	<span class="comment">//返回state的值，state的值只能是</span></span><br><span class="line">	<span class="comment">//enum</span></span><br><span class="line">	<span class="comment">//	&#123;</span></span><br><span class="line">	<span class="comment">//	TASKLET_STATE_SCHED,	/* Tasklet is scheduled for execution */</span></span><br><span class="line">	<span class="comment">//	TASKLET_STATE_RUN	/* Tasklet is running (SMP only) */</span></span><br><span class="line">	<span class="comment">//	&#125;;</span></span><br><span class="line">	<span class="comment">//如果返回TASKLET_STATE_SCHED的话，也就是说这个tasklet没有被运行，这个while循环不成立。</span></span><br><span class="line">    <span class="comment">//如果state的原来的状态就是TASKLET_STATE_RUN，则这个大循环成立，进入到内循环中判断state是否被已经是TASKLET_STATE_SCHED，如果是的话，则退出内循环，这个时候外循环也就退出了</span></span><br><span class="line">	</span><br><span class="line">	<span class="keyword">while</span> (test_and_set_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state)) &#123;</span><br><span class="line">		<span class="keyword">do</span> &#123;</span><br><span class="line">			yield();</span><br><span class="line">		&#125; <span class="keyword">while</span> (test_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state));</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="comment">//等待这个tasklet被执行完成</span></span><br><span class="line">	tasklet_unlock_wait(t);</span><br><span class="line">	清理tasklet中的TASKLET_STATE_SCHED位</span><br><span class="line">	clear_bit(TASKLET_STATE_SCHED, &amp;t-&gt;state);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="处理流程-1"><a href="#处理流程-1" class="headerlink" title="处理流程"></a>处理流程</h4><p>我们这里看的是tasklet_action的处理流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> __<span class="function">latent_entropy <span class="keyword">void</span> <span class="title">tasklet_action</span><span class="params">(struct softirq_action *a)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">	local_irq_disable();</span><br><span class="line">	<span class="built_in">list</span> = __this_cpu_read(tasklet_vec.head);</span><br><span class="line">	__this_cpu_write(tasklet_vec.head, <span class="literal">NULL</span>);</span><br><span class="line">	__this_cpu_write(tasklet_vec.tail, this_cpu_ptr(&amp;tasklet_vec.head));</span><br><span class="line">	local_irq_enable();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">while</span> (<span class="built_in">list</span>) &#123;<span class="comment">//遍历tasklet</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">tasklet_struct</span> *<span class="title">t</span> = <span class="title">list</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="built_in">list</span> = <span class="built_in">list</span>-&gt;next;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (tasklet_trylock(t)) &#123;<span class="comment">//设置TASKLET_STATE_RUN，返回老的state，老的state如果是TASKLET_STATE_RUN就不用执行这个tasklet</span></span><br><span class="line">			<span class="keyword">if</span> (!atomic_read(&amp;t-&gt;count)) &#123;<span class="comment">//引用计数为0才能执行</span></span><br><span class="line">                <span class="comment">//清除TASKLET_STATE_SCHED标志，如果老的状态没有TASKLET_STATE_SCHED则代表出现bug了</span></span><br><span class="line">				<span class="keyword">if</span> (!test_and_clear_bit(TASKLET_STATE_SCHED,</span><br><span class="line">							&amp;t-&gt;state))</span><br><span class="line">					BUG();</span><br><span class="line">				t-&gt;func(t-&gt;data);<span class="comment">//执行回调</span></span><br><span class="line">				tasklet_unlock(t);<span class="comment">//清除TASKLET_STATE_RUN标志</span></span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			tasklet_unlock(t);<span class="comment">//清除TASKLET_STATE_RUN标志</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//重新出发软中断</span></span><br><span class="line">		local_irq_disable();</span><br><span class="line">		t-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">		*__this_cpu_read(tasklet_vec.tail) = t;</span><br><span class="line">		__this_cpu_write(tasklet_vec.tail, &amp;(t-&gt;next));</span><br><span class="line">		__raise_softirq_irqoff(TASKLET_SOFTIRQ);</span><br><span class="line">		local_irq_enable();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>到此timer和tasklet的工作流程就基本整理完了；还有很多细节可能没有关注到，后续有必要在更新！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/16/Linux-irq-bh-tasklet-timer/" data-id="cjx4s5fi80027t0ii6x2ep3ew" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/20/Linux-irq-bh-workqueue/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Linux中断下半部之workqueue
        
      </div>
    </a>
  
  
    <a href="/2019/04/10/Linux-kernel-softirq/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux内核的软中断机制</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AIDL/">AIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">9</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HIDL/">HIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/driver/">driver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实战/">实战</a><span class="tag-list-count">5</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稳定性/">稳定性</a><span class="tag-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AIDL/" style="font-size: 10px;">AIDL</a> <a href="/tags/Android/" style="font-size: 16px;">Android</a> <a href="/tags/HIDL/" style="font-size: 10px;">HIDL</a> <a href="/tags/Linux/" style="font-size: 18px;">Linux</a> <a href="/tags/driver/" style="font-size: 10px;">driver</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/实战/" style="font-size: 12px;">实战</a> <a href="/tags/稳定性/" style="font-size: 14px;">稳定性</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/06/15/Linux-system-ipc/">Linux进程间通信机制</a>
          </li>
        
          <li>
            <a href="/2019/06/01/Android-hidl-sample-impletment/">Android9.0 HIDL 学习</a>
          </li>
        
          <li>
            <a href="/2019/05/26/Android-sub-system-impletment/">实现一个简单的android子系统</a>
          </li>
        
          <li>
            <a href="/2019/05/25/Linux-global-data-overflow/">全局数据踩踏问题</a>
          </li>
        
          <li>
            <a href="/2019/05/22/Qcom-watchdog/">高通watchdog驱动分析</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 JoyYoung<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>