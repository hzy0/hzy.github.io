<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Android binder机制学习 | JoyYoung&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="了解android IPC 之binder的实现">
<meta name="keywords" content="Android,学习">
<meta property="og:type" content="article">
<meta property="og:title" content="Android binder机制学习">
<meta property="og:url" content="http://yoursite.com/2019/03/26/Android-IPC-binder/index.html">
<meta property="og:site_name" content="JoyYoung&#39;s blog">
<meta property="og:description" content="了解android IPC 之binder的实现">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/main-structs.png">
<meta property="og:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/entire-flow.png">
<meta property="og:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/manager-init.PNG">
<meta property="og:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/BpServiceManager.PNG">
<meta property="og:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/add-service-data.PNG">
<meta property="og:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/binder-proc.PNG">
<meta property="og:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/binder-buffers.PNG">
<meta property="og:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/binder_node-service.PNG">
<meta property="og:updated_time" content="2019-08-19T14:31:15.832Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Android binder机制学习">
<meta name="twitter:description" content="了解android IPC 之binder的实现">
<meta name="twitter:image" content="http://yoursite.com/2019/03/26/Android-IPC-binder/main-structs.png">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoyYoung&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Android-IPC-binder" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/03/26/Android-IPC-binder/" class="article-date">
  <time datetime="2019-03-26T15:00:00.000Z" itemprop="datePublished">2019-03-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Android binder机制学习
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="Binder驱动"><a href="#Binder驱动" class="headerlink" title="Binder驱动"></a>Binder驱动</h2><p>Binder驱动是Android专用进程间通信的一个驱动程序；除了内存，不涉及外设。Binder驱动代码的实现放在内核的kernel/msm-4.9/drivers/android/binder.c中。</p>
<h4 id="配置"><a href="#配置" class="headerlink" title="配置"></a>配置</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># android专用控制宏</span></span><br><span class="line">CONFIG_ANDROID=y</span><br><span class="line"><span class="comment"># android binder驱动宏</span></span><br><span class="line">CONFIG_ANDROID_BINDER_IPC=y</span><br><span class="line"><span class="comment"># android binder驱动需要创建的设备，android8.0之前只有binder，后两者是因treble框架添加的</span></span><br><span class="line"><span class="comment"># 三者本质上没有什么区别，只是对应了三个binder上下文</span></span><br><span class="line"><span class="comment"># 不管是AIDL使用binder，HIDL使用hwbinder，vndbinder则是vendor厂商组件可以用他来通信</span></span><br><span class="line">CONFIG_ANDROID_BINDER_DEVICES=<span class="string">"binder,hwbinder,vndbinder"</span></span><br></pre></td></tr></table></figure>

<h4 id="初始化"><a href="#初始化" class="headerlink" title="初始化"></a>初始化</h4><p>Binder驱动的初始化流程在函数binder_init完成；负责以下几点初始化工作：</p>
<p>1、binder内存缓冲池初始化，注册内存页面回收shrinker</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_alloc_shrinker_init</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	list_lru_init(&amp;binder_alloc_lru);</span><br><span class="line">	register_shrinker(&amp;binder_shrinker);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建相关的调试目录</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">binder_debugfs_dir_entry_root = debugfs_create_dir(<span class="string">"binder"</span>, <span class="literal">NULL</span>);</span><br><span class="line"><span class="keyword">if</span> (binder_debugfs_dir_entry_root)</span><br><span class="line">	binder_debugfs_dir_entry_proc = debugfs_create_dir(<span class="string">"proc"</span>,</span><br><span class="line">					 binder_debugfs_dir_entry_root);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (binder_debugfs_dir_entry_root) &#123;</span><br><span class="line">	debugfs_create_file(<span class="string">"state"</span>,</span><br><span class="line">			    S_IRUGO,</span><br><span class="line">			    binder_debugfs_dir_entry_root,</span><br><span class="line">			    <span class="literal">NULL</span>,</span><br><span class="line">			    &amp;binder_state_fops);</span><br><span class="line">	debugfs_create_file(<span class="string">"stats"</span>,</span><br><span class="line">			    S_IRUGO,</span><br><span class="line">			    binder_debugfs_dir_entry_root,</span><br><span class="line">			    <span class="literal">NULL</span>,</span><br><span class="line">			    &amp;binder_stats_fops);</span><br><span class="line">	debugfs_create_file(<span class="string">"transactions"</span>,</span><br><span class="line">			    S_IRUGO,</span><br><span class="line">			    binder_debugfs_dir_entry_root,</span><br><span class="line">			    <span class="literal">NULL</span>,</span><br><span class="line">			    &amp;binder_transactions_fops);</span><br><span class="line">	debugfs_create_file(<span class="string">"transaction_log"</span>,</span><br><span class="line">			    S_IRUGO,</span><br><span class="line">			    binder_debugfs_dir_entry_root,</span><br><span class="line">			    &amp;binder_transaction_log,</span><br><span class="line">			    &amp;binder_transaction_log_fops);</span><br><span class="line">	debugfs_create_file(<span class="string">"failed_transaction_log"</span>,</span><br><span class="line">			    S_IRUGO,</span><br><span class="line">			    binder_debugfs_dir_entry_root,</span><br><span class="line">			    &amp;binder_transaction_log_failed,</span><br><span class="line">			    &amp;binder_transaction_log_fops);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>目录内容大致如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">1|TB-XXXXX:/d/binder # ls -l</span><br><span class="line">total 0</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 03:00 failed_transaction_log</span><br><span class="line">drwxr-xr-x 2 root root 0 2019-01-04 09:12 proc</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 03:00 state</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 03:00 stats</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 03:00 transaction_log</span><br><span class="line">-r--r--r-- 1 root root 0 1970-01-01 03:00 transactions</span><br><span class="line">TB-XXXXX:/d/binder # cd proc/</span><br><span class="line">TB-XXXXX:/d/binder/proc # ls</span><br><span class="line">10091 2339 27699 27965 3129 3387 412 435  505 510  517 523 529 536 542  568 662  697  723 759  772  822 937</span><br><span class="line">10861 2368 2779  28393 3131 3396 413 436  506 5126 518 524 532 538 5489 633 664  6984 733 7610 792  858 9954</span><br><span class="line">1409  2517 27849 2900  3330 3434 414 451  507 514  519 526 533 539 554  634 6720 699  737 7614 794  870</span><br><span class="line">20010 2553 27854 29531 3359 3447 420 4842 508 515  520 527 534 540 555  643 674  703  745 767  8014 897</span><br><span class="line">20069 2577 27914 2974  3379 3490 434 504  509 516  522 528 535 541 567  644 691  7188 747 768  814  908</span><br></pre></td></tr></table></figure>

<p>3、设备和上下文；从内核配置我们知道这里要初始化三个设备，但是流程是完全一样的。主要是分配相关的数据结构并注册对应的misc字符设备；为上层提供操作binder驱动的接口。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Copy the module_parameter string, because we don't want to</span></span><br><span class="line"><span class="comment"> * tokenize it in-place.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">device_names = kzalloc(<span class="built_in">strlen</span>(binder_devices_param) + <span class="number">1</span>, GFP_KERNEL);</span><br><span class="line"><span class="keyword">if</span> (!device_names) &#123;</span><br><span class="line">	ret = -ENOMEM;</span><br><span class="line">	<span class="keyword">goto</span> err_alloc_device_names_failed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">strcpy</span>(device_names, binder_devices_param);</span><br><span class="line"></span><br><span class="line"><span class="keyword">while</span> ((device_name = strsep(&amp;device_names, <span class="string">","</span>))) &#123;</span><br><span class="line">	ret = init_binder_device(device_name);</span><br><span class="line">	<span class="keyword">if</span> (ret)</span><br><span class="line">		<span class="keyword">goto</span> err_init_binder_device_failed;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>设备节点如下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TB-XXXXX:/dev # ls -lZ | grep binder</span><br><span class="line">crw-rw-rw- 1 root      root            u:object_r:binder_device:s0                10,  59 1970-03-01 07:30 binder</span><br><span class="line">crw-rw-rw- 1 root      root            u:object_r:hwbinder_device:s0              10,  58 1970-03-01 07:30 hwbinder</span><br><span class="line">crw-rw-rw- 1 root      root            u:object_r:vndbinder_device:s0             10,  57 1970-03-01 07:30 vndbinder</span><br></pre></td></tr></table></figure>

<p>主要的结构体和设备操作符大致的关系如下,主要的数据结构有binder_device（设备）、binder_context（上下文）和binder_proc（进程在binder驱动的抽象）、binder_node（binder实体，代表一个binder实体对象，比如我们注册的一个binder服务）、binder_alloc（内存管理）等。主要的操作集合函数有binder_open（打开binder设备，每个进程只打开一次）、binder_mmap（内存映射）、binder_ioctl（binder通信的操作集合）等。binder通信的操作和数据流程不在这里体现。</p>
<p><img src="/2019/03/26/Android-IPC-binder/main-structs.png" alt="1558937743534"></p>
<h2 id="服务管理"><a href="#服务管理" class="headerlink" title="服务管理"></a>服务管理</h2><p>在查询了很多资料和阅读了相关源码后整理的一个服务管理者的流程和相关组件关系的一些细节，为了方便自己查阅。</p>
<p><img src="/2019/03/26/Android-IPC-binder/entire-flow.png" alt="entire"></p>
<h4 id="管理者"><a href="#管理者" class="headerlink" title="管理者"></a>管理者</h4><p>看看服务管理者进程，这里面有三个，分别对应三个binder域的。其实三个进程的流程和功能基本是一样的，只是selinux角色和权限不同。以servicemanager为例分析。</p>
<p>hwservicemanagerde源码目录：system/hwservicemanager</p>
<p>servicemanager和vndservicemanager源码目录: frameworks/native/cmds/servicemanager/</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">TB-XXXXX:/dev # ps -eZ | grep manager</span><br><span class="line">u:r:servicemanager:s0          system         412     1   11936   2804 binder_thread_read  0 S servicemanager</span><br><span class="line">u:r:hwservicemanager:s0        system         413     1 2125360   3856 binder_thread_read  0 S hwservicemanager</span><br><span class="line">u:r:vndservicemanager:s0       system         414     1   12648   2584 binder_thread_read  0 S vndservicemanager</span><br></pre></td></tr></table></figure>

<h4 id="启动流程"><a href="#启动流程" class="headerlink" title="启动流程"></a>启动流程</h4><h5 id="servicemanager-rc启动脚本"><a href="#servicemanager-rc启动脚本" class="headerlink" title="servicemanager.rc启动脚本"></a>servicemanager.rc启动脚本</h5><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">service servicemanager /system/bin/servicemanager</span><br><span class="line">    # 类别，具有相同类名的service可以一起启动和停止</span><br><span class="line">    class core animation</span><br><span class="line">    # 用户</span><br><span class="line">    user system</span><br><span class="line">    # 用户组</span><br><span class="line">    group system readproc</span><br><span class="line">    # init进程，Service-&gt;Reap函数；init进程收到子进程退出信号后会调用对应进程的sevice进行Reap</span><br><span class="line">    # critical代表是关键进程，4分钟内crash4次，则系统重启进入recovery mode</span><br><span class="line">    critical</span><br><span class="line">    # onrestart，当进程退出时需重启以下进程</span><br><span class="line">    onrestart restart healthd</span><br><span class="line">    onrestart restart zygote</span><br><span class="line">    onrestart restart audioserver</span><br><span class="line">    onrestart restart media</span><br><span class="line">    onrestart restart surfaceflinger</span><br><span class="line">    onrestart restart inputflinger</span><br><span class="line">    onrestart restart drm</span><br><span class="line">    onrestart restart cameraserver</span><br><span class="line">    onrestart restart keystore</span><br><span class="line">    onrestart restart gatekeeperd</span><br><span class="line">    # cgroup相关</span><br><span class="line">    writepid /dev/cpuset/system-background/tasks</span><br><span class="line">    # 关机流程中的critical进程，从DoReboot函数可知，在进行内核关机前不停止该服务</span><br><span class="line">    shutdown critical</span><br></pre></td></tr></table></figure>

<h5 id="初始化流程图"><a href="#初始化流程图" class="headerlink" title="初始化流程图"></a>初始化流程图</h5><p><img src="/2019/03/26/Android-IPC-binder/manager-init.PNG" alt="初始化"></p>
<h5 id="service-manager-c"><a href="#service-manager-c" class="headerlink" title="service_manager.c"></a>service_manager.c</h5><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">main</span><span class="params">(<span class="keyword">int</span> argc, <span class="keyword">char</span>** argv)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_state</span> *<span class="title">bs</span>;</span></span><br><span class="line">    <span class="keyword">union</span> selinux_callback cb;</span><br><span class="line">    <span class="keyword">char</span> *driver;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 没有通过启动参数指定目标binder设备时，就是默认的/dev/binder</span></span><br><span class="line">    <span class="keyword">if</span> (argc &gt; <span class="number">1</span>) &#123;</span><br><span class="line">        driver = argv[<span class="number">1</span>];</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        driver = <span class="string">"/dev/binder"</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// step1：打开biner驱动，映射128K的内存</span></span><br><span class="line">    bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">    <span class="keyword">if</span> (!bs) &#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">        ALOGW(<span class="string">"failed to open binder driver %s\n"</span>, driver);</span><br><span class="line">        <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">            sleep(UINT_MAX);</span><br><span class="line">        &#125;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">        ALOGE(<span class="string">"failed to open binder driver %s\n"</span>, driver);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">// step2：将自己设置成管理者，对应binder驱动ioctl的BINDER_SET_CONTEXT_MGR</span></span><br><span class="line">    <span class="comment">// binder驱动为它创建一个binder_node，代表它的一个bind而实体，存放在binder上下文的binder_context_mgr_node中</span></span><br><span class="line">    <span class="comment">// binder服务管理者是比较特殊的，系统中所有其他的服务必须通过0号索引来访问他</span></span><br><span class="line">    <span class="keyword">if</span> (binder_become_context_manager(bs)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"cannot become context manager (%s)\n"</span>, strerror(errno));</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    cb.func_audit = audit_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_AUDIT, cb);</span><br><span class="line">    cb.func_log = selinux_log_callback;</span><br><span class="line">    selinux_set_callback(SELINUX_CB_LOG, cb);</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> VENDORSERVICEMANAGER</span></span><br><span class="line">    sehandle = selinux_android_vendor_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line">    sehandle = selinux_android_service_context_handle();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    selinux_status_open(<span class="literal">true</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (sehandle == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"SELinux: Failed to acquire sehandle. Aborting.\n"</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (getcon(&amp;service_manager_context) != <span class="number">0</span>) &#123;</span><br><span class="line">        ALOGE(<span class="string">"SELinux: Failed to acquire service_manager context. Aborting.\n"</span>);</span><br><span class="line">        <span class="built_in">abort</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step3：轮训处理binder事务,服务管理者主要的工作是服务的查询和获取</span></span><br><span class="line">    binder_loop(bs, svcmgr_handler);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_loop进入循环等待：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">binder_loop</span><span class="params">(struct binder_state *bs, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> res;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">binder_write_read</span> <span class="title">bwr</span>;</span></span><br><span class="line">    <span class="keyword">uint32_t</span> readbuf[<span class="number">32</span>];</span><br><span class="line"></span><br><span class="line">    bwr.write_size = <span class="number">0</span>;</span><br><span class="line">    bwr.write_consumed = <span class="number">0</span>;</span><br><span class="line">    bwr.write_buffer = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*服务管理者进程只有一个线程，即主线程</span></span><br><span class="line"><span class="comment">     * TB-X505F:/proc/sys/kernel # ps -eT | grep " 383 "</span></span><br><span class="line"><span class="comment">     * system  383   383     1   11936   3088 binder_thread_read  0 S servicemanager</span></span><br><span class="line"><span class="comment">     * 通过BC_ENTER_LOOPER告诉binder驱动自己作为binder事务监听的主线程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">    readbuf[<span class="number">0</span>] = BC_ENTER_LOOPER;</span><br><span class="line">    binder_write(bs, readbuf, <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//开始循环监听binder事件</span></span><br><span class="line">    <span class="keyword">for</span> (;;) &#123;</span><br><span class="line">        <span class="comment">//设置binder_write_read，这里是监听读取binder驱动数据，read缓冲区大小32*4=128Bytes</span></span><br><span class="line">        <span class="comment">//所以设置的是read缓冲区，然后通过ioctl的BINDER_WRITE_READ进入事件等待状态</span></span><br><span class="line">        <span class="comment">//驱动会根据binder_write_read的read_size和write_size判断上层发起的是读操作还是写操作</span></span><br><span class="line">        bwr.read_size = <span class="keyword">sizeof</span>(readbuf);</span><br><span class="line">        bwr.read_consumed = <span class="number">0</span>;</span><br><span class="line">        bwr.read_buffer = (<span class="keyword">uintptr_t</span>) readbuf;</span><br><span class="line"></span><br><span class="line">        res = ioctl(bs-&gt;fd, BINDER_WRITE_READ, &amp;bwr);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"binder_loop: ioctl failed (%s)\n"</span>, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//到这里已经从内核读取到数据，对驱动数据包进行解析，并调用svcmgr_handler作出处理和反馈</span></span><br><span class="line">        res = binder_parse(bs, <span class="number">0</span>, (<span class="keyword">uintptr_t</span>) readbuf, bwr.read_consumed, func);</span><br><span class="line">        <span class="keyword">if</span> (res == <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"binder_loop: unexpected reply?!\n"</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (res &lt; <span class="number">0</span>) &#123;</span><br><span class="line">            ALOGE(<span class="string">"binder_loop: io error %d %s\n"</span>, res, strerror(errno));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_parse解析数据包：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">binder_parse</span><span class="params">(struct binder_state *bs, struct binder_io *bio,</span></span></span><br><span class="line"><span class="function"><span class="params">                 <span class="keyword">uintptr_t</span> ptr, <span class="keyword">size_t</span> size, binder_handler func)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">int</span> r = <span class="number">1</span>;</span><br><span class="line">    <span class="comment">//驱动会设置read_consumed，代表这次读操作消耗了多好buffer，也就是读取到的数据实际的大小</span></span><br><span class="line">    <span class="keyword">uintptr_t</span> end = ptr + (<span class="keyword">uintptr_t</span>) size;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环逐步处理数据包中数据，binder有自己的数据包通用规则，binder通信双方需要约定好具体操作的规则</span></span><br><span class="line">    <span class="keyword">while</span> (ptr &lt; end) &#123;</span><br><span class="line">        <span class="comment">//取出缓冲区中第一个uint32_t型数据，这代表一个binder命令</span></span><br><span class="line">        <span class="keyword">uint32_t</span> cmd = *(<span class="keyword">uint32_t</span> *) ptr;</span><br><span class="line">        ptr += <span class="keyword">sizeof</span>(<span class="keyword">uint32_t</span>);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRACE</span></span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"%s:\n"</span>, cmd_name(cmd));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">switch</span>(cmd) &#123;</span><br><span class="line">        <span class="comment">//空操作</span></span><br><span class="line">        <span class="keyword">case</span> BR_NOOP:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">// 表示本地端发起的binder操作，如BC_TRANSACTION或BC_REPLY已经在驱动完成</span></span><br><span class="line">        <span class="comment">// 不涉及到远程端的反馈，这是驱动反馈给发送者的事件，不管是同步调用还是异步调用都可以收到此消息</span></span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//强弱引用相关的操作，服务管理者不做任何操作</span></span><br><span class="line">        <span class="keyword">case</span> BR_INCREFS:</span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE:</span><br><span class="line">        <span class="keyword">case</span> BR_RELEASE:</span><br><span class="line">        <span class="keyword">case</span> BR_DECREFS:</span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> TRACE</span></span><br><span class="line">            <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>,<span class="string">"  %p, %p\n"</span>, (<span class="keyword">void</span> *)ptr, (<span class="keyword">void</span> *)(ptr + <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(struct binder_ptr_cookie);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//对应发送方的BC_TRANSACTION，对方发起BC_TRANSACTION，binder驱动完成路由选择分发给本地那个bidner线程处理后，本地的对应线程可以收到这个事件</span></span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> = (<span class="title">struct</span> <span class="title">binder_transaction_data</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(*txn)) &#123;</span><br><span class="line">                ALOGE(<span class="string">"parse: txn too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (func) &#123;</span><br><span class="line">                <span class="keyword">unsigned</span> rdata[<span class="number">256</span>/<span class="number">4</span>];</span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">msg</span>;</span></span><br><span class="line">                <span class="class"><span class="keyword">struct</span> <span class="title">binder_io</span> <span class="title">reply</span>;</span></span><br><span class="line">                <span class="keyword">int</span> res;</span><br><span class="line"></span><br><span class="line">                bio_init(&amp;reply, rdata, <span class="keyword">sizeof</span>(rdata), <span class="number">4</span>);</span><br><span class="line">                bio_init_from_txn(&amp;msg, txn);</span><br><span class="line">                <span class="comment">//调用svcmgr_handler进行实际的binger事务处理</span></span><br><span class="line">                res = func(bs, txn, &amp;msg, &amp;reply);</span><br><span class="line">                <span class="comment">//对方发起的请求带TF_ONE_WAY标志，也就是异步类型的，不需要回复，那就直接释放binder传输用的缓冲区</span></span><br><span class="line">                <span class="keyword">if</span> (txn-&gt;flags &amp; TF_ONE_WAY) &#123;</span><br><span class="line">                    binder_free_buffer(bs, txn-&gt;data.ptr.buffer);</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">//如果是同步调用，则先BC_REPLY，再释放缓冲区</span></span><br><span class="line">                    binder_send_reply(bs, &amp;reply, txn-&gt;data.ptr.buffer, res);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//对应发送方的BC_REPLY，对方处理完本地发起的BC_TRANSACTION后，发起BC_REPLY，binder驱动完成路由选择分发给本地这个bidner线程，</span></span><br><span class="line">        <span class="comment">//也就是说BR_REPLY是远程端对本地发起的BC_TRANSACTION的一个回复消息，用于同步调用</span></span><br><span class="line">        <span class="keyword">case</span> BR_REPLY: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> *<span class="title">txn</span> = (<span class="title">struct</span> <span class="title">binder_transaction_data</span> *) <span class="title">ptr</span>;</span></span><br><span class="line">            <span class="keyword">if</span> ((end - ptr) &lt; <span class="keyword">sizeof</span>(*txn)) &#123;</span><br><span class="line">                ALOGE(<span class="string">"parse: reply too small!\n"</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            binder_dump_txn(txn);</span><br><span class="line">            <span class="keyword">if</span> (bio) &#123;</span><br><span class="line">                bio_init_from_txn(bio, txn);</span><br><span class="line">                bio = <span class="number">0</span>;</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                <span class="comment">/* todo FREE BUFFER */</span></span><br><span class="line">            &#125;</span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(*txn);</span><br><span class="line">            r = <span class="number">0</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//死亡通知，各个系统服务往管理者注册自己的时候，管理者会为每个服务注册一个死亡通知</span></span><br><span class="line">        <span class="comment">//当一个binder服务死亡后，服务者需要清理和回收相关资源</span></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_BINDER: &#123;</span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">binder_death</span> *<span class="title">death</span> = (<span class="title">struct</span> <span class="title">binder_death</span> *)(<span class="title">uintptr_t</span>) *(<span class="title">binder_uintptr_t</span> *)<span class="title">ptr</span>;</span></span><br><span class="line">            ptr += <span class="keyword">sizeof</span>(<span class="keyword">binder_uintptr_t</span>);</span><br><span class="line">            death-&gt;func(bs, death-&gt;ptr);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            r = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            r = <span class="number">-1</span>;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            ALOGE(<span class="string">"parse: OOPS %d\n"</span>, cmd);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> r;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<strong><u>服务管理者的角度</u></strong>看看add service的svcmgr_handler函数具体事务处理，忽略具体数据包的解析过程，先理解下流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">do_add_service</span><span class="params">(struct binder_state *bs, <span class="keyword">const</span> <span class="keyword">uint16_t</span> *s, <span class="keyword">size_t</span> len, <span class="keyword">uint32_t</span> handle,</span></span></span><br><span class="line"><span class="function"><span class="params">                   <span class="keyword">uid_t</span> uid, <span class="keyword">int</span> allow_isolated, <span class="keyword">uint32_t</span> dumpsys_priority, <span class="keyword">pid_t</span> spid)</span> </span>&#123;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">svcinfo</span> *<span class="title">si</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//ALOGI("add_service('%s',%x,%s) uid=%d\n", str8(s, len), handle,</span></span><br><span class="line">    <span class="comment">//        allow_isolated ? "allow_isolated" : "!allow_isolated", uid);</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (!handle || (len == <span class="number">0</span>) || (len &gt; <span class="number">127</span>))</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//判断对方是否有add service的权限</span></span><br><span class="line">    <span class="keyword">if</span> (!svc_can_register(s, len, spid, uid)) &#123;</span><br><span class="line">        ALOGE(<span class="string">"add_service('%s',%x) uid=%d - PERMISSION DENIED\n"</span>,</span><br><span class="line">             str8(s, len), handle, uid);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    si = find_svc(s, len);</span><br><span class="line">    <span class="keyword">if</span> (si) &#123;</span><br><span class="line">        <span class="comment">//通过服务名可以找对对应的服务，说明已经注册过；对应服务的hangle存在则先释放其handle在重新赋值</span></span><br><span class="line">        <span class="keyword">if</span> (si-&gt;handle) &#123;</span><br><span class="line">            ALOGE(<span class="string">"add_service('%s',%x) uid=%d - ALREADY REGISTERED, OVERRIDE\n"</span>,</span><br><span class="line">                 str8(s, len), handle, uid);</span><br><span class="line">            svcinfo_death(bs, si);</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">    <span class="comment">//通常服务注册流程走的是这个分支，初始化服务相关信息，并将其加入svclist列表中</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        si = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(*si) + (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        <span class="keyword">if</span> (!si) &#123;</span><br><span class="line">            ALOGE(<span class="string">"add_service('%s',%x) uid=%d - OUT OF MEMORY\n"</span>,</span><br><span class="line">                 str8(s, len), handle, uid);</span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        si-&gt;handle = handle;</span><br><span class="line">        si-&gt;len = len;</span><br><span class="line">        <span class="built_in">memcpy</span>(si-&gt;name, s, (len + <span class="number">1</span>) * <span class="keyword">sizeof</span>(<span class="keyword">uint16_t</span>));</span><br><span class="line">        si-&gt;name[len] = <span class="string">'\0'</span>;</span><br><span class="line">        si-&gt;death.func = (<span class="keyword">void</span>*) svcinfo_death;</span><br><span class="line">        si-&gt;death.ptr = si;</span><br><span class="line">        si-&gt;allow_isolated = allow_isolated;</span><br><span class="line">        si-&gt;dumpsys_priority = dumpsys_priority;</span><br><span class="line">        si-&gt;next = svclist;</span><br><span class="line">        svclist = si;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//远程服务注册成功，通过BC_ACQUIRE对服务在远程中的对象进行强引用+1</span></span><br><span class="line">    binder_acquire(bs, handle);</span><br><span class="line">    <span class="comment">//为远程服务实体注册死亡通知</span></span><br><span class="line">    binder_link_to_death(bs, handle, &amp;si-&gt;death);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从<u><strong>普通binder服务的角度</strong></u>看看add service的过程，以audioserver注册AudioPolicyService的过程为例，尽量深入到数据打包传输细节。audioserver这个进程至少注册两个binder服务实体，比如audioflinger、audiopolicy。我们以audiopolicy为例看看服务的注册过程；入口是Frameworks/av/Media/audioserver/main_audioserver.cpp-&gt;main-&gt;AudioPolicyService::instantiate()-&gt;BinderService::instantiate-&gt;BinderService::publish。</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> status_t <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>,<span class="keyword">int</span> dumpFlags = IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT)</span> </span>&#123;</span><br><span class="line">    <span class="comment">//step1：获取servicemanager本地代理对象BpBinder</span></span><br><span class="line">    sp&lt;IServiceManager&gt; sm(defaultServiceManager());</span><br><span class="line">    <span class="comment">//step2：addService是servicemanager的本地代理对象，是一个同步调用，会阻塞</span></span><br><span class="line">    <span class="keyword">return</span> sm-&gt;addService(String16(SERVICE::getServiceName()), <span class="keyword">new</span> SERVICE(), allowIsolated,dumpFlags);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>step1中的是如何得到一个handle为0的IServiceManager对象的强引用的？在IServiceManager.cpp可以看到：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">sp&lt;IServiceManager&gt; defaultServiceManager()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (gDefaultServiceManager != <span class="literal">NULL</span>) <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line"></span><br><span class="line">    &#123;</span><br><span class="line">        AutoMutex _l(gDefaultServiceManagerLock);</span><br><span class="line">        <span class="keyword">while</span> (gDefaultServiceManager == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            gDefaultServiceManager = interface_cast&lt;IServiceManager&gt;(</span><br><span class="line">                ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>));</span><br><span class="line">            <span class="keyword">if</span> (gDefaultServiceManager == <span class="literal">NULL</span>)</span><br><span class="line">                sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> gDefaultServiceManager;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>先获取一本BpBinder对象，其handle为0：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ProcessState::self()-&gt;getContextObject(<span class="literal">NULL</span>)</span><br><span class="line">--&gt;getStrongProxyForHandle(<span class="number">0</span>)</span><br><span class="line">----&gt;BpBinder::create(<span class="number">0</span>)</span><br><span class="line">------&gt;返回一个BpBinder对象：BpBinder(<span class="number">0</span>, trackedUid);</span><br></pre></td></tr></table></figure>

<p>然后对这个BpBinder对象进行类型转换：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//interface_cast这是一个模板函数</span></span><br><span class="line"><span class="keyword">template</span>&lt;<span class="keyword">typename</span> INTERFACE&gt;</span><br><span class="line"><span class="keyword">inline</span> sp&lt;INTERFACE&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> INTERFACE::asInterface(obj);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//代入interface_cast&lt;IServiceManager&gt;（BpBinder *）后得到</span></span><br><span class="line"><span class="keyword">inline</span> sp&lt;IServiceManager&gt; interface_cast(<span class="keyword">const</span> sp&lt;IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">return</span> IServiceManager::asInterface(obj);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>那IServiceManager的asInterface是怎么申明定义的呢？</p>
<p>在IServiceManager.h中可以通过DECLARE_META_INTERFACE来实现申明：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">IServiceManager</span> :</span> <span class="keyword">public</span> IInterface</span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    DECLARE_META_INTERFACE(ServiceManager)</span><br><span class="line">    ......</span><br></pre></td></tr></table></figure>

<p>在IServiceManager.cpp中可以看通过IMPLEMENT_META_INTERFACE实现定义：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">IMPLEMENT_META_INTERFACE(ServiceManager, <span class="string">"android.os.IServiceManager"</span>);</span><br><span class="line"><span class="comment">//按IMPLEMENT_META_INTERFACE宏进行替换展开得到：</span></span><br><span class="line"><span class="keyword">const</span> ::android::String16 IServiceManager::descriptor(<span class="string">"android.os.IServiceManager"</span>);</span><br><span class="line"><span class="keyword">const</span> ::android::String16&amp; IServiceManager::getInterfaceDescriptor() <span class="keyword">const</span> &#123;             </span><br><span class="line">        <span class="keyword">return</span> IServiceManager::descriptor;</span><br><span class="line">&#125;</span><br><span class="line">::android::sp&lt;IServiceManager&gt; IServiceManager::asInterface(</span><br><span class="line">            <span class="keyword">const</span> ::android::sp&lt;::android::IBinder&gt;&amp; obj)</span><br><span class="line">&#123;</span><br><span class="line">    ::android::sp&lt;I##INTERFACE&gt; intr;</span><br><span class="line">    <span class="keyword">if</span> (obj != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        intr = <span class="keyword">static_cast</span>&lt;IServiceManager*&gt;(</span><br><span class="line">            obj-&gt;queryLocalInterface(IServiceManager::descriptor).get());</span><br><span class="line">        <span class="keyword">if</span> (intr == <span class="literal">NULL</span>) &#123;</span><br><span class="line">            intr = <span class="keyword">new</span> BpServiceManager(obj);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> intr;</span><br><span class="line">&#125;</span><br><span class="line">    IServiceManager::IServiceManager() &#123; &#125;</span><br><span class="line">    IServiceManager::~IServiceManager() &#123; &#125;</span><br></pre></td></tr></table></figure>

<p>综上可知defaultServiceManager()得到的是一个BpServiceManager对象，持有一个handle为0的BpBinder对象；代表远程servicemanager在本地端的一个代理对象，后续调用servicemanager都是通过这个代理对象进行的。以BpServiceManager类为例看看上述过程中各个类之间的关系：<img src="/2019/03/26/Android-IPC-binder/BpServiceManager.PNG" alt="类图关系"></p>
<p>回到publish时候调用的addService的代码，将publish模板函数将SERVICE替换成AudioPolicyService后得到：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> status_t <span class="title">publish</span><span class="params">(<span class="keyword">bool</span> allowIsolated = <span class="literal">false</span>,<span class="keyword">int</span> dumpFlags = IServiceManager::DUMP_FLAG_PRIORITY_DEFAULT)</span> </span>&#123;</span><br><span class="line">    ......</span><br><span class="line">    <span class="keyword">return</span> sm-&gt;addService(String16(AudioPolicyService::getServiceName()), <span class="keyword">new</span> AudioPolicyService(), allowIsolated,dumpFlags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入PbServiceManager的addService函数：</span></span><br><span class="line">    <span class="function"><span class="keyword">virtual</span> status_t <span class="title">addService</span><span class="params">(<span class="keyword">const</span> String16&amp; name, <span class="keyword">const</span> sp&lt;IBinder&gt;&amp; service,</span></span></span><br><span class="line"><span class="function"><span class="params">                                <span class="keyword">bool</span> allowIsolated, <span class="keyword">int</span> dumpsysPriority)</span> </span>&#123;</span><br><span class="line">        Parcel data, reply;</span><br><span class="line">        <span class="comment">//写入一个4字节的init型表示StrictModePolicy</span></span><br><span class="line">        <span class="comment">//写入令牌长度</span></span><br><span class="line">        <span class="comment">//写入接口令牌，也就是接口类名字："android.os.IServiceManager"</span></span><br><span class="line">        data.writeInterfaceToken(IServiceManager::getInterfaceDescriptor());</span><br><span class="line">        <span class="comment">//写入服务Int32类型，表示服务名字长度</span></span><br><span class="line">        <span class="comment">//写入要发布的服务名字</span></span><br><span class="line">        data.writeString16(name);</span><br><span class="line">        <span class="comment">//写入AudioPolicyService对象的强引用指针，binder扁平数据封装</span></span><br><span class="line">        data.writeStrongBinder(service);</span><br><span class="line">        <span class="comment">//写入int32代表是否允许隔离</span></span><br><span class="line">        data.writeInt32(allowIsolated ? <span class="number">1</span> : <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//写入ini32代表dumpsys优先级</span></span><br><span class="line">        data.writeInt32(dumpsysPriority);</span><br><span class="line">        <span class="comment">//调用remote对象，也就是BpBinder类型的transact，操作码是ADD_SERVICE_TRANSACTION</span></span><br><span class="line">        <span class="keyword">status_t</span> err = remote()-&gt;transact(ADD_SERVICE_TRANSACTION, data, &amp;reply);</span><br><span class="line">        <span class="keyword">return</span> err == NO_ERROR ? reply.readExceptionCode() : err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * 进入BpBinder的transact函数</span></span><br><span class="line"><span class="comment"> * code为ADD_SERVICE_TRANSACTION</span></span><br><span class="line"><span class="comment"> * data是前面组织好的数据</span></span><br><span class="line"><span class="comment"> * reply用于存放远程端返回的结果</span></span><br><span class="line"><span class="comment"> * flags默认为0，表示同步调用，需要阻塞等待远程端的结果</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">status_t</span> BpBinder::transact(</span><br><span class="line">    <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data, Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// Once a binder has died, it will never come back to life.</span></span><br><span class="line">    <span class="keyword">if</span> (mAlive) &#123;</span><br><span class="line">        <span class="keyword">status_t</span> status = IPCThreadState::self()-&gt;transact(</span><br><span class="line">            mHandle, code, data, reply, flags);</span><br><span class="line">        <span class="keyword">if</span> (status == DEAD_OBJECT) mAlive = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">return</span> status;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> DEAD_OBJECT;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//进入IPCThreadState的transact</span></span><br><span class="line"><span class="keyword">status_t</span> IPCThreadState::transact(<span class="keyword">int32_t</span> handle,</span><br><span class="line">                                  <span class="keyword">uint32_t</span> code, <span class="keyword">const</span> Parcel&amp; data,</span><br><span class="line">                                  Parcel* reply, <span class="keyword">uint32_t</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">status_t</span> err;</span><br><span class="line"></span><br><span class="line">    flags |= TF_ACCEPT_FDS;</span><br><span class="line"></span><br><span class="line">    IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">        TextOutput::Bundle _b(alog);</span><br><span class="line">        alog &lt;&lt; <span class="string">"BC_TRANSACTION thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></span><br><span class="line">            &lt;&lt; handle &lt;&lt; <span class="string">" / code "</span> &lt;&lt; TypeCode(code) &lt;&lt; <span class="string">": "</span></span><br><span class="line">            &lt;&lt; indent &lt;&lt; data &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    LOG_ONEWAY(<span class="string">"&gt;&gt;&gt;&gt; SEND from pid %d uid %d %s"</span>, getpid(), getuid(),</span><br><span class="line">        (flags &amp; TF_ONE_WAY) == <span class="number">0</span> ? <span class="string">"READ REPLY"</span> : <span class="string">"ONE WAY"</span>);</span><br><span class="line">    <span class="comment">//将数据封装成binder_transaction_data，写入mOut</span></span><br><span class="line">    err = writeTransactionData(BC_TRANSACTION, flags, handle, code, data, <span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        <span class="keyword">return</span> (mLastError = err);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//没有TF_ONE_WAY标志，说明是同步调用，需要等待远程端回复</span></span><br><span class="line">    <span class="comment">//waitForResponse做的事情包括将mOut的数据写入binder驱动，然后等待驱动反馈</span></span><br><span class="line">    <span class="keyword">if</span> ((flags &amp; TF_ONE_WAY) == <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) &#123; <span class="comment">// relayout</span></span><br><span class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction 4"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"&gt;&gt;&gt;&gt;&gt;&gt; CALLING transaction %d"</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">        <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">            err = waitForResponse(reply);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            Parcel fakeReply;</span><br><span class="line">            err = waitForResponse(&amp;fakeReply);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">if</span> 0</span></span><br><span class="line">        <span class="keyword">if</span> (code == <span class="number">4</span>) &#123; <span class="comment">// relayout</span></span><br><span class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction 4"</span>);</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            ALOGI(<span class="string">"&lt;&lt;&lt;&lt;&lt;&lt; RETURNING transaction %d"</span>, code);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">        IF_LOG_TRANSACTIONS() &#123;</span><br><span class="line">            TextOutput::Bundle _b(alog);</span><br><span class="line">            alog &lt;&lt; <span class="string">"BR_REPLY thr "</span> &lt;&lt; (<span class="keyword">void</span>*)pthread_self() &lt;&lt; <span class="string">" / hand "</span></span><br><span class="line">                &lt;&lt; handle &lt;&lt; <span class="string">": "</span>;</span><br><span class="line">            <span class="keyword">if</span> (reply) alog &lt;&lt; indent &lt;&lt; *reply &lt;&lt; dedent &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">            <span class="keyword">else</span> alog &lt;&lt; <span class="string">"(none requested)"</span> &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;<span class="comment">//异步调用，不需要等待远程端回复</span></span><br><span class="line">        err = waitForResponse(<span class="literal">NULL</span>, <span class="literal">NULL</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以add service为例看看writeTransactionData这次请求构建出来的mOut内容是怎么样的：<img src="/2019/03/26/Android-IPC-binder/add-service-data.PNG" alt="数据包"></p>
<p>继续看看waitForResponse的流程：</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">status_t</span> IPCThreadState::waitForResponse(Parcel *reply, <span class="keyword">status_t</span> *acquireResult)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">uint32_t</span> cmd;</span><br><span class="line">    <span class="keyword">int32_t</span> err;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//循环处理事务</span></span><br><span class="line">    <span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">        <span class="comment">//talkWithDriver封装binder_write_read结构体，和binder驱动交互，负责两部分内容：</span></span><br><span class="line">        <span class="comment">//对于同步调用，如果mIn为空，则从驱动读取数据到mIn；否则将mOut的数据写入驱动</span></span><br><span class="line">        <span class="comment">//对于异步调用，则只讲mOut发给驱动</span></span><br><span class="line">        <span class="keyword">if</span> ((err=talkWithDriver()) &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        err = mIn.errorCheck();</span><br><span class="line">        <span class="keyword">if</span> (err &lt; NO_ERROR) <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">if</span> (mIn.dataAvail() == <span class="number">0</span>) <span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        cmd = (<span class="keyword">uint32_t</span>)mIn.readInt32(); <span class="comment">//获取mIn的cmd</span></span><br><span class="line"></span><br><span class="line">        IF_LOG_COMMANDS() &#123;</span><br><span class="line">            alog &lt;&lt; <span class="string">"Processing waitForResponse Command: "</span></span><br><span class="line">                &lt;&lt; getReturnString(cmd) &lt;&lt; <span class="built_in">endl</span>;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//这里是驱动反馈上来的各种cmd</span></span><br><span class="line">        <span class="keyword">switch</span> (cmd) &#123;</span><br><span class="line">        <span class="comment">//上次发送mOut的请求在驱动已经完成，这里不是指远程端服务的结果</span></span><br><span class="line">        <span class="comment">//不管是同步还是异步请求，如果驱动阶段完成，都会受到该事件</span></span><br><span class="line">        <span class="keyword">case</span> BR_TRANSACTION_COMPLETE:</span><br><span class="line">            <span class="keyword">if</span> (!reply &amp;&amp; !acquireResult) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="comment">//表示远程端服务已死</span></span><br><span class="line">        <span class="keyword">case</span> BR_DEAD_REPLY:</span><br><span class="line">            err = DEAD_OBJECT;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_FAILED_REPLY:</span><br><span class="line">            err = FAILED_TRANSACTION;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">case</span> BR_ACQUIRE_RESULT:</span><br><span class="line">            &#123;</span><br><span class="line">                ALOG_ASSERT(acquireResult != <span class="literal">NULL</span>, <span class="string">"Unexpected brACQUIRE_RESULT"</span>);</span><br><span class="line">                <span class="keyword">const</span> <span class="keyword">int32_t</span> result = mIn.readInt32();</span><br><span class="line">                <span class="keyword">if</span> (!acquireResult) <span class="keyword">continue</span>;</span><br><span class="line">                *acquireResult = result ? NO_ERROR : INVALID_OPERATION;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line">        <span class="comment">//远程服务端对上次的请求BC_TRASATION有了结果反馈回来</span></span><br><span class="line">        <span class="keyword">case</span> BR_REPLY:</span><br><span class="line">            &#123;</span><br><span class="line">                binder_transaction_data tr;</span><br><span class="line">                err = mIn.read(&amp;tr, <span class="keyword">sizeof</span>(tr));</span><br><span class="line">                ALOG_ASSERT(err == NO_ERROR, <span class="string">"Not enough command data for brREPLY"</span>);</span><br><span class="line">                <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">                <span class="keyword">if</span> (reply) &#123;</span><br><span class="line">                    <span class="keyword">if</span> ((tr.flags &amp; TF_STATUS_CODE) == <span class="number">0</span>) &#123;</span><br><span class="line">                        reply-&gt;ipcSetDataReference(</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>),</span><br><span class="line">                            freeBuffer, <span class="keyword">this</span>);</span><br><span class="line">                    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                        err = *<span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">status_t</span>*&gt;(tr.data.ptr.buffer);</span><br><span class="line">                        freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                            tr.data_size,</span><br><span class="line">                            <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                            tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    freeBuffer(<span class="literal">NULL</span>,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">uint8_t</span>*&gt;(tr.data.ptr.buffer),</span><br><span class="line">                        tr.data_size,</span><br><span class="line">                        <span class="keyword">reinterpret_cast</span>&lt;<span class="keyword">const</span> <span class="keyword">binder_size_t</span>*&gt;(tr.data.ptr.offsets),</span><br><span class="line">                        tr.offsets_size/<span class="keyword">sizeof</span>(<span class="keyword">binder_size_t</span>), <span class="keyword">this</span>);</span><br><span class="line">                    <span class="keyword">continue</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">goto</span> finish;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//executeCommand是自己作为服务端接收远程端请求的事务处理</span></span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            err = executeCommand(cmd);</span><br><span class="line">            <span class="keyword">if</span> (err != NO_ERROR) <span class="keyword">goto</span> finish;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">finish:</span><br><span class="line">    <span class="keyword">if</span> (err != NO_ERROR) &#123;</span><br><span class="line">        <span class="keyword">if</span> (acquireResult) *acquireResult = err;</span><br><span class="line">        <span class="keyword">if</span> (reply) reply-&gt;setError(err);</span><br><span class="line">        mLastError = err;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>到这里，上层的流程就结束了，如果忽略驱动部分的逻辑，那么这次add_service的调用会导致servicemanager服务响应BR_TRANSATION事件-&gt;SVC_MGR_ADD_SERVICE流程。</p>
<h2 id="驱动细节"><a href="#驱动细节" class="headerlink" title="驱动细节"></a>驱动细节</h2><p>通过以上整理我们基本知道了binder驱动提供了IPC功能给上层使用，用户空间的进程是如何调用binder驱动发起IPC的过程；忽略驱动细节的情况下我们也能知道客户端和远程服务端通过binder交互的基本流程和代码定位。接下来需要深入到binder驱动的细节了解binder驱动的实现。</p>
<p>Android8.0之后会有三个binder驱动上下文，但是对于驱动部分流程是一样的。每一个binder驱动上下文都提供了一组操作函数，供用户空间使用：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">binder_fops</span> = &#123;</span></span><br><span class="line">	.owner = THIS_MODULE,</span><br><span class="line">	.poll = binder_poll, <span class="comment">//这个主要是为了用户空间可以对binder驱动文件句柄使用epoll机制来轮训，一般不适用</span></span><br><span class="line">	.unlocked_ioctl = binder_ioctl,</span><br><span class="line">	.compat_ioctl = binder_ioctl,</span><br><span class="line">	.mmap = binder_mmap,</span><br><span class="line">	.open = binder_open,</span><br><span class="line">	.flush = binder_flush,</span><br><span class="line">	.release = binder_release,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="binder-open"><a href="#binder-open" class="headerlink" title="binder_open"></a>binder_open</h4><p>这个函数主要是打开binder设备节点，返回一个fd。没有用户空间的进程拥有一个ProcessState单例，也就是么个进程只能打开一次binder设备。binder_open为进程创建一个binder_proc对象（进程在binder驱动上下文中的代表），初始化相关的内容，并将其加到全局的哈希列表binder_procs中。</p>
<p><img src="/2019/03/26/Android-IPC-binder/binder-proc.PNG" alt="binder_procs"></p>
<p>binder_proc各成员的含义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">proc_node</span>;</span> <span class="comment">//用于插入binder_procs链表的节点</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">threads</span>;</span>      <span class="comment">//该进程所有的binder线程</span></span><br><span class="line">    <span class="comment">//该进程注册的所有binder实体，binder_node，代表一个binder服务</span></span><br><span class="line">    <span class="comment">//所有的binder node按ptr为索引插入nodes红黑树；ptr是binder_node在用户空间所指向的binder服务</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">nodes</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_desc</span>;</span><span class="comment">//本进程引用的binder node红黑树，按handle索引</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">refs_by_node</span>;</span><span class="comment">//本进程引用的binder node红黑树，按node索引</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">waiting_threads</span>;</span> <span class="comment">//该进程所有正在等待的binder线程，也就是空闲的binder线程</span></span><br><span class="line">	<span class="keyword">int</span> pid;          <span class="comment">//进程的pid</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">tsk</span>;</span><span class="comment">//进程的PCB</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">deferred_work_node</span>;</span></span><br><span class="line">	<span class="keyword">int</span> deferred_work;</span><br><span class="line">	<span class="keyword">bool</span> is_dead;    <span class="comment">//进程是否已经死亡</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">todo</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_stats</span> <span class="title">stats</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">delivered_death</span>;</span><span class="comment">//该进程所关心的</span></span><br><span class="line">	<span class="keyword">int</span> max_threads; <span class="comment">//支持的binder线程最大数量，进程可以通过BINDER_SET_MAX_THREADS设置，默认是15个，特殊进程可能会自己改变这个值，比如system_server是32</span></span><br><span class="line">	<span class="keyword">int</span> requested_threads; <span class="comment">//已经申请但是未启动的binder线程</span></span><br><span class="line">	<span class="keyword">int</span> requested_threads_started; <span class="comment">//已经申请并且已经启动的线程</span></span><br><span class="line">	<span class="keyword">int</span> tmp_ref;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_priority</span> <span class="title">default_priority</span>;</span> <span class="comment">//进程默认的优先级和调度策略</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">debugfs_entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_alloc</span> <span class="title">alloc</span>;</span> <span class="comment">//内存分配器</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_context</span> *<span class="title">context</span>;</span><span class="comment">//所属的binder上下文</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> inner_lock;<span class="comment">//内部所</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> outer_lock;<span class="comment">//外部锁</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="binder-mmap"><a href="#binder-mmap" class="headerlink" title="binder_mmap"></a>binder_mmap</h4><p>在进程打开了binder设备后，必须要调用mmap映射一段内存到binder设备的fd；binder驱动完成内存映射的工作在binder_mmap完成。用户空间映射这段内存的flags为PROT_READ，代表用户空间只能读取这段虚拟内存，而不能直接写；通过ioctl的BINDER_WRITE_READ写入驱动中，或者通过它指定的地址去读。</p>
<p>1、service_manager映射了128k的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">bs = binder_open(driver, <span class="number">128</span>*<span class="number">1024</span>);</span><br><span class="line">--&gt;bs-&gt;mapped = mmap(<span class="literal">NULL</span>, mapsize, PROT_READ, MAP_PRIVATE, bs-&gt;fd, <span class="number">0</span>);</span><br></pre></td></tr></table></figure>

<p>2、一般的进程映射接近1M的大小</p>
<figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">define</span> BINDER_VM_SIZE ((1 * 1024 * 1024) - sysconf(_SC_PAGE_SIZE) * 2)</span></span><br></pre></td></tr></table></figure>

<p>binder_mmap驱动源码：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_mmap</span><span class="params">(struct file *filp, struct vm_area_struct *vma)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *failure_string;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;tsk != current-&gt;group_leader)</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//参数vm_area_struct *vma描述了一块连续的用户态虚拟内存地址空间</span></span><br><span class="line">    <span class="comment">//申请空间不能大于4M，如果大于4M就改为4M</span></span><br><span class="line">	<span class="keyword">if</span> ((vma-&gt;vm_end - vma-&gt;vm_start) &gt; SZ_4M)</span><br><span class="line">		vma-&gt;vm_end = vma-&gt;vm_start + SZ_4M;</span><br><span class="line"></span><br><span class="line">	binder_debug(BINDER_DEBUG_OPEN_CLOSE,</span><br><span class="line">		     <span class="string">"%s: %d %lx-%lx (%ld K) vma %lx pagep %lx\n"</span>,</span><br><span class="line">		     __func__, proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end,</span><br><span class="line">		     (vma-&gt;vm_end - vma-&gt;vm_start) / SZ_1K, vma-&gt;vm_flags,</span><br><span class="line">		     (<span class="keyword">unsigned</span> <span class="keyword">long</span>)pgprot_val(vma-&gt;vm_page_prot));</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果设置了VM_WRITE标志，则失败返回</span></span><br><span class="line">	<span class="keyword">if</span> (vma-&gt;vm_flags &amp; FORBIDDEN_MMAP_FLAGS) &#123;</span><br><span class="line">		ret = -EPERM;</span><br><span class="line">		failure_string = <span class="string">"bad vm_flags"</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_bad_arg;</span><br><span class="line">	&#125;</span><br><span class="line">    <span class="comment">//VM_DONTCOPY表示fork子进程时不拷贝这段内存，清除VM_MAYWRITE标志</span></span><br><span class="line">	vma-&gt;vm_flags = (vma-&gt;vm_flags | VM_DONTCOPY) &amp; ~VM_MAYWRITE;</span><br><span class="line">	vma-&gt;vm_ops = &amp;binder_vm_ops;<span class="comment">//设置这段虚拟内存自己的操作符</span></span><br><span class="line">	vma-&gt;vm_private_data = proc;<span class="comment">//设置这段虚拟内存自己所属的binder_proc</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//关键函数</span></span><br><span class="line">	ret = binder_alloc_mmap_handler(&amp;proc-&gt;alloc, vma);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line"></span><br><span class="line">err_bad_arg:</span><br><span class="line">	pr_err(<span class="string">"binder_mmap: %d %lx-%lx %s failed %d\n"</span>,</span><br><span class="line">	       proc-&gt;pid, vma-&gt;vm_start, vma-&gt;vm_end, failure_string, ret);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>struct vm_area_struct表示用户空间的一段连续的虚拟内存区域</p>
<p>struct vm_struct表示内核空间的一段连续的虚拟内存区域</p>
<p>struct mm_struct是一个进程所有的vm_area_struct的集合</p>
<p>binder驱动实现了自己的内存分配器，比较复杂，没有深入阅读，大概就是所有的buffer都会放到双向链表binder_proc-&gt;buffers中; 其中被分配出去的buffer会同时插入红黑树binder_proc-&gt;allocated_buffer中; 空闲的buffer会插入红黑树binder_proc-&gt;free_buffer中；而pages管理所有的物理页面，binder_buffer的data域指向的一段虚拟内存地址会被映射到实际物理页面的某段内存。先放张图，后续读懂再继续完善<img src="/2019/03/26/Android-IPC-binder/binder-buffers.PNG" alt="binder-buffer"></p>
<h4 id="binder-ioctl"><a href="#binder-ioctl" class="headerlink" title="binder_ioctl"></a>binder_ioctl</h4><p>binder_ioctl实现了所有binder操作，binder实体之间的通信流程都在这个函数里面。进程通过open、mmap之后，就可以通过ioctl命令来控制binder驱动、发起传输请求了。先从简单的命令开始：</p>
<h5 id="BINDER-SET-MAX-THREADS"><a href="#BINDER-SET-MAX-THREADS" class="headerlink" title="BINDER_SET_MAX_THREADS"></a>BINDER_SET_MAX_THREADS</h5><p>这个命令很简单，就是设置当前进程的binder线程池中线程的最大数量。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">proc-&gt;max_threads = max_threads;</span><br></pre></td></tr></table></figure>

<h5 id="BINDER-THREAD-EXIT"><a href="#BINDER-THREAD-EXIT" class="headerlink" title="BINDER_THREAD_EXIT"></a>BINDER_THREAD_EXIT</h5><p>某个binder线程退出时会通知binder驱动回收其在内核相关的资源。</p>
<h5 id="BINDER-SET-CONTEXT-MGR"><a href="#BINDER-SET-CONTEXT-MGR" class="headerlink" title="BINDER_SET_CONTEXT_MGR"></a>BINDER_SET_CONTEXT_MGR</h5><p>这个命令只有作为服务管理者的进程才需要调用，系统中只有一个管理者，这个命令只能设置一次。主要就是告诉binder驱动自己要成为服务管理者，binder客户端进程可以通过handle 0访问自己。binder驱动为服务管理者创建一个binder_node对应用户空间的binder实体（对于服务管理者是比较特殊的，用户空间没有对应的binder实体；而通常注册的binder服务，比如前面说道的audioserver进程注册的AudioPolicyService服务在内核binder驱动中就对应一个binder_node，而binder_node的ptr指向了AudioPolicyService的地址），挂在该进程的binder_proc的nodes红黑树上。</p>
<p>驱动流程：binder_ioctl_set_ctx_mgr-&gt;binder_new_node-&gt;binder_init_node_ilocked(关键函数)</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> struct binder_node *<span class="title">binder_new_node</span><span class="params">(struct binder_proc *proc,</span></span></span><br><span class="line"><span class="function"><span class="params">					   struct flat_binder_object *fp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span></span><br><span class="line">    <span class="comment">//分配binder_node</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">new_node</span> = <span class="title">kzalloc</span>(<span class="title">sizeof</span>(*<span class="title">node</span>), <span class="title">GFP_KERNEL</span>);</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!new_node)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	node = binder_init_node_ilocked(proc, new_node, fp);</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">	<span class="keyword">if</span> (node != new_node)</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * The node was already added by another thread</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		kfree(new_node);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> node;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="BINDER-WRITE-READ"><a href="#BINDER-WRITE-READ" class="headerlink" title="BINDER_WRITE_READ"></a>BINDER_WRITE_READ</h5><h6 id="binder-thread-write部分"><a href="#binder-thread-write部分" class="headerlink" title="binder_thread_write部分"></a>binder_thread_write部分</h6><p>也就是处理BC_XXX命令；核心函数binder_thread_write；</p>
<p>BC_INCREFS:弱引用+1<br>BC_ACQUIRE:强引用+1<br>BC_RELEASE:强引用-1<br>BC_DECREFS:弱应用-1</p>
<p>关于binder_node引用的结构体：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_ref</span> &#123;</span></span><br><span class="line">	<span class="comment">/* Lookups needed: */</span></span><br><span class="line">	<span class="comment">/*   node + proc =&gt; ref (transaction) */</span></span><br><span class="line">	<span class="comment">/*   desc + proc =&gt; ref (transaction, inc/dec ref) */</span></span><br><span class="line">	<span class="comment">/*   node =&gt; refs + procs (proc exit) */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> <span class="title">data</span>;</span><span class="comment">//引用相关的信息记录</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_desc</span>;</span><span class="comment">//插入到引用者binder_proc的refs_by_desc树中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb_node_node</span>;</span><span class="comment">//插入到引用者binder_proc的refs_by_node树中</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span> <span class="title">node_entry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span><span class="comment">//被引用的binder_node所属的进程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_node</span> *<span class="title">node</span>;</span><span class="comment">//被引用的binder_node</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_death</span> *<span class="title">death</span>;</span> <span class="comment">//当这个引用对应的binder_node死亡之后会调用这个death发出死亡通知；关心目标服务实体死亡与否的客户端进程需要通过BC_REQUEST_DEATH_NOTIFICATION进行注册</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">binder_ref_data</span> &#123;</span></span><br><span class="line">	<span class="keyword">int</span> debug_id;</span><br><span class="line">	<span class="keyword">uint32_t</span> desc;<span class="comment">//被引用的binder_node在引用者进程中的索引，也就是handle</span></span><br><span class="line">	<span class="keyword">int</span> strong;<span class="comment">//强应用计数</span></span><br><span class="line">	<span class="keyword">int</span> weak;<span class="comment">//弱应用计数</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>BC_TRANSACTION:进程作为客户端向驱动发起一次binder传输请求；binder驱动将BC_TRANSACTION进行处理后转换成BR_TRANSACTION，投递给目标服务进程。同时会给发起请求的客户端进程投递BR_TRANSACTION_COMPLETE（不管是同步还是异步请求，驱动都会发送这个命令）</p>
<p>BR_TRANSACTION:目标服务进程接收到这个命令，对数据包进行解析，执行相关的流程后，发起BC_REPLY对这次请求进行回复。</p>
<p>BC_REPLY:进程作为服务端对客户端的某次BC_TRANSACTION请求进行回复。</p>
<p>BR_REPLY:驱动把BC_REPLY转换成BR_REPLY投递给目标客户端进程；到此客户端进程发起的binder请求得到了远程服务的反馈。</p>
<p>以上大概描述了同步binder请求时，client、binder驱动、service三者的交互。</p>
<p>audioserver进程A注册了两个binder_node实体，也就是有两个binder服务；一个AudioPolicyService和一个AudioFlinger。当某个服务实体binder_node被某个client进程引用时，client进程会有一个binder_ref指向这个binder_node并插入到进程A的refs_by_node、refs_by_desc树中；同时这个binder_ref也会被加入到；这个binder_node的refs列表中</p>
<p><img src="/2019/03/26/Android-IPC-binder/binder_node-service.PNG" alt="audioserver"></p>
<p>从audioserver进程通过addService往service_manager注册audio_policy服务的视角，看看内核的是如何做一次binder事务传输的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> BC_TRANSACTION:</span><br><span class="line"><span class="keyword">case</span> BC_REPLY: &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(&amp;tr, ptr, <span class="keyword">sizeof</span>(tr)))</span><br><span class="line">		<span class="keyword">return</span> -EFAULT;</span><br><span class="line">	ptr += <span class="keyword">sizeof</span>(tr);</span><br><span class="line">	binder_transaction(proc, thread, &amp;tr,</span><br><span class="line">			   cmd == BC_REPLY, <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">break</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_transaction函数是binder传输的核心，函数比较长，只看我们的关心的部分。</p>
<p>1、如何找到目标进程？</p>
<p>如果本次是BC_REPLY事务，一定是当前线程事务栈顶的binder事务发送者线程；但是BC_TRANSACTION事务就比较复杂：目标handle为0时，目标binder服务实体为service_manager、否则需要在本进程的refs_by_desc树中查找都目标binder服务实体，binder服务实体确认了，目标进程也就确定了；但是目标线程还涉及到binder线程的复用，线程的复用提高了效率，还避免了新建不必要的Binder线程；复用的原则是，当前线程遍历自己的事务栈，如果有事务请求来自目标进程，那么我们可以放心的使用这个事务的请求方线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//对于BC_REPLY，当前线程就是处理BC_TRANSATION的binder线程，那BC_REPLY的目标进程就很明确的，就是发起BC_TRANSATION</span></span><br><span class="line"><span class="keyword">if</span> (reply) &#123;</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	in_reply_to = thread-&gt;transaction_stack;<span class="comment">//先找到当前线程的binder事务栈，也就是上次某个远程线程发起的BC_TRANSATION构建的事务</span></span><br><span class="line">	<span class="keyword">if</span> (in_reply_to == <span class="literal">NULL</span>) &#123;<span class="comment">//如果当前线程的事务栈为空说明出错了</span></span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got reply transaction with no transaction stack\n"</span>,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EPROTO;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_empty_call_stack;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (in_reply_to-&gt;to_thread != thread) &#123;<span class="comment">//事务目标检查不对，也报错</span></span><br><span class="line">		spin_lock(&amp;in_reply_to-&gt;lock);</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got reply transaction with bad transaction stack, transaction %d has target %d:%d\n"</span>,</span><br><span class="line">			proc-&gt;pid, thread-&gt;pid, in_reply_to-&gt;debug_id,</span><br><span class="line">			in_reply_to-&gt;to_proc ?</span><br><span class="line">			in_reply_to-&gt;to_proc-&gt;pid : <span class="number">0</span>,</span><br><span class="line">			in_reply_to-&gt;to_thread ?</span><br><span class="line">			in_reply_to-&gt;to_thread-&gt;pid : <span class="number">0</span>);</span><br><span class="line">		spin_unlock(&amp;in_reply_to-&gt;lock);</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EPROTO;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		in_reply_to = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">	&#125;</span><br><span class="line">	thread-&gt;transaction_stack = in_reply_to-&gt;to_parent;</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">       <span class="comment">//binder事务的from记录着发起BC_TRANSATION的线程，也就是这次事务reply的目标线程</span></span><br><span class="line">	target_thread = binder_get_txn_from_and_acq_inner(in_reply_to);</span><br><span class="line">	<span class="keyword">if</span> (target_thread == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_DEAD_REPLY;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (target_thread-&gt;transaction_stack != in_reply_to) &#123;</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got reply transaction with bad target transaction stack %d, expected %d\n"</span>,</span><br><span class="line">			proc-&gt;pid, thread-&gt;pid,</span><br><span class="line">			target_thread-&gt;transaction_stack ?</span><br><span class="line">			target_thread-&gt;transaction_stack-&gt;debug_id : <span class="number">0</span>,</span><br><span class="line">			in_reply_to-&gt;debug_id);</span><br><span class="line">		binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EPROTO;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		in_reply_to = <span class="literal">NULL</span>;</span><br><span class="line">		target_thread = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">	&#125;</span><br><span class="line">       <span class="comment">//通过目标线程找到目标进程</span></span><br><span class="line">	target_proc = target_thread-&gt;proc;</span><br><span class="line">	target_proc-&gt;tmp_ref++;</span><br><span class="line">	binder_inner_proc_unlock(target_thread-&gt;proc);</span><br><span class="line">   <span class="comment">//对于BC_TRANSATION，当前线程就需要通过用户空间床底下来的handle在自己所在的进程中的refs_by_desc树中查找</span></span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	<span class="keyword">if</span> (tr-&gt;target.handle) &#123;<span class="comment">//handle不为0，说明目标进程不是service_manager的情况</span></span><br><span class="line">		struct binder_ref *ref;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * There must already be a strong ref</span></span><br><span class="line"><span class="comment">		 * on this node. If so, do a strong</span></span><br><span class="line"><span class="comment">		 * increment on the node to ensure it</span></span><br><span class="line"><span class="comment">		 * stays alive until the transaction is</span></span><br><span class="line"><span class="comment">		 * done.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		binder_proc_lock(proc);</span><br><span class="line">           <span class="comment">//通过handle查找目标binder实体的binder_ref引用</span></span><br><span class="line">		ref = binder_get_ref_olocked(proc, tr-&gt;target.handle,</span><br><span class="line">					     <span class="literal">true</span>);</span><br><span class="line">		<span class="keyword">if</span> (ref) &#123;<span class="comment">//通过binder_ref找到目标binder_node</span></span><br><span class="line">			target_node = binder_get_node_refs_for_txn(</span><br><span class="line">					ref-&gt;node, &amp;target_proc,</span><br><span class="line">					&amp;return_error);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			binder_user_error(<span class="string">"%d:%d got transaction to invalid handle\n"</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">		&#125;</span><br><span class="line">		binder_proc_unlock(proc);</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//handle为0，说明目标是service_manager，无需查找</span></span><br><span class="line">		mutex_lock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">		target_node = context-&gt;binder_context_mgr_node;</span><br><span class="line">		<span class="keyword">if</span> (target_node)</span><br><span class="line">			target_node = binder_get_node_refs_for_txn(</span><br><span class="line">					target_node, &amp;target_proc,</span><br><span class="line">					&amp;return_error);</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			return_error = BR_DEAD_REPLY;</span><br><span class="line">		mutex_unlock(&amp;context-&gt;context_mgr_node_lock);</span><br><span class="line">		<span class="keyword">if</span> (target_node &amp;&amp; target_proc == proc) &#123;</span><br><span class="line">			binder_user_error(<span class="string">"%d:%d got transaction to context manager from process owning it\n"</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (!target_node) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * return_error is set above</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		return_error_param = -EINVAL;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_dead_binder;</span><br><span class="line">	&#125;</span><br><span class="line">	e-&gt;to_node = target_node-&gt;debug_id;</span><br><span class="line">	<span class="keyword">if</span> (security_binder_transaction(proc-&gt;tsk,</span><br><span class="line">					target_proc-&gt;tsk) &lt; <span class="number">0</span>) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EPERM;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_invalid_target_handle;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">       <span class="comment">//如果不是异步请求，并且当前线程有事务栈中有binder事务在处理</span></span><br><span class="line">       <span class="comment">//说明是当前线程正在处理binder事务，又对其他binder服务发起了请求</span></span><br><span class="line">       <span class="comment">//这个时候我们需要在找到目标进程中，正在等待本进程的反馈的线程</span></span><br><span class="line">	<span class="keyword">if</span> (!(tr-&gt;flags &amp; TF_ONE_WAY) &amp;&amp; thread-&gt;transaction_stack) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">tmp</span>;</span></span><br><span class="line"></span><br><span class="line">		tmp = thread-&gt;transaction_stack;</span><br><span class="line">		<span class="keyword">if</span> (tmp-&gt;to_thread != thread) &#123;</span><br><span class="line">			spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">			binder_user_error(<span class="string">"%d:%d got new transaction with bad transaction stack, transaction %d has target %d:%d\n"</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid, tmp-&gt;debug_id,</span><br><span class="line">				tmp-&gt;to_proc ? tmp-&gt;to_proc-&gt;pid : <span class="number">0</span>,</span><br><span class="line">				tmp-&gt;to_thread ?</span><br><span class="line">				tmp-&gt;to_thread-&gt;pid : <span class="number">0</span>);</span><br><span class="line">			spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EPROTO;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_call_stack;</span><br><span class="line">		&#125;</span><br><span class="line">           <span class="comment">//从当前线程的事务栈中找到某个binder事务，如果这个事务的请求方正好在等待本进程的binder反馈</span></span><br><span class="line">           <span class="comment">//那么我们可以放心的将本次请求投递给这个请求方线程</span></span><br><span class="line">		<span class="keyword">while</span> (tmp) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">from</span>;</span></span><br><span class="line"></span><br><span class="line">			spin_lock(&amp;tmp-&gt;lock);</span><br><span class="line">			from = tmp-&gt;from;</span><br><span class="line">			<span class="keyword">if</span> (from &amp;&amp; from-&gt;proc == target_proc) &#123;</span><br><span class="line">				atomic_inc(&amp;from-&gt;tmp_ref);</span><br><span class="line">				target_thread = from;</span><br><span class="line">				spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			spin_unlock(&amp;tmp-&gt;lock);</span><br><span class="line">			tmp = tmp-&gt;from_parent;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_inner_proc_unlock(proc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>找到目标进程（或者目标线程）、目标实体后，数据是如何封装并投递的？</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">if</span> (target_thread)</span><br><span class="line">		e-&gt;to_thread = target_thread-&gt;pid;</span><br><span class="line">	e-&gt;to_proc = target_proc-&gt;pid;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* <span class="doctag">TODO:</span> reuse incoming transaction for reply */</span></span><br><span class="line">   <span class="comment">//分配binder_transaction事务，将用于投递到目标进程（线程）事务栈</span></span><br><span class="line">	t = kzalloc(<span class="keyword">sizeof</span>(*t), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (t == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -ENOMEM;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_t_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_stats_created(BINDER_STAT_TRANSACTION);</span><br><span class="line">	spin_lock_init(&amp;t-&gt;lock);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配binder_transaction事务，将用于投递到本进程（线程）事务栈，告诉自己这次BC_XX事务在binder驱动完成了投递</span></span><br><span class="line">	tcomplete = kzalloc(<span class="keyword">sizeof</span>(*tcomplete), GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (tcomplete == <span class="literal">NULL</span>) &#123;</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -ENOMEM;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_alloc_tcomplete_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	binder_stats_created(BINDER_STAT_TRANSACTION_COMPLETE);</span><br><span class="line"></span><br><span class="line">	t-&gt;debug_id = t_debug_id;</span><br><span class="line"></span><br><span class="line">......</span><br><span class="line">    <span class="comment">//如果不是BC_REPLY并且是同步请求，则binder事务的from为本线程；否则为null</span></span><br><span class="line">	<span class="keyword">if</span> (!reply &amp;&amp; !(tr-&gt;flags &amp; TF_ONE_WAY))</span><br><span class="line">		t-&gt;from = thread;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		t-&gt;from = <span class="literal">NULL</span>;</span><br><span class="line">	t-&gt;sender_euid = task_euid(proc-&gt;tsk);<span class="comment">//设置发送者的uid</span></span><br><span class="line">	t-&gt;to_proc = target_proc;<span class="comment">//设置目标进程</span></span><br><span class="line">	t-&gt;to_thread = target_thread;<span class="comment">//设置目标线程</span></span><br><span class="line">	t-&gt;code = tr-&gt;code;<span class="comment">//设置操作码</span></span><br><span class="line">	t-&gt;flags = tr-&gt;flags;<span class="comment">//设置flags</span></span><br><span class="line">	<span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY) &amp;&amp;</span><br><span class="line">	    binder_supported_policy(current-&gt;policy)) &#123;</span><br><span class="line">		<span class="comment">/* Inherit supported policies for synchronous transactions */</span></span><br><span class="line">		t-&gt;priority.sched_policy = current-&gt;policy;</span><br><span class="line">		t-&gt;priority.prio = current-&gt;normal_prio;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/* Otherwise, fall back to the default priority */</span></span><br><span class="line">		t-&gt;priority = target_proc-&gt;default_priority;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	trace_binder_transaction(reply, t, target_node);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//从目标进程的binder内存分配器分配一块内存binder_buffer</span></span><br><span class="line">	t-&gt;buffer = binder_alloc_new_buf(&amp;target_proc-&gt;alloc, tr-&gt;data_size,</span><br><span class="line">		tr-&gt;offsets_size, extra_buffers_size,</span><br><span class="line">		!reply &amp;&amp; (t-&gt;flags &amp; TF_ONE_WAY));</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(t-&gt;buffer)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * -ESRCH indicates VMA cleared. The target is dying.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		return_error_param = PTR_ERR(t-&gt;buffer);</span><br><span class="line">		return_error = return_error_param == -ESRCH ?</span><br><span class="line">			BR_DEAD_REPLY : BR_FAILED_REPLY;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		t-&gt;buffer = <span class="literal">NULL</span>;</span><br><span class="line">		<span class="keyword">goto</span> err_binder_alloc_buf_failed;</span><br><span class="line">	&#125;</span><br><span class="line">	t-&gt;buffer-&gt;allow_user_free = <span class="number">0</span>;</span><br><span class="line">	t-&gt;buffer-&gt;debug_id = t-&gt;debug_id;</span><br><span class="line">	t-&gt;buffer-&gt;transaction = t;</span><br><span class="line">	t-&gt;buffer-&gt;target_node = target_node;</span><br><span class="line">	trace_binder_transaction_alloc_buf(t-&gt;buffer);</span><br><span class="line">	off_start = (<span class="keyword">binder_size_t</span> *)(t-&gt;buffer-&gt;data +</span><br><span class="line">				      ALIGN(tr-&gt;data_size, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">	offp = off_start;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//直接拷贝传输内容到目标进程的binder_buffer中，1次拷贝就到了目标进程空间里面</span></span><br><span class="line">	<span class="keyword">if</span> (copy_from_user(t-&gt;buffer-&gt;data, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">			   tr-&gt;data.ptr.buffer, tr-&gt;data_size)) &#123;</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got transaction with invalid data ptr\n"</span>,</span><br><span class="line">				proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EFAULT;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    ......</span><br><span class="line">    <span class="comment">//这里先跳过binder驱动处理binder扁平数据的部分；直接看看前面准备好的两个binder_transaction事务的分发投递</span></span><br><span class="line">	tcomplete-&gt;type = BINDER_WORK_TRANSACTION_COMPLETE;</span><br><span class="line">	t-&gt;work.type = BINDER_WORK_TRANSACTION;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (reply) &#123;<span class="comment">//BC_REPLY</span></span><br><span class="line">        <span class="comment">//往当前线程的todo队列压入tcomplete，告诉自己这个binder请求被驱动处理完毕</span></span><br><span class="line">		binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">		binder_inner_proc_lock(target_proc);</span><br><span class="line">		<span class="keyword">if</span> (target_thread-&gt;is_dead) &#123;</span><br><span class="line">			binder_inner_proc_unlock(target_proc);</span><br><span class="line">			<span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">		&#125;</span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">        <span class="comment">//BC_REPLY一定是回复事务栈顶的那个事务的，栈顶事务出栈</span></span><br><span class="line">		binder_pop_transaction_ilocked(target_thread, in_reply_to);</span><br><span class="line">        <span class="comment">//往目标线程的TODO队列压入一个binder事务工作任务</span></span><br><span class="line">		binder_enqueue_thread_work_ilocked(target_thread, &amp;t-&gt;work);</span><br><span class="line">		binder_inner_proc_unlock(target_proc);</span><br><span class="line">		wake_up_interruptible_sync(&amp;target_thread-&gt;wait);</span><br><span class="line">		binder_restore_priority(current, in_reply_to-&gt;saved_priority);</span><br><span class="line">		binder_free_transaction(in_reply_to);</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!(t-&gt;flags &amp; TF_ONE_WAY)) &#123;<span class="comment">//对于BC_XXX，并且同步请求</span></span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">0</span>);</span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Defer the TRANSACTION_COMPLETE, so we don't return to</span></span><br><span class="line"><span class="comment">		 * userspace immediately; this allows the target process to</span></span><br><span class="line"><span class="comment">		 * immediately start processing this transaction, reducing</span></span><br><span class="line"><span class="comment">		 * latency. We will then return the TRANSACTION_COMPLETE when</span></span><br><span class="line"><span class="comment">		 * the target replies (or there is an error).</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">//往当前线程的todo队列压入tcomplete，告诉自己这个binder请求被驱动处理完毕</span></span><br><span class="line">		binder_enqueue_deferred_thread_work_ilocked(thread, tcomplete);</span><br><span class="line">        <span class="comment">//这次binde事务压入当前线程的事务栈顶</span></span><br><span class="line">		t-&gt;need_reply = <span class="number">1</span>;</span><br><span class="line">		t-&gt;from_parent = thread-&gt;transaction_stack;</span><br><span class="line">		thread-&gt;transaction_stack = t;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">        <span class="comment">//这次binde事务投递目标进程或者目标线程的todo队列</span></span><br><span class="line">		<span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, target_thread)) &#123;</span><br><span class="line">			binder_inner_proc_lock(proc);</span><br><span class="line">			binder_pop_transaction_ilocked(thread, t);</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			<span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//BC_XXX，且是异步请求，往当前线程的todo队列压入tcomplete，告诉自己这个binder请求被驱动处理完毕</span></span><br><span class="line">		BUG_ON(target_node == <span class="literal">NULL</span>);</span><br><span class="line">		BUG_ON(t-&gt;buffer-&gt;async_transaction != <span class="number">1</span>);</span><br><span class="line">		binder_enqueue_thread_work(thread, tcomplete);</span><br><span class="line">		<span class="keyword">if</span> (!binder_proc_transaction(t, target_proc, <span class="literal">NULL</span>))</span><br><span class="line">			<span class="keyword">goto</span> err_dead_proc_or_thread;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (target_thread)</span><br><span class="line">		binder_thread_dec_tmpref(target_thread);</span><br><span class="line">	binder_proc_dec_tmpref(target_proc);</span><br><span class="line">	<span class="keyword">if</span> (target_node)</span><br><span class="line">		binder_dec_node_tmpref(target_node);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * write barrier to synchronize with initialization</span></span><br><span class="line"><span class="comment">	 * of log entry</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_wmb();</span><br><span class="line">	WRITE_ONCE(e-&gt;debug_id_done, t_debug_id);</span><br><span class="line">	<span class="keyword">return</span>;</span><br></pre></td></tr></table></figure>

<p>这个过程中，还有一部分内容我们忽略了，就是扁平数据的处理；扁平数据需要完全在binder驱动转化、修改后再能给到目标进程；比如文件句柄、handle等，这类数据在本进程的值不做修改传递给远程进程时没有意义的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br></pre></td><td class="code"><pre><span class="line">   <span class="comment">//先拷贝到目标进程空间</span></span><br><span class="line">   <span class="keyword">if</span> (copy_from_user(offp, (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">		   tr-&gt;data.ptr.offsets, tr-&gt;offsets_size)) &#123;</span><br><span class="line">	binder_user_error(<span class="string">"%d:%d got transaction with invalid offsets ptr\n"</span>,</span><br><span class="line">			proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">	return_error = BR_FAILED_REPLY;</span><br><span class="line">	return_error_param = -EFAULT;</span><br><span class="line">	return_error_line = __LINE__;</span><br><span class="line">	<span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">&#125;</span><br><span class="line">.....</span><br><span class="line">off_end = (<span class="keyword">void</span> *)off_start + tr-&gt;offsets_size;</span><br><span class="line">sg_bufp = (u8 *)(PTR_ALIGN(off_end, <span class="keyword">sizeof</span>(<span class="keyword">void</span> *)));</span><br><span class="line">sg_buf_end = sg_bufp + extra_buffers_size;</span><br><span class="line">off_min = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">for</span> (; offp &lt; off_end; offp++) &#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_object_header</span> *<span class="title">hdr</span>;</span></span><br><span class="line">	<span class="keyword">size_t</span> object_size = binder_validate_object(t-&gt;buffer, *offp);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (object_size == <span class="number">0</span> || *offp &lt; off_min) &#123;</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got transaction with invalid offset (%lld, min %lld max %lld) or object.\n"</span>,</span><br><span class="line">				  proc-&gt;pid, thread-&gt;pid, (u64)*offp,</span><br><span class="line">				  (u64)off_min,</span><br><span class="line">				  (u64)t-&gt;buffer-&gt;data_size);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EINVAL;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	hdr = (struct binder_object_header *)(t-&gt;buffer-&gt;data + *offp);</span><br><span class="line">	off_min = *offp + object_size;</span><br><span class="line">	<span class="keyword">switch</span> (hdr-&gt;type) &#123;</span><br><span class="line">       <span class="comment">//addService传递的就是BINDER_TYPE_BINDER</span></span><br><span class="line">	<span class="keyword">case</span> BINDER_TYPE_BINDER:</span><br><span class="line">	<span class="keyword">case</span> BINDER_TYPE_WEAK_BINDER: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line">           <span class="comment">//指向扁平数据</span></span><br><span class="line">		fp = to_flat_binder_object(hdr);</span><br><span class="line">           <span class="comment">//addservice会在本进程创建一个与用户空间服务实体对应的binder_node，插入到本进程的nodes树中</span></span><br><span class="line">           <span class="comment">//同时也会目标进程，也就是service_manager中的引用树中查找是否有这个binder_node引用；addSErvice当然是没有、所以会创建一个对这个binder_node的引用、分配器在service_manager中的handle，并插入到refs_by_node和refs_by_desc树中</span></span><br><span class="line">           <span class="comment">//然后修改扁平数据的BINDER_TYPE_BINDER为BINDER_TYPE_HANDLE，handle为新分配的desc等</span></span><br><span class="line">           <span class="comment">//最后sevice_manager收到add_service的请求就根据这些数据做add service的逻辑</span></span><br><span class="line">		ret = binder_translate_binder(fp, t, thread);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = ret;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">       <span class="comment">//客户端getService的时候，service_manager先获取到对应目标service在自己进程中的handle</span></span><br><span class="line">       <span class="comment">//传递会给客户端的就是BINDER_TYPE_HANDLE，但是handle是service managr进程的；对于client进程没有意义</span></span><br><span class="line">       <span class="comment">//所以这里同样需要对目标服务实体在service_manager进程中的handle进行转换</span></span><br><span class="line">       <span class="comment">//这里就是在client进程的用户空间创建一个目标binder_node的binder_ref，并分配handle，插入到client进程的refs_by_node和refs_by_desc树中</span></span><br><span class="line">       <span class="comment">//这里需要区分client获取的binder服务实体是自己注册的还是别的进程注册的。如果是获取自己进程的服务实体BINDER_TYPE_HANDLE要转换成BINDER_TYPE_BINDER，否则不用转换只是更改handle</span></span><br><span class="line">	<span class="keyword">case</span> BINDER_TYPE_HANDLE:</span><br><span class="line">	<span class="keyword">case</span> BINDER_TYPE_WEAK_HANDLE: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">flat_binder_object</span> *<span class="title">fp</span>;</span></span><br><span class="line"></span><br><span class="line">		fp = to_flat_binder_object(hdr);</span><br><span class="line">		ret = binder_translate_handle(fp, t, thread);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = ret;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">       <span class="comment">//传递文件句柄</span></span><br><span class="line">       <span class="comment">//binder支持本进程打开一个文件，并将其fd传递给某个远程进程；不过本进程的fd在远程进程上也是没有意义的</span></span><br><span class="line">       <span class="comment">//所以需要转换，其实就是通过fd找对对应的file，然后再目标进程为这个file分配一个fd</span></span><br><span class="line">	<span class="keyword">case</span> BINDER_TYPE_FD: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_fd_object</span> *<span class="title">fp</span> = <span class="title">to_binder_fd_object</span>(<span class="title">hdr</span>);</span></span><br><span class="line">		<span class="keyword">int</span> target_fd = binder_translate_fd(fp-&gt;fd, t, thread,</span><br><span class="line">						    in_reply_to);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (target_fd &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = target_fd;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		fp-&gt;pad_binder = <span class="number">0</span>;</span><br><span class="line">		fp-&gt;fd = target_fd;</span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">       <span class="comment">//这个和BINDER_TYPE_FD差不多，就是fd数组传递</span></span><br><span class="line">	<span class="keyword">case</span> BINDER_TYPE_FDA: &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_fd_array_object</span> *<span class="title">fda</span> =</span></span><br><span class="line"><span class="class">			<span class="title">to_binder_fd_array_object</span>(<span class="title">hdr</span>);</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer_object</span> *<span class="title">parent</span> =</span></span><br><span class="line"><span class="class">			<span class="title">binder_validate_ptr</span>(<span class="title">t</span>-&gt;<span class="title">buffer</span>, <span class="title">fda</span>-&gt;<span class="title">parent</span>,</span></span><br><span class="line"><span class="class">					    <span class="title">off_start</span>,</span></span><br><span class="line"><span class="class">					    <span class="title">offp</span> - <span class="title">off_start</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (!parent) &#123;</span><br><span class="line">			binder_user_error(<span class="string">"%d:%d got transaction with invalid parent offset or type\n"</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_parent;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (!binder_validate_fixup(t-&gt;buffer, off_start,</span><br><span class="line">					   parent, fda-&gt;parent_offset,</span><br><span class="line">					   last_fixup_obj,</span><br><span class="line">					   last_fixup_min_off)) &#123;</span><br><span class="line">			binder_user_error(<span class="string">"%d:%d got transaction with out-of-order buffer fixup\n"</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_parent;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = binder_translate_fd_array(fda, parent, t, thread,</span><br><span class="line">						in_reply_to);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = ret;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		last_fixup_obj = parent;</span><br><span class="line">		last_fixup_min_off =</span><br><span class="line">			fda-&gt;parent_offset + <span class="keyword">sizeof</span>(u32) * fda-&gt;num_fds;</span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">case</span> BINDER_TYPE_PTR: &#123;<span class="comment">//hwbinder才会用到，传递大数据块</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_buffer_object</span> *<span class="title">bp</span> =</span></span><br><span class="line"><span class="class">			<span class="title">to_binder_buffer_object</span>(<span class="title">hdr</span>);</span></span><br><span class="line">		<span class="keyword">size_t</span> buf_left = sg_buf_end - sg_bufp;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (bp-&gt;length &gt; buf_left) &#123;</span><br><span class="line">			binder_user_error(<span class="string">"%d:%d got transaction with too large buffer\n"</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = -EINVAL;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_bad_offset;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (copy_from_user(sg_bufp,</span><br><span class="line">				   (<span class="keyword">const</span> <span class="keyword">void</span> __user *)(<span class="keyword">uintptr_t</span>)</span><br><span class="line">				   bp-&gt;buffer, bp-&gt;length)) &#123;</span><br><span class="line">			binder_user_error(<span class="string">"%d:%d got transaction with invalid offsets ptr\n"</span>,</span><br><span class="line">					  proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">			return_error_param = -EFAULT;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_copy_data_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* Fixup buffer pointer to target proc address space */</span></span><br><span class="line">           <span class="comment">// 缓冲区指针指向目标proc地址空间</span></span><br><span class="line">		bp-&gt;buffer = (<span class="keyword">uintptr_t</span>)sg_bufp +</span><br><span class="line">			binder_alloc_get_user_buffer_offset(</span><br><span class="line">					&amp;target_proc-&gt;alloc);</span><br><span class="line">		sg_bufp += ALIGN(bp-&gt;length, <span class="keyword">sizeof</span>(u64));</span><br><span class="line"></span><br><span class="line">		ret = binder_fixup_parent(t, thread, bp, off_start,</span><br><span class="line">					  offp - off_start,</span><br><span class="line">					  last_fixup_obj,</span><br><span class="line">					  last_fixup_min_off);</span><br><span class="line">		<span class="keyword">if</span> (ret &lt; <span class="number">0</span>) &#123;</span><br><span class="line">			return_error = BR_FAILED_REPLY;</span><br><span class="line">			return_error_param = ret;</span><br><span class="line">			return_error_line = __LINE__;</span><br><span class="line">			<span class="keyword">goto</span> err_translate_failed;</span><br><span class="line">		&#125;</span><br><span class="line">		last_fixup_obj = bp;</span><br><span class="line">		last_fixup_min_off = <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">break</span>;</span><br><span class="line">	<span class="keyword">default</span>:</span><br><span class="line">		binder_user_error(<span class="string">"%d:%d got transaction with invalid object type, %x\n"</span>,</span><br><span class="line">			proc-&gt;pid, thread-&gt;pid, hdr-&gt;type);</span><br><span class="line">		return_error = BR_FAILED_REPLY;</span><br><span class="line">		return_error_param = -EINVAL;</span><br><span class="line">		return_error_line = __LINE__;</span><br><span class="line">		<span class="keyword">goto</span> err_bad_object_type;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h6 id="binder-thread-read部分"><a href="#binder-thread-read部分" class="headerlink" title="binder_thread_read部分"></a>binder_thread_read部分</h6><p>如果当前的binder线程的binder事务栈为空、todo任务列表为空，且线程已经处于BINDER_LOOPER_STATE_ENTERED或者BINDER_LOOPER_STATE_REGISTERED状态，那么当前binder线程空闲等待所在进程的任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wait_for_proc_work = binder_available_for_proc_work_ilocked(thread);</span><br></pre></td></tr></table></figure>

<p>如果进程打开binder设备文件的时候制定了非阻塞的方式，那么线程和其所在的进程没有任何事务需要处理的话直接返回错误；否则将线程状态设置成TASK_INTERRUPTIBLE、挂到自己的wait队列中、加入所在进程的waiting_threads中，自己休眠起来调度出去。所以可以看出binder_proc的waiting_threads列表上的线程都是空闲的binder线程；binder线程挂起等待是在自己的等待队列中。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (non_block) &#123;</span><br><span class="line">	<span class="keyword">if</span> (!binder_has_work(thread, wait_for_proc_work))</span><br><span class="line">		ret = -EAGAIN;</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">	ret = binder_wait_for_work(thread, wait_for_proc_work);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder线程优先处理自己todo队列上的任务；如果自己的todo任务为空，则处理所在进程的todo队列上的任务。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">	<span class="keyword">while</span> (<span class="number">1</span>) &#123;</span><br><span class="line">		<span class="keyword">uint32_t</span> cmd;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction_data</span> <span class="title">tr</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_work</span> *<span class="title">w</span> = <span class="title">NULL</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">list</span> = <span class="title">NULL</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_transaction</span> *<span class="title">t</span> = <span class="title">NULL</span>;</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">binder_thread</span> *<span class="title">t_from</span>;</span></span><br><span class="line"></span><br><span class="line">		binder_inner_proc_lock(proc);</span><br><span class="line">		<span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">			<span class="built_in">list</span> = &amp;thread-&gt;todo;</span><br><span class="line">		<span class="keyword">else</span> <span class="keyword">if</span> (!binder_worklist_empty_ilocked(&amp;proc-&gt;todo) &amp;&amp;</span><br><span class="line">			   wait_for_proc_work)</span><br><span class="line">			<span class="built_in">list</span> = &amp;proc-&gt;todo;</span><br><span class="line">		<span class="keyword">else</span> &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* no data added */</span></span><br><span class="line">			<span class="keyword">if</span> (ptr - buffer == <span class="number">4</span> &amp;&amp; !thread-&gt;looper_need_return)</span><br><span class="line">				<span class="keyword">goto</span> retry;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (end - ptr &lt; <span class="keyword">sizeof</span>(tr) + <span class="number">4</span>) &#123;</span><br><span class="line">			binder_inner_proc_unlock(proc);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		w = binder_dequeue_work_head_ilocked(<span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">if</span> (binder_worklist_empty_ilocked(&amp;thread-&gt;todo))</span><br><span class="line">			thread-&gt;process_todo = <span class="literal">false</span>;</span><br><span class="line">......</span><br><span class="line">    <span class="comment">//这里内容太多，忽略各类型的事务处理</span></span><br></pre></td></tr></table></figure>

<p>read处理的binder任务类型很多，就不一一列举了。处理完binder任务后，判断是否需要启动新的binder线程：如果当前没有正在请求但是还没启动的binder线程、线程数没有超标、并且线程池中已经没有空闲的线程时，会给用户空间发起BR_SPAWN_LOOPER命令启动新的binder线程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">done:</span><br><span class="line"></span><br><span class="line">	*consumed = ptr - buffer;</span><br><span class="line">	binder_inner_proc_lock(proc);</span><br><span class="line">	<span class="keyword">if</span> (proc-&gt;requested_threads == <span class="number">0</span> &amp;&amp;</span><br><span class="line">	    list_empty(&amp;thread-&gt;proc-&gt;waiting_threads) &amp;&amp;</span><br><span class="line">	    proc-&gt;requested_threads_started &lt; proc-&gt;max_threads &amp;&amp;</span><br><span class="line">	    (thread-&gt;looper &amp; (BINDER_LOOPER_STATE_REGISTERED |</span><br><span class="line">	     BINDER_LOOPER_STATE_ENTERED)) <span class="comment">/* the user-space code fails to */</span></span><br><span class="line">	     <span class="comment">/*spawn a new thread if we leave this out */</span>) &#123;</span><br><span class="line">		proc-&gt;requested_threads++;</span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">		binder_debug(BINDER_DEBUG_THREADS,</span><br><span class="line">			     <span class="string">"%d:%d BR_SPAWN_LOOPER\n"</span>,</span><br><span class="line">			     proc-&gt;pid, thread-&gt;pid);</span><br><span class="line">		<span class="keyword">if</span> (put_user(BR_SPAWN_LOOPER, (<span class="keyword">uint32_t</span> __user *)buffer))</span><br><span class="line">			<span class="keyword">return</span> -EFAULT;</span><br><span class="line">		binder_stat_br(proc, thread, BR_SPAWN_LOOPER);</span><br><span class="line">	&#125; <span class="keyword">else</span></span><br><span class="line">		binder_inner_proc_unlock(proc);</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="binder-release"><a href="#binder-release" class="headerlink" title="binder_release"></a>binder_release</h4><p>当进程不管任何原因退出的时候，linux会回收进程的所有资源，其中就包括打开的文件资源，binder设备节点被打开后也是一个文件。binder文件资源被回收时回调的就是binder_release。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">binder_release</span><span class="params">(struct inode *nodp, struct file *filp)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line"></span><br><span class="line">	debugfs_remove(proc-&gt;debugfs_entry);<span class="comment">//移除进程的binder在debugfs中的调试节点</span></span><br><span class="line">    <span class="comment">//设置自己的binder_proc的deferred_work，加上BINDER_DEFERRED_RELEASE类型的work</span></span><br><span class="line">    <span class="comment">//将自己binder_proc加入全局延迟工作任务列表binder_deferred_list中，启动binder_deferred_work</span></span><br><span class="line">	binder_defer_work(proc, BINDER_DEFERRED_RELEASE);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>看看工作任务的处理函数做了什么：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">binder_deferred_func</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">binder_proc</span> *<span class="title">proc</span>;</span></span><br><span class="line">	<span class="keyword">int</span> defer;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历binder_deferred_list上的所有binder_proc</span></span><br><span class="line">    <span class="comment">//根据deferred_work的类型做相应的处理</span></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		mutex_lock(&amp;binder_deferred_lock);</span><br><span class="line">		<span class="keyword">if</span> (!hlist_empty(&amp;binder_deferred_list)) &#123;</span><br><span class="line">			proc = hlist_entry(binder_deferred_list.first,</span><br><span class="line">					struct binder_proc, deferred_work_node);</span><br><span class="line">			hlist_del_init(&amp;proc-&gt;deferred_work_node);</span><br><span class="line">			defer = proc-&gt;deferred_work;</span><br><span class="line">			proc-&gt;deferred_work = <span class="number">0</span>;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			proc = <span class="literal">NULL</span>;</span><br><span class="line">			defer = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		mutex_unlock(&amp;binder_deferred_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (defer &amp; BINDER_DEFERRED_FLUSH)</span><br><span class="line">			binder_deferred_flush(proc);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//我们binder_release发起的延迟工作类型是BINDER_DEFERRED_RELEASE</span></span><br><span class="line">		<span class="keyword">if</span> (defer &amp; BINDER_DEFERRED_RELEASE)</span><br><span class="line">			binder_deferred_release(proc); <span class="comment">/* frees proc */</span></span><br><span class="line">	&#125; <span class="keyword">while</span> (proc);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>binder_deferred_release函数包含了所有进程相关的binder资源的回收工作，比如线程资源、binder实体资源、死亡通知等等。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/03/26/Android-IPC-binder/" data-id="cjy7ayuah002feoii5t85mzcr" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Android/">Android</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/04/02/Android-activity-impletment/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Android四大组件之Activity
        
      </div>
    </a>
  
  
    <a href="/2019/03/20/Linux-process-management/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Linux内核进程管理基础</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AIDL/">AIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HIDL/">HIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/driver/">driver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">18</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实战/">实战</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稳定性/">稳定性</a><span class="tag-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AIDL/" style="font-size: 10px;">AIDL</a> <a href="/tags/Android/" style="font-size: 16.67px;">Android</a> <a href="/tags/HIDL/" style="font-size: 10px;">HIDL</a> <a href="/tags/Linux/" style="font-size: 16.67px;">Linux</a> <a href="/tags/driver/" style="font-size: 10px;">driver</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/实战/" style="font-size: 13.33px;">实战</a> <a href="/tags/稳定性/" style="font-size: 13.33px;">稳定性</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">1</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/01/Arm-linux-exception-flows/">Linux-ARMv8异常相关知识</a>
          </li>
        
          <li>
            <a href="/2019/07/20/Android-gdb-extract-logs/">Android9.0 logd进程空间提取日志信息</a>
          </li>
        
          <li>
            <a href="/2019/07/15/Android-booting-time-spent/">Android开机时间分析</a>
          </li>
        
          <li>
            <a href="/2019/07/10/a-intentresolver-cts-issue/">关于IntentResolver的一个cts问题</a>
          </li>
        
          <li>
            <a href="/2019/07/05/native-acess-javaservice-with-binder/">Android平台上native代码访问PackageManagerService</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 JoyYoung<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>