<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>Linux进程间通信机制 | JoyYoung&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="学习linux进程间通信的基础知识">
<meta name="keywords" content="学习,Linux">
<meta property="og:type" content="article">
<meta property="og:title" content="Linux进程间通信机制">
<meta property="og:url" content="http://yoursite.com/2019/06/15/Linux-system-ipc/index.html">
<meta property="og:site_name" content="JoyYoung&#39;s blog">
<meta property="og:description" content="学习linux进程间通信的基础知识">
<meta property="og:locale" content="default">
<meta property="og:image" content="http://yoursite.com/2019/06/15/Linux-system-ipc/write-buffer.PNG">
<meta property="og:image" content="http://yoursite.com/2019/06/15/Linux-system-ipc/signal-struct.PNG">
<meta property="og:updated_time" content="2019-08-19T14:26:14.900Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Linux进程间通信机制">
<meta name="twitter:description" content="学习linux进程间通信的基础知识">
<meta name="twitter:image" content="http://yoursite.com/2019/06/15/Linux-system-ipc/write-buffer.PNG">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoyYoung&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-Linux-system-ipc" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/06/15/Linux-system-ipc/" class="article-date">
  <time datetime="2019-06-15T15:00:00.000Z" itemprop="datePublished">2019-06-15</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      Linux进程间通信机制
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>ipc是Inter-Process Communication的简称，即进程间通信；是多个进程之间相互交换数据的一种方法。在linux系统中有多种进程间通信的方法，如管道、命名管道、消息队列、信号、信号量、共享内存、内存映射文件、套接字等等。这篇文章将基于android系统学习整理各个通信机制的基本原理和使用方法。</p>
<h4 id="管道（pipe）"><a href="#管道（pipe）" class="headerlink" title="管道（pipe）"></a>管道（pipe）</h4><p>管道即匿名管道，主要用于具有亲缘关系的进程间通信。创建管道的进程称为管道服务端，连接到一个管道的进程为管道客户端。一个进程在向管道写入数据后，另一进程就可以从管道的另一端将其读取出来。创建匿名管道的方法在bionic/libc/bionic/pipe.cpp定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * pipefd[0]为read，pipefd[1]为write</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">pipe</span><span class="params">(<span class="keyword">int</span> pipefd[<span class="number">2</span>])</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> pipe2(pipefd, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以arm64为例，系统调用pipe2在bionic/libc/arch-arm64/syscalls/pipe2.S中实现，接收两个参数pipefd用于存放创建好的管道文件的句柄，0是默认flags参数。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">/* Generated by gensyscalls.py. Do not edit. */</span><br><span class="line"></span><br><span class="line">#include &lt;private/bionic_asm.h&gt;</span><br><span class="line"></span><br><span class="line">ENTRY(pipe2)</span><br><span class="line">    /*将系统调用号存放在x8寄存器中*/</span><br><span class="line">    mov     x8, __NR_pipe2</span><br><span class="line">    /*执行svc指令，陷入异常，并且从el0切换到el1*/</span><br><span class="line">    svc     #0</span><br><span class="line"></span><br><span class="line">    /*系统调用已经返回*/</span><br><span class="line">    cmn     x0, #(MAX_ERRNO + 1)</span><br><span class="line">    cneg    x0, x0, hi</span><br><span class="line">    b.hi    __set_errno_internal</span><br><span class="line"></span><br><span class="line">    ret</span><br><span class="line">END(pipe2)</span><br></pre></td></tr></table></figure>

<p>找出这个系统调用最终调用到内核的哪个函数，先看看arm64的内核异常向量表：</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line">/*kernel/arch/arm64/kernel/entry.S*/</span><br><span class="line">/*</span><br><span class="line"> * Exception vectors.</span><br><span class="line"> */</span><br><span class="line">	.pushsection &quot;.entry.text&quot;, &quot;ax&quot;</span><br><span class="line"></span><br><span class="line">	.align	11</span><br><span class="line">ENTRY(vectors)</span><br><span class="line">	kernel_ventry	1, sync_invalid			// Synchronous EL1t</span><br><span class="line">	kernel_ventry	1, irq_invalid			// IRQ EL1t</span><br><span class="line">	kernel_ventry	1, fiq_invalid			// FIQ EL1t</span><br><span class="line">	kernel_ventry	1, error_invalid		// Error EL1t</span><br><span class="line"></span><br><span class="line">	kernel_ventry	1, sync				// Synchronous EL1h</span><br><span class="line">	kernel_ventry	1, irq				// IRQ EL1h</span><br><span class="line">	kernel_ventry	1, fiq_invalid			// FIQ EL1h</span><br><span class="line">	kernel_ventry	1, error_invalid		// Error EL1h</span><br><span class="line"></span><br><span class="line">    /*这里设计arm架构很底层的只是，网上资料说arm64的同步异常会跳到sync*/</span><br><span class="line">	kernel_ventry	0, sync				// Synchronous 64-bit EL0</span><br><span class="line">	kernel_ventry	0, irq				// IRQ 64-bit EL0</span><br><span class="line">	kernel_ventry	0, fiq_invalid			// FIQ 64-bit EL0</span><br><span class="line">	kernel_ventry	0, error_invalid		// Error 64-bit EL0</span><br><span class="line"></span><br><span class="line">#ifdef CONFIG_COMPAT</span><br><span class="line">	kernel_ventry	0, sync_compat, 32		// Synchronous 32-bit EL0</span><br><span class="line">	kernel_ventry	0, irq_compat, 32		// IRQ 32-bit EL0</span><br><span class="line">	kernel_ventry	0, fiq_invalid_compat, 32	// FIQ 32-bit EL0</span><br><span class="line">	kernel_ventry	0, error_invalid_compat, 32	// Error 32-bit EL0</span><br><span class="line">#else</span><br><span class="line">	kernel_ventry	0, sync_invalid, 32		// Synchronous 32-bit EL0</span><br><span class="line">	kernel_ventry	0, irq_invalid, 32		// IRQ 32-bit EL0</span><br><span class="line">	kernel_ventry	0, fiq_invalid, 32		// FIQ 32-bit EL0</span><br><span class="line">	kernel_ventry	0, error_invalid, 32		// Error 32-bit EL0</span><br><span class="line">#endif</span><br><span class="line">END(vectors)</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * EL0 mode handlers.同步异常的处理函数</span><br><span class="line"> */</span><br><span class="line">	.align	6</span><br><span class="line">el0_sync:</span><br><span class="line">	kernel_entry 0</span><br><span class="line">	mrs	x25, esr_el1			// read the syndrome register</span><br><span class="line">	lsr	x24, x25, #ESR_ELx_EC_SHIFT	// exception class</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SVC64		// SVC in 64-bit state，调用svc处理函数</span><br><span class="line">	b.eq	el0_svc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_DABT_LOW	// data abort in EL0</span><br><span class="line">	b.eq	el0_da</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_IABT_LOW	// instruction abort in EL0</span><br><span class="line">	b.eq	el0_ia</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_FP_ASIMD	// FP/ASIMD access</span><br><span class="line">	b.eq	el0_fpsimd_acc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_FP_EXC64	// FP/ASIMD exception</span><br><span class="line">	b.eq	el0_fpsimd_exc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SYS64		// configurable trap</span><br><span class="line">	b.eq	el0_sys</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_SP_ALIGN	// stack alignment exception</span><br><span class="line">	b.eq	el0_sp_pc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_PC_ALIGN	// pc alignment exception</span><br><span class="line">	b.eq	el0_sp_pc</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_UNKNOWN	// unknown exception in EL0</span><br><span class="line">	b.eq	el0_undef</span><br><span class="line">	cmp	x24, #ESR_ELx_EC_BREAKPT_LOW	// debug exception in EL0</span><br><span class="line">	b.ge	el0_dbg</span><br><span class="line">	b	el0_inv</span><br><span class="line"></span><br><span class="line">/*</span><br><span class="line"> * SVC handler.</span><br><span class="line"> */</span><br><span class="line">	.align	6</span><br><span class="line">el0_svc:</span><br><span class="line">	adrp	stbl, sys_call_table		// 系统调用表</span><br><span class="line">	uxtw	scno, w8			// pipe2是将系统调用编号保存在x8，这里读取w8</span><br><span class="line">	mov	sc_nr, #__NR_syscalls   //linux内核系统调用表大小是400</span><br><span class="line">el0_svc_naked:					// compat entry point</span><br><span class="line">	stp	x0, scno, [sp, #S_ORIG_X0]	// 保存x0中的第一个参数和系统调用编号</span><br><span class="line">	enable_dbg_and_irq</span><br><span class="line">	ct_user_exit 1</span><br><span class="line"></span><br><span class="line">	ldr	x16, [tsk, #TSK_TI_FLAGS]	// check for syscall hooks</span><br><span class="line">	tst	x16, #_TIF_SYSCALL_WORK</span><br><span class="line">	b.ne	__sys_trace</span><br><span class="line">	cmp     scno, sc_nr                     // scno - sc_nr，修改条件标志位</span><br><span class="line">	b.hs	ni_sys                          // scno - sc_nr &gt;=0,非法系统条用，则跳转到ni_sys执行</span><br><span class="line">	mask_nospec64 scno, sc_nr, x19	// enforce bounds for syscall number</span><br><span class="line">	ldr	x16, [stbl, scno, lsl #3]	// address in the syscall table</span><br><span class="line">	blr	x16				// call sys_* routine 跳转到系统调用号对应的地址的处理函数去执行</span><br><span class="line">	b	ret_fast_syscall //系统调用表对应的处理函数执行后返回，直接跳到ret_fast_syscall去执行</span><br><span class="line">ni_sys:</span><br><span class="line">	mov	x0, sp</span><br><span class="line">	bl	do_ni_syscall</span><br><span class="line">	b	ret_fast_syscall</span><br><span class="line">ENDPROC(el0_svc)</span><br></pre></td></tr></table></figure>

<p>arm64的系统调用表定义在kernel/arch/arm64/kernel/sys.c，按页对齐。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The sys_call_table array must be 4K aligned to be accessible from</span></span><br><span class="line"><span class="comment"> * kernel/entry.S.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> * <span class="keyword">const</span> sys_call_table[__NR_syscalls] __aligned(<span class="number">4096</span>) = &#123;</span><br><span class="line">	[<span class="number">0</span> ... __NR_syscalls - <span class="number">1</span>] = sys_ni_syscall,</span><br><span class="line">    #include &lt;<span class="keyword">asm</span>/unistd.h&gt; <span class="comment">//这里包含了所有的系统调用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>而我们要看的pipe2就在kernel/include/uapi/asm-generic/unistd.h里面：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* fs/pipe.c */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __NR_pipe2 59</span></span><br><span class="line">__SYSCALL(__NR_pipe2, sys_pipe2)<span class="comment">//所有的系统调用的函数都是sys_这个前缀</span></span><br></pre></td></tr></table></figure>

<p>所以管道的创建最终是在pipe.c里面实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * sys_pipe() is the normal C calling standard for creating</span></span><br><span class="line"><span class="comment"> * a pipe. It's not the way Unix traditionally does this, though.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(pipe2, <span class="keyword">int</span> __user *, fildes, <span class="keyword">int</span>, flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">files</span>[2];</span></span><br><span class="line">	<span class="keyword">int</span> fd[<span class="number">2</span>];</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step1：创建管道</span></span><br><span class="line">	error = __do_pipe_flags(fd, files, flags);</span><br><span class="line">	<span class="keyword">if</span> (!error) &#123;<span class="comment">//创建成功</span></span><br><span class="line">        <span class="comment">//step2：将fd拷贝到用户空间，fildes也就是我们最初的时候传进来的第一个参数pipefd数组的地址</span></span><br><span class="line">        <span class="comment">//如果数据拷贝成功，则返回零；否则，返回没有拷贝成功的数据字节数</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(copy_to_user(fildes, fd, <span class="keyword">sizeof</span>(fd)))) &#123;<span class="comment">//拷贝失败</span></span><br><span class="line">			fput(files[<span class="number">0</span>]);</span><br><span class="line">			fput(files[<span class="number">1</span>]);</span><br><span class="line">			put_unused_fd(fd[<span class="number">0</span>]);</span><br><span class="line">			put_unused_fd(fd[<span class="number">1</span>]);</span><br><span class="line">			error = -EFAULT;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;<span class="comment">//拷贝成功</span></span><br><span class="line">            <span class="comment">//step3：这里将file保存到当前进程所打开的文件列表里面</span></span><br><span class="line">            <span class="comment">//current-&gt;files-&gt;fdt-&gt;fd[fd]指向file；</span></span><br><span class="line">			fd_install(fd[<span class="number">0</span>], files[<span class="number">0</span>]);</span><br><span class="line">			fd_install(fd[<span class="number">1</span>], files[<span class="number">1</span>]);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>step1创建管道，过程比较复杂；主要是在pipefs里面创建文件，并分配文件句柄等。实现了file相关的操作集，如read、write、seek、poll等等。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * cat proc/filesystems</span></span><br><span class="line"><span class="comment"> * nodev   pipefs</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_pipe_fs</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> err = register_filesystem(&amp;pipe_fs_type);<span class="comment">//注册pipefs</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!err) &#123;</span><br><span class="line">		pipe_mnt = kern_mount(&amp;pipe_fs_type);<span class="comment">//挂在pipefs</span></span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(pipe_mnt)) &#123;</span><br><span class="line">			err = PTR_ERR(pipe_mnt);</span><br><span class="line">			unregister_filesystem(&amp;pipe_fs_type);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> err;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fs_initcall(init_pipe_fs);</span><br></pre></td></tr></table></figure>

<p>pipe所支持的操作集：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">file_operations</span> <span class="title">pipefifo_fops</span> = &#123;</span></span><br><span class="line">	.open		= fifo_open,</span><br><span class="line">	.llseek		= no_llseek,</span><br><span class="line">	.read_iter	= pipe_read,</span><br><span class="line">	.write_iter	= pipe_write,</span><br><span class="line">	.poll		= pipe_poll,</span><br><span class="line">	.unlocked_ioctl	= pipe_ioctl,</span><br><span class="line">	.release	= pipe_release,</span><br><span class="line">	.fasync		= pipe_fasync,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>__do_pipe_flags函数负责创建pipe的实质工作：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __do_pipe_flags(<span class="keyword">int</span> *fd, struct file **files, <span class="keyword">int</span> flags)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">int</span> fdw, fdr;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//只支持O_CLOEXEC | O_NONBLOCK | O_DIRECT</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; ~(O_CLOEXEC | O_NONBLOCK | O_DIRECT))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//在pipefs中创建用作管道的两个文件</span></span><br><span class="line">	error = create_pipe_files(files, flags);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//为用于read的file分配fd</span></span><br><span class="line">	error = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_read_pipe;</span><br><span class="line">	fdr = error;</span><br><span class="line"></span><br><span class="line">    <span class="comment">////为用于write的file分配fd</span></span><br><span class="line">	error = get_unused_fd_flags(flags);</span><br><span class="line">	<span class="keyword">if</span> (error &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_fdr;</span><br><span class="line">	fdw = error;</span><br><span class="line"></span><br><span class="line">	audit_fd_pair(fdr, fdw);</span><br><span class="line">	fd[<span class="number">0</span>] = fdr;<span class="comment">//fd[0]作为read管道</span></span><br><span class="line">	fd[<span class="number">1</span>] = fdw;<span class="comment">//fd[1]作为write管道</span></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"> err_fdr:</span><br><span class="line">	put_unused_fd(fdr);</span><br><span class="line"> err_read_pipe:</span><br><span class="line">	fput(files[<span class="number">0</span>]);</span><br><span class="line">	fput(files[<span class="number">1</span>]);</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>其他的流程细节不在继续深入分析，总结下匿名管道的一些特点：</p>
<p>1、管道是基于pipefs文件系统所创建的文件，基于内存实现。但是有别于普通文件，用户创建管道时flags只支持O_CLOEXEC | O_NONBLOCK | O_DIRECT这3种。pipefs为这3中flag实现了和普通文件一样的功能属性。</p>
<p>2、没有名字，只能用于本地具有亲缘关系的进程之间。</p>
<p>3、半双工传输，只支持单向数据流；所以需要两个fd，一个用于读，一个用于写。这个读写是相对的。</p>
<p>4、缓冲区的大小限制，有最大1M和最小1page限制，root用户可以修改最大限制。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The max size that a non-root user is allowed to grow the pipe. Can</span></span><br><span class="line"><span class="comment"> * be set by root in /proc/sys/fs/pipe-max-size</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> pipe_max_size = <span class="number">1048576</span>;<span class="comment">//256页</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Minimum pipe size, as required by POSIX</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">unsigned</span> <span class="keyword">int</span> pipe_min_size = PAGE_SIZE;<span class="comment">//1页</span></span><br></pre></td></tr></table></figure>

<p>创建pipe时缓冲区大小的确认在alloc_pipe_info函数中,root用户通常是16pages、普通用户是1page。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">struct pipe_inode_info *<span class="title">alloc_pipe_info</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> pipe_bufs = PIPE_DEF_BUFFERS;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *<span class="title">user</span> = <span class="title">get_current_user</span>();</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> user_bufs;</span><br><span class="line"></span><br><span class="line">	pipe = kzalloc(<span class="keyword">sizeof</span>(struct pipe_inode_info), GFP_KERNEL_ACCOUNT);</span><br><span class="line">	<span class="keyword">if</span> (pipe == <span class="literal">NULL</span>)</span><br><span class="line">		<span class="keyword">goto</span> out_free_uid;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe_bufs * PAGE_SIZE &gt; pipe_max_size &amp;&amp; !capable(CAP_SYS_RESOURCE))</span><br><span class="line">		pipe_bufs = pipe_max_size &gt;&gt; PAGE_SHIFT;</span><br><span class="line"></span><br><span class="line">	user_bufs = account_pipe_buffers(user, <span class="number">0</span>, pipe_bufs);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (too_many_pipe_buffers_soft(user_bufs) &amp;&amp; is_unprivileged_user()) &#123;</span><br><span class="line">		user_bufs = account_pipe_buffers(user, pipe_bufs, <span class="number">1</span>);</span><br><span class="line">		pipe_bufs = <span class="number">1</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (too_many_pipe_buffers_hard(user_bufs) &amp;&amp; is_unprivileged_user())</span><br><span class="line">		<span class="keyword">goto</span> out_revert_acct;</span><br><span class="line"></span><br><span class="line">	pipe-&gt;bufs = kcalloc(pipe_bufs, <span class="keyword">sizeof</span>(struct pipe_buffer),</span><br><span class="line">			     GFP_KERNEL_ACCOUNT);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;bufs) &#123;</span><br><span class="line">		init_waitqueue_head(&amp;pipe-&gt;wait);</span><br><span class="line">		pipe-&gt;r_counter = pipe-&gt;w_counter = <span class="number">1</span>;</span><br><span class="line">		pipe-&gt;buffers = pipe_bufs;</span><br><span class="line">		pipe-&gt;user = user;</span><br><span class="line">		mutex_init(&amp;pipe-&gt;mutex);</span><br><span class="line">		<span class="keyword">return</span> pipe;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_revert_acct:</span><br><span class="line">	(<span class="keyword">void</span>) account_pipe_buffers(user, pipe_bufs, <span class="number">0</span>);</span><br><span class="line">	kfree(pipe);</span><br><span class="line">out_free_uid:</span><br><span class="line">	free_uid(user);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>5、字节流传输方式，需要通信双方约好数据传输格式。</p>
<p>6、pipe系统调用默认创建了两个文件并且打开相关的文件，分配了fd。pipe后直接可以通过fd操作管道。</p>
<p>7、从write的角度pipe的环形缓冲区的实现，read是write的相反流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">ssize_t</span></span><br><span class="line">pipe_write(struct kiocb *iocb, struct iov_iter *from)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">file</span> *<span class="title">filp</span> = <span class="title">iocb</span>-&gt;<span class="title">ki_filp</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pipe_inode_info</span> *<span class="title">pipe</span> = <span class="title">filp</span>-&gt;<span class="title">private_data</span>;</span></span><br><span class="line">	<span class="keyword">ssize_t</span> ret = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> do_wakeup = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">size_t</span> total_len = iov_iter_count(from);<span class="comment">//此次写入数据的大小</span></span><br><span class="line">	<span class="keyword">ssize_t</span> chars;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* Null write succeeds. */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(total_len == <span class="number">0</span>))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	__pipe_lock(pipe);<span class="comment">//上锁</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!pipe-&gt;readers) &#123;<span class="comment">//pipe没有reader的时候发出SIGPIPE信号</span></span><br><span class="line">		send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">		ret = -EPIPE;</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* We try to merge small writes */</span></span><br><span class="line">	<span class="comment">// 看看这次写入的数据是否有部分可以merge到上次写入时用到的页面</span></span><br><span class="line">	chars = total_len &amp; (PAGE_SIZE<span class="number">-1</span>); <span class="comment">/* size of the last buffer */</span></span><br><span class="line">	<span class="keyword">if</span> (pipe-&gt;nrbufs &amp;&amp; chars != <span class="number">0</span>) &#123;</span><br><span class="line">		<span class="comment">//找到上次写使用的页面索引</span></span><br><span class="line">		<span class="keyword">int</span> lastbuf = (pipe-&gt;curbuf + pipe-&gt;nrbufs - <span class="number">1</span>) &amp;</span><br><span class="line">							(pipe-&gt;buffers - <span class="number">1</span>);</span><br><span class="line">		<span class="comment">//找到上次写使用的页面，看看剩下的空间是否能够容纳这次写入的数据</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> = <span class="title">pipe</span>-&gt;<span class="title">bufs</span> + <span class="title">lastbuf</span>;</span></span><br><span class="line">		<span class="keyword">int</span> offset = buf-&gt;offset + buf-&gt;len;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//can_merge为1，如果page的有效数据的起始+写入大小&lt;页大小，则可以merge</span></span><br><span class="line">		<span class="keyword">if</span> (buf-&gt;ops-&gt;can_merge &amp;&amp; offset + chars &lt;= PAGE_SIZE) &#123;</span><br><span class="line">			ret = pipe_buf_confirm(pipe, buf);<span class="comment">//目前只返回0</span></span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line"></span><br><span class="line">            <span class="comment">//将数据拷贝如页面</span></span><br><span class="line">			ret = copy_page_from_iter(buf-&gt;page, offset, chars, from);</span><br><span class="line">			<span class="keyword">if</span> (unlikely(ret &lt; chars)) &#123;</span><br><span class="line">				ret = -EFAULT;</span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">			&#125;</span><br><span class="line">			do_wakeup = <span class="number">1</span>;</span><br><span class="line">			buf-&gt;len += ret;</span><br><span class="line">			<span class="keyword">if</span> (!iov_iter_count(from))<span class="comment">//看看这次merge后from是否还有数据，如果没有直接跳到out执行</span></span><br><span class="line">				<span class="keyword">goto</span> out;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//到这里，说明这次写入的数据量比较大，超过一个页面大小或者前面的merge消耗不完</span></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="keyword">int</span> bufs;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!pipe-&gt;readers) &#123;</span><br><span class="line">			send_sig(SIGPIPE, current, <span class="number">0</span>);</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -EPIPE;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//pipe中已经被使用的页面数</span></span><br><span class="line">		bufs = pipe-&gt;nrbufs;</span><br><span class="line">		<span class="keyword">if</span> (bufs &lt; pipe-&gt;buffers) &#123;<span class="comment">//还有空闲的页面，继续写入</span></span><br><span class="line">		    <span class="comment">//找到新页面</span></span><br><span class="line">			<span class="keyword">int</span> newbuf = (pipe-&gt;curbuf + bufs) &amp; (pipe-&gt;buffers<span class="number">-1</span>);</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pipe_buffer</span> *<span class="title">buf</span> = <span class="title">pipe</span>-&gt;<span class="title">bufs</span> + <span class="title">newbuf</span>;</span></span><br><span class="line">			<span class="comment">//用于写入的临时页面</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">page</span> *<span class="title">page</span> = <span class="title">pipe</span>-&gt;<span class="title">tmp_page</span>;</span></span><br><span class="line">			<span class="keyword">int</span> copied;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!page) &#123;<span class="comment">//如果pipe没有临时页面，则分配一个</span></span><br><span class="line">				page = alloc_page(GFP_HIGHUSER | __GFP_ACCOUNT);</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!page)) &#123;</span><br><span class="line">					ret = ret ? : -ENOMEM;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">				pipe-&gt;tmp_page = page;</span><br><span class="line">			&#125;</span><br><span class="line">			<span class="comment">/* Always wake up, even if the copy fails. Otherwise</span></span><br><span class="line"><span class="comment">			 * we lock up (O_NONBLOCK-)readers that sleep due to</span></span><br><span class="line"><span class="comment">			 * syscall merging.</span></span><br><span class="line"><span class="comment">			 * FIXME! Is this really true?</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			do_wakeup = <span class="number">1</span>;</span><br><span class="line">			<span class="comment">//拷贝写入一个页面大小的数据</span></span><br><span class="line">			copied = copy_page_from_iter(page, <span class="number">0</span>, PAGE_SIZE, from);</span><br><span class="line">			<span class="comment">//如果拷贝的数据达不到一页，但是from还有数据，说明拷贝出错了</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(copied &lt; PAGE_SIZE &amp;&amp; iov_iter_count(from))) &#123;</span><br><span class="line">				<span class="keyword">if</span> (!ret)</span><br><span class="line">					ret = -EFAULT;</span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">			&#125;</span><br><span class="line">			ret += copied;<span class="comment">//更新已拷贝的数据量</span></span><br><span class="line"></span><br><span class="line">			<span class="comment">/* Insert it into the buffer array */</span></span><br><span class="line">			<span class="comment">//这次产生的临时页面已经写入数据，将其放入pipe的bufs数组中</span></span><br><span class="line">			buf-&gt;page = page;</span><br><span class="line">			buf-&gt;ops = &amp;anon_pipe_buf_ops;</span><br><span class="line">			buf-&gt;offset = <span class="number">0</span>;</span><br><span class="line">			buf-&gt;len = copied;</span><br><span class="line">			buf-&gt;flags = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">if</span> (is_packetized(filp)) &#123;</span><br><span class="line">				buf-&gt;ops = &amp;packet_pipe_buf_ops;</span><br><span class="line">				buf-&gt;flags = PIPE_BUF_FLAG_PACKET;</span><br><span class="line">			&#125;</span><br><span class="line">			pipe-&gt;nrbufs = ++bufs;<span class="comment">//已使用页面数+1</span></span><br><span class="line">			pipe-&gt;tmp_page = <span class="literal">NULL</span>;<span class="comment">//临时页面指针清空</span></span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (!iov_iter_count(from))<span class="comment">//from已经没有数据了，跳出循环</span></span><br><span class="line">				<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//到这里说明from还有数据，如果还有空闲页面则继续写入</span></span><br><span class="line">		<span class="keyword">if</span> (bufs &lt; pipe-&gt;buffers)</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//如果用户创建pipe指定了非阻塞标志，没有数据写入成功则跳出循环，返回错误码-EAGAIN</span></span><br><span class="line">		<span class="keyword">if</span> (filp-&gt;f_flags &amp; O_NONBLOCK) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -EAGAIN;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">//如果当前进程有挂起的信号等待处理</span></span><br><span class="line">		<span class="keyword">if</span> (signal_pending(current)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (!ret)</span><br><span class="line">				ret = -ERESTARTSYS;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">if</span> (do_wakeup) &#123;<span class="comment">//唤醒等待队列上的因为poll挂起的reader</span></span><br><span class="line">			wake_up_interruptible_sync_poll(&amp;pipe-&gt;wait, POLLIN | POLLRDNORM);</span><br><span class="line">			kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">			do_wakeup = <span class="number">0</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		pipe-&gt;waiting_writers++;</span><br><span class="line">		pipe_wait(pipe);<span class="comment">//唤醒别人后，自己进入等待队列，让出cpu</span></span><br><span class="line">		pipe-&gt;waiting_writers--;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	__pipe_unlock(pipe);</span><br><span class="line">	<span class="keyword">if</span> (do_wakeup) &#123;</span><br><span class="line">		wake_up_interruptible_sync_poll(&amp;pipe-&gt;wait, POLLIN | POLLRDNORM);</span><br><span class="line">		kill_fasync(&amp;pipe-&gt;fasync_readers, SIGIO, POLL_IN);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (ret &gt; <span class="number">0</span> &amp;&amp; sb_start_write_trylock(file_inode(filp)-&gt;i_sb)) &#123;</span><br><span class="line">		<span class="keyword">int</span> err = file_update_time(filp);</span><br><span class="line">		<span class="keyword">if</span> (err)</span><br><span class="line">			ret = err;</span><br><span class="line">		sb_end_write(file_inode(filp)-&gt;i_sb);</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大致的缓冲区结构：<img src="/2019/06/15/Linux-system-ipc/write-buffer.PNG" alt="写角度看环形缓冲区"></p>
<h4 id="命名管道（fifo）"><a href="#命名管道（fifo）" class="headerlink" title="命名管道（fifo）"></a>命名管道（fifo）</h4><p>命名管道主要是为了克服管道只能用于有亲缘关系的进程间通信的缺陷。当然具体实现和使用上也是跟管道有所不同。</p>
<p>1、命令管道有名字，可以用于无亲属关系的进程间通信；需要预先创建好命名管道，通信双方知道管道的文件目录和名字，即可打开对应的fifo文件进行操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//bionic/libc/bionic/mkfifo.cpp</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * path：是我们要创建的管道路径，命名管道的api默认指定AT_FDCWD，path则相对于进程当前工作目录的相对路径</span></span><br><span class="line"><span class="comment"> * mode：是创建的模式，命名管道文件类型默认S_IFIFO</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifo</span><span class="params">(<span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mkfifoat(AT_FDCWD, path, mode);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">mkfifoat</span><span class="params">(<span class="keyword">int</span> fd, <span class="keyword">const</span> <span class="keyword">char</span>* path, <span class="keyword">mode_t</span> mode)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mknodat(fd, path, (mode &amp; ~S_IFMT) | S_IFIFO, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//命名管道创建是通过mknodat系统调用，对应内核源码kernel/msm-4.9/fs/namei.c</span></span><br><span class="line">SYSCALL_DEFINE4(mknodat, <span class="keyword">int</span>, dfd, <span class="keyword">const</span> <span class="keyword">char</span> __user *, filename, <span class="keyword">umode_t</span>, mode,</span><br><span class="line">		<span class="keyword">unsigned</span>, dev)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">dentry</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">path</span> <span class="title">path</span>;</span></span><br><span class="line">	<span class="keyword">int</span> error;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> lookup_flags = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	error = may_mknod(mode);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">return</span> error;</span><br><span class="line">retry:</span><br><span class="line">	dentry = user_path_create(dfd, filename, &amp;path, lookup_flags);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(dentry))</span><br><span class="line">		<span class="keyword">return</span> PTR_ERR(dentry);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (!IS_POSIXACL(path.dentry-&gt;d_inode))</span><br><span class="line">		mode &amp;= ~current_umask();</span><br><span class="line">	error = security_path_mknod(&amp;path, dentry, mode, dev);</span><br><span class="line">	<span class="keyword">if</span> (error)</span><br><span class="line">		<span class="keyword">goto</span> out;</span><br><span class="line">	<span class="keyword">switch</span> (mode &amp; S_IFMT) &#123;</span><br><span class="line">		<span class="keyword">case</span> <span class="number">0</span>: <span class="keyword">case</span> S_IFREG:</span><br><span class="line">			error = vfs_create2(path.mnt, path.dentry-&gt;d_inode,dentry,mode,<span class="literal">true</span>);</span><br><span class="line">			<span class="keyword">if</span> (!error)</span><br><span class="line">				ima_post_path_mknod(dentry);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFCHR: <span class="keyword">case</span> S_IFBLK:</span><br><span class="line">			error = vfs_mknod2(path.mnt, path.dentry-&gt;d_inode,dentry,mode,</span><br><span class="line">					new_decode_dev(dev));</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> S_IFIFO: <span class="keyword">case</span> S_IFSOCK:</span><br><span class="line">			error = vfs_mknod(path.dentry-&gt;d_inode,dentry,mode,<span class="number">0</span>);</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">	&#125;</span><br><span class="line">out:</span><br><span class="line">	done_path_create(&amp;path, dentry);</span><br><span class="line">	<span class="keyword">if</span> (retry_estale(error, lookup_flags)) &#123;</span><br><span class="line">		lookup_flags |= LOOKUP_REVAL;</span><br><span class="line">		<span class="keyword">goto</span> retry;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> error;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>2、创建好fifo文件后，就可以用于进程间的通信。开启两个shell终端，用命令行mkfifo、echo、cat三个命令测试下：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span>创建命名管道</span><br><span class="line">mkfifo /mnt/cmd/fifo_test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>终端1先cat会阻塞，直到终端2 echo信息进入管道</span><br><span class="line">1|TB-XXXXX:/proc/1 # cat /mnt/cmd/fifo_test</span><br><span class="line">test</span><br><span class="line"></span><br><span class="line"><span class="meta">#</span>终端1先echo会阻塞，直到终端2 cat管道</span><br></pre></td></tr></table></figure>

<p>说明默认情况下：管道读端未打开，写端阻塞；写端未打开，读端阻塞；管道缓冲区满了，写端阻塞；管道缓冲区空了，读端阻塞。</p>
<p>3、命名管道不像普通的pipe基于特定的pipefs创建，而是一种fifo类型的文件，可以基于任意一种文件系统创建。文件节点存储在不同的文件系统上。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">TB-XXXXX:/proc/1 # ls -lZ /mnt/cmd/fifo_test</span><br><span class="line">prw-rw-rw- 1 root root u:object_r:tmpfs:s0 0 2019-06-17 10:56 /mnt/cmd/fifo_test</span><br><span class="line"><span class="meta">#</span>或者</span><br><span class="line">TB-X505X:/proc/1 # ls -lZ /data/cmd_fifo/test</span><br><span class="line">prw-rw-rw- 1 root root u:object_r:system_data_file:s0 0 2019-06-17 10:58 /data/cmd_fifo/test</span><br></pre></td></tr></table></figure>

<p>4、fifo文件的节点虽然是在各类文件中，但是最终的read、write、open等操作函数还是用了跟普通pipe的操作集一样的pipefifo_fops，在kernel/fs/inode.c中的一些特殊inode初始化可以看出。所以fifo的缓冲区跟pipe是一眼的；只是fifo的alloc_pipe_info是在open的时候调用的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">init_special_inode</span><span class="params">(struct inode *inode, <span class="keyword">umode_t</span> mode, <span class="keyword">dev_t</span> rdev)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	inode-&gt;i_mode = mode;</span><br><span class="line">	<span class="keyword">if</span> (S_ISCHR(mode)) &#123;</span><br><span class="line">		inode-&gt;i_fop = &amp;def_chr_fops;</span><br><span class="line">		inode-&gt;i_rdev = rdev;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISBLK(mode)) &#123;</span><br><span class="line">		inode-&gt;i_fop = &amp;def_blk_fops;</span><br><span class="line">		inode-&gt;i_rdev = rdev;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (S_ISFIFO(mode))<span class="comment">//这是用户通过mkfifo系统调用创建命名管道的时候指定了S_IFIFO标志</span></span><br><span class="line">		inode-&gt;i_fop = &amp;pipefifo_fops;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (S_ISSOCK(mode))</span><br><span class="line">		;	<span class="comment">/* leave it no_open_fops */</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		printk(KERN_DEBUG <span class="string">"init_special_inode: bogus i_mode (%o) for"</span></span><br><span class="line">				  <span class="string">" inode %s:%lu\n"</span>, mode, inode-&gt;i_sb-&gt;s_id,</span><br><span class="line">				  inode-&gt;i_ino);</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(init_special_inode);</span><br></pre></td></tr></table></figure>

<h4 id="信号（signal）"><a href="#信号（signal）" class="headerlink" title="信号（signal）"></a>信号（signal）</h4><p>信号是在软件层次上对中断机制的一种模拟，一个进程收到一个信号就像CPU收到一个中断请求是一样的。信号是异步的、随机的，进程不知道信号到底什么时候到达，也不必通过任何操作来等待信号的到达。但是信号能传递的信息太少，只有一个信号值（就像中断号），Linux支持最多64种信号，信号的定义在kernel/include/uapi/asm-generic/signal.h可以找到。每一种信号的含义都是预先约定好的，比如我们熟悉的信号9是杀死进程。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line">generic_arm64:/ # kill -l</span><br><span class="line"> 1    HUP Hangup                        17   CHLD Child exited                  33     33 Signal 33                     49     49 Signal 49</span><br><span class="line"> 2    INT Interrupt                     18   CONT Continue                      34     34 Signal 34                     50     50 Signal 50</span><br><span class="line"> 3   QUIT Quit                          19   STOP Stopped (signal)              35     35 Signal 35                     51     51 Signal 51</span><br><span class="line"> 4    ILL Illegal instruction           20   TSTP Stopped                       36     36 Signal 36                     52     52 Signal 52</span><br><span class="line"> 5   TRAP Trap                          21   TTIN Stopped (tty input)           37     37 Signal 37                     53     53 Signal 53</span><br><span class="line"> 6   ABRT Aborted                       22   TTOU Stopped (tty output)          38     38 Signal 38                     54     54 Signal 54</span><br><span class="line"> 7    BUS Bus error                     23    URG Urgent I/O condition          39     39 Signal 39                     55     55 Signal 55</span><br><span class="line"> 8    FPE Floating point exception      24   XCPU CPU time limit exceeded       40     40 Signal 40                     56     56 Signal 56</span><br><span class="line"> 9   KILL Killed                        25   XFSZ File size limit exceeded      41     41 Signal 41                     57     57 Signal 57</span><br><span class="line">10   USR1 User signal 1                 26 VTALRM Virtual timer expired         42     42 Signal 42                     58     58 Signal 58</span><br><span class="line">11   SEGV Segmentation fault            27   PROF Profiling timer expired       43     43 Signal 43                     59     59 Signal 59</span><br><span class="line">12   USR2 User signal 2                 28  WINCH Window size changed           44     44 Signal 44                     60     60 Signal 60</span><br><span class="line">13   PIPE Broken pipe                   29     IO I/O possible                  45     45 Signal 45                     61     61 Signal 61</span><br><span class="line">14   ALRM Alarm clock                   30    PWR Power failure                 46     46 Signal 46                     62     62 Signal 62</span><br><span class="line">15   TERM Terminated                    31    SYS Bad system call               47     47 Signal 47                     63     63 Signal 63</span><br><span class="line">16 STKFLT Stack fault                   32     32 Signal 32                     48     48 Signal 48                     64     64 Signal 64</span><br></pre></td></tr></table></figure>

<h5 id="信号的分类"><a href="#信号的分类" class="headerlink" title="信号的分类"></a>信号的分类</h5><p>1、不可靠信号 (非实时信号)<br>信号值小于SIGRTMIN的都是非可靠信号；表现在信号不支持排队,信号可能会丢失, 比如发送多次相同的信号, 进程只能收到一次。</p>
<p>2、可靠信号 (实时信号)<br>信号值位于 [SIGRTMIN, SIGRTMAX] 区间的都是可靠信号；表现在信号支持排队, 不会丢失, 发多少次, 就可以收到多少次。</p>
<h5 id="信号的产生"><a href="#信号的产生" class="headerlink" title="信号的产生"></a>信号的产生</h5><p>1、可能因一些外部输入事件，内核发出某些特定信号。</p>
<p>2、程序出错，如除0操作、内存越界、访问非法地址等也会产生信号。</p>
<p>3、进程用户态通过调用kill、tkill、、tgkill、raise、setitimer、sigqueue等系统调用发出信号。</p>
<p>主要看看kill系统调用发送信号的流程，通过kill的系统调用号__NR_kill可以知道其内核中的处理函数定义在kernel/kernel/signal.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  sys_kill - send a signal to a process</span></span><br><span class="line"><span class="comment"> *  @pid: the PID of the process</span></span><br><span class="line"><span class="comment"> *  @sig: signal to be sent</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line">SYSCALL_DEFINE2(kill, <span class="keyword">pid_t</span>, pid, <span class="keyword">int</span>, sig)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//构建siginfo，代表一个信号</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">siginfo</span> <span class="title">info</span>;</span></span><br><span class="line"></span><br><span class="line">	info.si_signo = sig;    <span class="comment">//信号值</span></span><br><span class="line">	info.si_errno = <span class="number">0</span>;      <span class="comment">//错误码</span></span><br><span class="line">	info.si_code = SI_USER; <span class="comment">//信号来源，即产生信号的原因，SI_USER表示调用kill, sigsend, raise等</span></span><br><span class="line">    <span class="comment">//信号发送者的pid和uid</span></span><br><span class="line">	info.si_pid = task_tgid_vnr(current);</span><br><span class="line">	info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> kill_something_info(sig, &amp;info, pid);<span class="comment">//实际发送的工作</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>继续kill_something_info函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * kill_something_info() interprets pid in interesting ways just like kill(2).</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * POSIX specifies that kill(-1,sig) is unspecified, but what we have</span></span><br><span class="line"><span class="comment"> * is probably wrong.  Should make it like BSD or SYSV.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">kill_something_info</span><span class="params">(<span class="keyword">int</span> sig, struct siginfo *info, <span class="keyword">pid_t</span> pid)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pid大于0时，信号发送给pid所代表的进程</span></span><br><span class="line">	<span class="keyword">if</span> (pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">		rcu_read_lock();</span><br><span class="line">		ret = kill_pid_info(sig, info, find_vpid(pid));</span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* -INT_MIN is undefined.  Exclude this case to avoid a UBSAN warning */</span></span><br><span class="line">	<span class="keyword">if</span> (pid == INT_MIN)</span><br><span class="line">		<span class="keyword">return</span> -ESRCH;</span><br><span class="line"></span><br><span class="line">	read_lock(&amp;tasklist_lock);</span><br><span class="line">    <span class="comment">//pid&lt;=0的情况：不等于-1，信号发送给-pid所代表的进程组；如果0就发给当前进程组</span></span><br><span class="line">	<span class="keyword">if</span> (pid != <span class="number">-1</span>) &#123;</span><br><span class="line">		ret = __kill_pgrp_info(sig, info,</span><br><span class="line">				pid ? find_vpid(-pid) : task_pgrp(current));</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="comment">//发送给除进程自身外的所有进程ID大于1的进程组</span></span><br><span class="line">		<span class="keyword">int</span> retval = <span class="number">0</span>, count = <span class="number">0</span>;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> * <span class="title">p</span>;</span></span><br><span class="line"></span><br><span class="line">		for_each_process(p) &#123;</span><br><span class="line">			<span class="keyword">if</span> (task_pid_vnr(p) &gt; <span class="number">1</span> &amp;&amp;</span><br><span class="line">					!same_thread_group(p, current)) &#123;</span><br><span class="line">				<span class="keyword">int</span> err = group_send_sig_info(sig, info, p);</span><br><span class="line">				++count;</span><br><span class="line">				<span class="keyword">if</span> (err != -EPERM)</span><br><span class="line">					retval = err;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		ret = count ? retval : -ESRCH;</span><br><span class="line">	&#125;</span><br><span class="line">	read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>这几个分支继续调用流程group_send_sig_info-&gt;do_send_sig_info-&gt;send_signal-&gt;__send_signal。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __send_signal(<span class="keyword">int</span> sig, struct siginfo *info, struct task_struct *t,</span><br><span class="line">			<span class="keyword">int</span> group, <span class="keyword">int</span> from_ancestor_ns)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigpending</span> *<span class="title">pending</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sigqueue</span> *<span class="title">q</span>;</span></span><br><span class="line">	<span class="keyword">int</span> override_rlimit;</span><br><span class="line">	<span class="keyword">int</span> ret = <span class="number">0</span>, result;</span><br><span class="line"></span><br><span class="line">	assert_spin_locked(&amp;t-&gt;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	result = TRACE_SIGNAL_IGNORED;</span><br><span class="line">	<span class="keyword">if</span> (!prepare_signal(sig, t,</span><br><span class="line">			from_ancestor_ns || (info == SEND_SIG_FORCED)))</span><br><span class="line">		<span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//目标队列：如果发给进程组，则选用目标进程组的共享挂起队列，否则是线程的私有挂起队列</span></span><br><span class="line">	pending = group ? &amp;t-&gt;signal-&gt;shared_pending : &amp;t-&gt;pending;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Short-circuit ignored signals and support queuing</span></span><br><span class="line"><span class="comment">	 * exactly one non-rt signal, so that we can get more</span></span><br><span class="line"><span class="comment">	 * detailed information about the cause of the signal.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	result = TRACE_SIGNAL_ALREADY_PENDING;</span><br><span class="line">    <span class="comment">//如果要发送的信号小于SIGRTMIN，并且已经在队列中，则返回；也就是小于SIGRTMIN的信号只能入队一次</span></span><br><span class="line">	<span class="keyword">if</span> (legacy_queue(pending, sig))</span><br><span class="line">		<span class="keyword">goto</span> ret;</span><br><span class="line"></span><br><span class="line">	result = TRACE_SIGNAL_DELIVERED;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * fast-pathed signals for kernel-internal things like SIGSTOP</span></span><br><span class="line"><span class="comment">	 * or SIGKILL.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//表明要发送的sig是强制发送的，直接跳到out_set去执行</span></span><br><span class="line">	<span class="keyword">if</span> (info == SEND_SIG_FORCED)</span><br><span class="line">		<span class="keyword">goto</span> out_set;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Real-time signals must be queued if sent by sigqueue, or</span></span><br><span class="line"><span class="comment">	 * some other real-time mechanism.  It is implementation</span></span><br><span class="line"><span class="comment">	 * defined whether kill() does so.  We attempt to do so, on</span></span><br><span class="line"><span class="comment">	 * the principle of least surprise, but since kill is not</span></span><br><span class="line"><span class="comment">	 * allowed to fail with EAGAIN when low on memory we just</span></span><br><span class="line"><span class="comment">	 * make sure at least one signal gets delivered and don't</span></span><br><span class="line"><span class="comment">	 * pass on the info struct.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//发送非实时信号时，info &lt; SEND_SIG_FORCED;信号来源&gt;SI_USER，不受singnal pending资源限制</span></span><br><span class="line">	<span class="keyword">if</span> (sig &lt; SIGRTMIN)</span><br><span class="line">		override_rlimit = (is_si_special(info) || info-&gt;si_code &gt;= <span class="number">0</span>);</span><br><span class="line">	<span class="keyword">else</span><span class="comment">//其他情况都受singnal pending资源限制</span></span><br><span class="line">		override_rlimit = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配一个sigqueue，用于将信号入队</span></span><br><span class="line">    <span class="comment">//singnal pending资源限制，或者还没达到资源限制数量，就会分配成功；否则失败，也就是这个信号被丢弃</span></span><br><span class="line">	q = __sigqueue_alloc(sig, t, GFP_ATOMIC | __GFP_NOTRACK_FALSE_POSITIVE,</span><br><span class="line">		override_rlimit);</span><br><span class="line">	<span class="keyword">if</span> (q) &#123;<span class="comment">//q分配成功，信号入队；并且拷贝信号的信息到q的siginfo_t成员</span></span><br><span class="line">		list_add_tail(&amp;q-&gt;<span class="built_in">list</span>, &amp;pending-&gt;<span class="built_in">list</span>);</span><br><span class="line">		<span class="keyword">switch</span> ((<span class="keyword">unsigned</span> <span class="keyword">long</span>) info) &#123;</span><br><span class="line">		<span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_NOINFO:</span><br><span class="line">			q-&gt;info.si_signo = sig;</span><br><span class="line">			q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">			q-&gt;info.si_code = SI_USER;</span><br><span class="line">			q-&gt;info.si_pid = task_tgid_nr_ns(current,</span><br><span class="line">							task_active_pid_ns(t));</span><br><span class="line">			q-&gt;info.si_uid = from_kuid_munged(current_user_ns(), current_uid());</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">case</span> (<span class="keyword">unsigned</span> <span class="keyword">long</span>) SEND_SIG_PRIV:</span><br><span class="line">			q-&gt;info.si_signo = sig;</span><br><span class="line">			q-&gt;info.si_errno = <span class="number">0</span>;</span><br><span class="line">			q-&gt;info.si_code = SI_KERNEL;</span><br><span class="line">			q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">			q-&gt;info.si_uid = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		<span class="keyword">default</span>:</span><br><span class="line">			copy_siginfo(&amp;q-&gt;info, info);</span><br><span class="line">			<span class="keyword">if</span> (from_ancestor_ns)</span><br><span class="line">				q-&gt;info.si_pid = <span class="number">0</span>;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		userns_fixup_signal_uid(&amp;q-&gt;info, t);</span><br><span class="line"></span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (!is_si_special(info)) &#123;<span class="comment">//这个分支是处理信号被丢失的情况，超过资源限制也就是队列溢出</span></span><br><span class="line">		<span class="keyword">if</span> (sig &gt;= SIGRTMIN &amp;&amp; info-&gt;si_code != SI_USER) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Queue overflow, abort.  We may abort if the</span></span><br><span class="line"><span class="comment">			 * signal was rt and sent by user using something</span></span><br><span class="line"><span class="comment">			 * other than kill().</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">            <span class="comment">//如果实时信号、并且信息来源不是SI_USER，比如通过kill系统调用发送。</span></span><br><span class="line">			result = TRACE_SIGNAL_OVERFLOW_FAIL;</span><br><span class="line">			ret = -EAGAIN;</span><br><span class="line">			<span class="keyword">goto</span> ret;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * This is a silent loss of information.  We still</span></span><br><span class="line"><span class="comment">			 * send the signal, but the *info bits are lost.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			result = TRACE_SIGNAL_LOSE_INFO;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">out_set:</span><br><span class="line">    <span class="comment">//目标进程的信号处理等待队列上不为空，则唤醒队列上的一个线程；这个跟signalfd相关的！！！</span></span><br><span class="line">	signalfd_notify(t, sig);</span><br><span class="line">    <span class="comment">//位图：将目标进程的信号挂起标志，对应的的sig位置1</span></span><br><span class="line">	sigaddset(&amp;pending-&gt;signal, sig);</span><br><span class="line">	complete_signal(sig, t, group);<span class="comment">//complete_signal是信号入队后，找到线程组中的一个合适线程，唤醒其去队列取出信号进行处理</span></span><br><span class="line">ret:</span><br><span class="line">	trace_signal_generate(sig, info, t, group, result);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>complete_signal函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">complete_signal</span><span class="params">(<span class="keyword">int</span> sig, struct task_struct *p, <span class="keyword">int</span> group)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">p</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">t</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Now find a thread we can wake up to take the signal off the queue.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * If the main thread wants the signal, it gets first crack.</span></span><br><span class="line"><span class="comment">	 * Probably the least surprising to the average bear.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//主线程是否需要处理信号？</span></span><br><span class="line">    <span class="comment">//目标进程的信号处于blocked状态、目标进程正在退出、目标进程处于stop或trace；则目标线程不适合</span></span><br><span class="line">    <span class="comment">//如果是信号9、或者目标线程正在cpu上执行且没有挂起的信号，则目标线程合适</span></span><br><span class="line">	<span class="keyword">if</span> (wants_signal(sig, p))</span><br><span class="line">		t = p;</span><br><span class="line">	<span class="keyword">else</span> <span class="keyword">if</span> (!group || thread_group_empty(p))</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * There is just one thread and it does not need to be woken.</span></span><br><span class="line"><span class="comment">		 * It will dequeue unblocked signals before it runs again.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	<span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Otherwise try to find a suitable thread.</span></span><br><span class="line"><span class="comment">		 * 找出一个合适的线程</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		t = signal-&gt;curr_target;</span><br><span class="line">		<span class="keyword">while</span> (!wants_signal(sig, t)) &#123;</span><br><span class="line">			t = next_thread(t);</span><br><span class="line">			<span class="keyword">if</span> (t == signal-&gt;curr_target)</span><br><span class="line">				<span class="comment">/*</span></span><br><span class="line"><span class="comment">				 * No thread needs to be woken.</span></span><br><span class="line"><span class="comment">				 * Any eligible threads will see</span></span><br><span class="line"><span class="comment">				 * the signal in the queue soon.</span></span><br><span class="line"><span class="comment">				 */</span></span><br><span class="line">				<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">		signal-&gt;curr_target = t;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Found a killable thread.  If the signal will be fatal,</span></span><br><span class="line"><span class="comment">	 * then start taking the whole group down immediately.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (sig_fatal(p, sig) &amp;&amp;</span><br><span class="line">	    !(signal-&gt;flags &amp; SIGNAL_GROUP_EXIT) &amp;&amp;</span><br><span class="line">	    !sigismember(&amp;t-&gt;real_blocked, sig) &amp;&amp;</span><br><span class="line">	    (sig == SIGKILL || !p-&gt;ptrace)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * This signal will be fatal to the whole group.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (!sig_kernel_coredump(sig)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * Start a group exit and wake everybody up.</span></span><br><span class="line"><span class="comment">			 * This way we don't have other threads</span></span><br><span class="line"><span class="comment">			 * running and doing things after a slower</span></span><br><span class="line"><span class="comment">			 * thread has the fatal signal pending.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			signal-&gt;flags = SIGNAL_GROUP_EXIT;</span><br><span class="line">			signal-&gt;group_exit_code = sig;</span><br><span class="line">			signal-&gt;group_stop_count = <span class="number">0</span>;</span><br><span class="line">			t = p;</span><br><span class="line">			<span class="keyword">do</span> &#123;</span><br><span class="line">				task_clear_jobctl_pending(t, JOBCTL_PENDING_MASK);</span><br><span class="line">				sigaddset(&amp;t-&gt;pending.signal, SIGKILL);</span><br><span class="line">				signal_wake_up(t, <span class="number">1</span>);</span><br><span class="line">			&#125; while_each_thread(p, t);</span><br><span class="line">			<span class="keyword">return</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The signal is already in the shared-pending queue.</span></span><br><span class="line"><span class="comment">	 * Tell the chosen thread to wake up and dequeue it.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	signal_wake_up(t, sig == SIGKILL);唤醒指定的线程，设置目标线程TIF_SIGPENDING标志</span><br><span class="line">	<span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>大体过了一遍信号发送流程后，信号在内核中与进程之间的关系可以总结如下：<img src="/2019/06/15/Linux-system-ipc/signal-struct.PNG" alt="信号结构关系"></p>
<h5 id="信号的处理"><a href="#信号的处理" class="headerlink" title="信号的处理"></a>信号的处理</h5><p>1、sigtimedwait；通过这个系统调用，用户程序可以带等待指定的信号到来并做一些处理；Android的dumpstate命令有用到这个，在frameworks/native/cmds/dumpstate/DumpstateUtil.cpp的waitpid_with_timeout函数可以看到使用方法。</p>
<p>2、signalfd；通过这个系统调用，用户程序可以创建一个接收信号的文件描述符，等待指定信号到来该文件描述符实现了标准的文件的相关操作集。Android的init进程有用到，在/system/core/init/init.cpp中的InstallSigtermHandler函数可以看到使用方法。</p>
<p>3、signal；通过这个系统调。用户程序可以注册自己的信号处理机，系统从内核态返回用户态前会处理一些工作，其中就包括信号的处理；以arm64架构为例，在kernel/arch/arm64/kernel/entry.S可以看到work_pending的处理。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">/*</span><br><span class="line"> * Ok, we need to do extra processing, enter the slow path.</span><br><span class="line"> */</span><br><span class="line">work_pending:</span><br><span class="line">	mov	x0, sp				// &apos;regs&apos;</span><br><span class="line">	bl	do_notify_resume          #--&gt;关键函数</span><br><span class="line">#ifdef CONFIG_TRACE_IRQFLAGS</span><br><span class="line">	bl	trace_hardirqs_on		// enabled while in userspace</span><br><span class="line">#endif</span><br><span class="line">	ldr	x1, [tsk, #TSK_TI_FLAGS]	// re-check for single-step</span><br><span class="line">	b	finish_ret_to_user</span><br><span class="line">/*</span><br><span class="line"> * &quot;slow&quot; syscall return path.</span><br><span class="line"> */</span><br><span class="line">ret_to_user:</span><br><span class="line">	disable_irq				// disable interrupts关闭中断</span><br><span class="line">	// 先获取线程的flags信息，放到x1中</span><br><span class="line">	// DEFINE(TSK_TI_FLAGS,		offsetof(struct task_struct, thread_info.flags));</span><br><span class="line">	ldr	x1, [tsk, #TSK_TI_FLAGS]</span><br><span class="line">	/* x1和_TIF_WORK_MASK做与操作，arm64为例，_TIF_WORK_MASK中包含了_TIF_SIGPENDING</span><br><span class="line">	 * 也就是我们前面在complete_signal函数看到的，发送信号完成后唤醒线程设置了这个标志位</span><br><span class="line">	* #define _TIF_WORK_MASK		(_TIF_NEED_RESCHED | _TIF_SIGPENDING | \</span><br><span class="line">				 _TIF_NOTIFY_RESUME | _TIF_FOREIGN_FPSTATE)</span><br><span class="line">	*/</span><br><span class="line">	and	x2, x1, #_TIF_WORK_MASK</span><br><span class="line">	cbnz	x2, work_pending</span><br><span class="line">finish_ret_to_user:</span><br><span class="line">	enable_step_tsk x1, x2</span><br><span class="line">	kernel_exit 0</span><br><span class="line">ENDPROC(ret_to_user)</span><br></pre></td></tr></table></figure>

<p>arm64的do_notify_resume函数在kernel/arch/arm64/kernel/signal.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="function">asmlinkage <span class="keyword">void</span> <span class="title">do_notify_resume</span><span class="params">(struct pt_regs *regs,</span></span></span><br><span class="line"><span class="function"><span class="params">				 <span class="keyword">unsigned</span> <span class="keyword">int</span> thread_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The assembly code enters us with IRQs off, but it hasn't</span></span><br><span class="line"><span class="comment">	 * informed the tracing code of that for efficiency reasons.</span></span><br><span class="line"><span class="comment">	 * Update the trace code with the current status.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	trace_hardirqs_off();</span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (thread_flags &amp; _TIF_NEED_RESCHED) &#123;</span><br><span class="line">			schedule();</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			local_irq_enable();</span><br><span class="line"></span><br><span class="line">            <span class="comment">//处理信号相关事务</span></span><br><span class="line">			<span class="keyword">if</span> (thread_flags &amp; _TIF_SIGPENDING)</span><br><span class="line">				do_signal(regs);</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (thread_flags &amp; _TIF_NOTIFY_RESUME) &#123;</span><br><span class="line">				clear_thread_flag(TIF_NOTIFY_RESUME);</span><br><span class="line">				tracehook_notify_resume(regs);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (thread_flags &amp; _TIF_FOREIGN_FPSTATE)</span><br><span class="line">				fpsimd_restore_current_state();</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		local_irq_disable();</span><br><span class="line">		thread_flags = READ_ONCE(current_thread_info()-&gt;flags);</span><br><span class="line">	&#125; <span class="keyword">while</span> (thread_flags &amp; _TIF_WORK_MASK);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>arm64的do_signal函数在kernel/arch/arm64/kernel/signal.c中：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Note that 'init' is a special process: it doesn't get signals it doesn't</span></span><br><span class="line"><span class="comment"> * want to handle. Thus you cannot kill init even with a SIGKILL even by</span></span><br><span class="line"><span class="comment"> * mistake.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Note that we go through the signals twice: once to check the signals that</span></span><br><span class="line"><span class="comment"> * the kernel can handle, and then we build all the user-level signal handling</span></span><br><span class="line"><span class="comment"> * stack-frames in one go after that.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">do_signal</span><span class="params">(struct pt_regs *regs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> continue_addr = <span class="number">0</span>, restart_addr = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> retval = <span class="number">0</span>;</span><br><span class="line">	<span class="keyword">int</span> syscall = (<span class="keyword">int</span>)regs-&gt;syscallno;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ksignal</span> <span class="title">ksig</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If we were from a system call, check for system call restarting...</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (syscall &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">		continue_addr = regs-&gt;pc;</span><br><span class="line">		restart_addr = continue_addr - (compat_thumb_mode(regs) ? <span class="number">2</span> : <span class="number">4</span>);</span><br><span class="line">		retval = regs-&gt;regs[<span class="number">0</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Avoid additional syscall restarting via ret_to_user.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		regs-&gt;syscallno = ~<span class="number">0U</span>L;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Prepare for system call restart. We do this here so that a</span></span><br><span class="line"><span class="comment">		 * debugger will see the already changed PC.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">switch</span> (retval) &#123;</span><br><span class="line">		<span class="keyword">case</span> -ERESTARTNOHAND:</span><br><span class="line">		<span class="keyword">case</span> -ERESTARTSYS:</span><br><span class="line">		<span class="keyword">case</span> -ERESTARTNOINTR:</span><br><span class="line">		<span class="keyword">case</span> -ERESTART_RESTARTBLOCK:</span><br><span class="line">			regs-&gt;regs[<span class="number">0</span>] = regs-&gt;orig_x0;</span><br><span class="line">			regs-&gt;pc = restart_addr;</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Get the signal to deliver. When running under ptrace, at this point</span></span><br><span class="line"><span class="comment">	 * the debugger may change all of our registers.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//获取一个要处理的信号，也就是用户注册了自己的处理机的信号</span></span><br><span class="line">	 <span class="comment">//这个函数也包含了信号在内核默认处理相关流程</span></span><br><span class="line">	<span class="keyword">if</span> (get_signal(&amp;ksig)) &#123;</span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Depending on the signal settings, we may need to revert the</span></span><br><span class="line"><span class="comment">		 * decision to restart the system call, but skip this if a</span></span><br><span class="line"><span class="comment">		 * debugger has chosen to restart at a different PC.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (regs-&gt;pc == restart_addr &amp;&amp;</span><br><span class="line">		    (retval == -ERESTARTNOHAND ||</span><br><span class="line">		     retval == -ERESTART_RESTARTBLOCK ||</span><br><span class="line">		     (retval == -ERESTARTSYS &amp;&amp;</span><br><span class="line">		      !(ksig.ka.sa.sa_flags &amp; SA_RESTART)))) &#123;</span><br><span class="line">			regs-&gt;regs[<span class="number">0</span>] = -EINTR;</span><br><span class="line">			regs-&gt;pc = continue_addr;</span><br><span class="line">		&#125;</span><br><span class="line">        <span class="comment">//为信号处理机准备环境，进入用户模式，并调用信号处理函数</span></span><br><span class="line">		handle_signal(&amp;ksig, regs);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br></pre></td></tr></table></figure>

<p>kernel/kernel/Signal.c-&gt;get_signal函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">get_signal</span><span class="params">(struct ksignal *ksig)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">sighand_struct</span> *<span class="title">sighand</span> = <span class="title">current</span>-&gt;<span class="title">sighand</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">signal_struct</span> *<span class="title">signal</span> = <span class="title">current</span>-&gt;<span class="title">signal</span>;</span></span><br><span class="line">	<span class="keyword">int</span> signr;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(current-&gt;task_works))</span><br><span class="line">		task_work_run();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(uprobe_deny_signal()))</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Do this once, we can't return to user-mode if freezing() == T.</span></span><br><span class="line"><span class="comment">	 * do_signal_stop() and ptrace_stop() do freezable_schedule() and</span></span><br><span class="line"><span class="comment">	 * thus do not need another check after return.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	try_to_freeze();</span><br><span class="line"></span><br><span class="line">relock:</span><br><span class="line">	spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Every stopped thread goes here after wakeup. Check to see if</span></span><br><span class="line"><span class="comment">	 * we should notify the parent, prepare_signal(SIGCONT) encodes</span></span><br><span class="line"><span class="comment">	 * the CLD_ si_code into SIGNAL_CLD_MASK bits.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_CLD_MASK)) &#123;</span><br><span class="line">		<span class="keyword">int</span> why;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (signal-&gt;flags &amp; SIGNAL_CLD_CONTINUED)</span><br><span class="line">			why = CLD_CONTINUED;</span><br><span class="line">		<span class="keyword">else</span></span><br><span class="line">			why = CLD_STOPPED;</span><br><span class="line"></span><br><span class="line">		signal-&gt;flags &amp;= ~SIGNAL_CLD_MASK;</span><br><span class="line"></span><br><span class="line">		spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Notify the parent that we're continuing.  This event is</span></span><br><span class="line"><span class="comment">		 * always per-process and doesn't make whole lot of sense</span></span><br><span class="line"><span class="comment">		 * for ptracers, who shouldn't consume the state via</span></span><br><span class="line"><span class="comment">		 * wait(2) either, but, for backward compatibility, notify</span></span><br><span class="line"><span class="comment">		 * the ptracer of the group leader too unless it's gonna be</span></span><br><span class="line"><span class="comment">		 * a duplicate.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		read_lock(&amp;tasklist_lock);</span><br><span class="line">		do_notify_parent_cldstop(current, <span class="literal">false</span>, why);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (ptrace_reparented(current-&gt;group_leader))</span><br><span class="line">			do_notify_parent_cldstop(current-&gt;group_leader,</span><br><span class="line">						<span class="literal">true</span>, why);</span><br><span class="line">		read_unlock(&amp;tasklist_lock);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">goto</span> relock;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">k_sigaction</span> *<span class="title">ka</span>;</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp; JOBCTL_STOP_PENDING) &amp;&amp;</span><br><span class="line">		    do_signal_stop(<span class="number">0</span>))</span><br><span class="line">			<span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(current-&gt;jobctl &amp; JOBCTL_TRAP_MASK)) &#123;</span><br><span class="line">			do_jobctl_trap();</span><br><span class="line">			spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">			<span class="keyword">goto</span> relock;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//优先从私有队列取出信号，若没有才从共享队列中取</span></span><br><span class="line">        <span class="comment">//被设置为blocked的信号不处理</span></span><br><span class="line">		signr = dequeue_signal(current, &amp;current-&gt;blocked, &amp;ksig-&gt;info);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (!signr)</span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">/* will return 0 */</span></span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (unlikely(current-&gt;ptrace) &amp;&amp; signr != SIGKILL) &#123;</span><br><span class="line">			signr = ptrace_signal(signr, &amp;ksig-&gt;info);</span><br><span class="line">			<span class="keyword">if</span> (!signr)</span><br><span class="line">				<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//取出信号对应的处理机</span></span><br><span class="line">		ka = &amp;sighand-&gt;action[signr<span class="number">-1</span>];</span><br><span class="line"></span><br><span class="line">		<span class="comment">/* Trace actually delivered signals. */</span></span><br><span class="line">		trace_signal_deliver(signr, &amp;ksig-&gt;info, ka);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//忽略信号</span></span><br><span class="line">		<span class="keyword">if</span> (ka-&gt;sa.sa_handler == SIG_IGN) <span class="comment">/* Do nothing.  */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		<span class="comment">//不是设置SIG_DFL的信号，也就是用户注册了自己的信号处理机</span></span><br><span class="line">        <span class="comment">//然后跳出循环，返回</span></span><br><span class="line">		<span class="keyword">if</span> (ka-&gt;sa.sa_handler != SIG_DFL) &#123;</span><br><span class="line">			<span class="comment">/* Run the handler.  */</span></span><br><span class="line">			ksig-&gt;ka = *ka;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (ka-&gt;sa.sa_flags &amp; SA_ONESHOT)</span><br><span class="line">				ka-&gt;sa.sa_handler = SIG_DFL;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">break</span>; <span class="comment">/* will return non-zero "signr" value */</span></span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Now we are doing the default action for this signal.</span></span><br><span class="line"><span class="comment">		 * 现在我们正在对此信号执行默认操作。</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//内核指定忽略的一些信号</span></span><br><span class="line">		<span class="keyword">if</span> (sig_kernel_ignore(signr)) <span class="comment">/* Default is nothing. */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Global init gets no signals it doesn't want.</span></span><br><span class="line"><span class="comment">		 * Container-init gets no signals it doesn't want from same</span></span><br><span class="line"><span class="comment">		 * container.</span></span><br><span class="line"><span class="comment">		 *</span></span><br><span class="line"><span class="comment">		 * Note that if global/container-init sees a sig_kernel_only()</span></span><br><span class="line"><span class="comment">		 * signal here, the signal must have been generated internally</span></span><br><span class="line"><span class="comment">		 * or must have come from an ancestor namespace. In either</span></span><br><span class="line"><span class="comment">		 * case, the signal cannot be dropped.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal-&gt;flags &amp; SIGNAL_UNKILLABLE) &amp;&amp;</span><br><span class="line">				!sig_kernel_only(signr))</span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//进程终止或者continue信号，设置进程对应的状态</span></span><br><span class="line">		<span class="keyword">if</span> (sig_kernel_stop(signr)) &#123;</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * The default action is to stop all threads in</span></span><br><span class="line"><span class="comment">			 * the thread group.  The job control signals</span></span><br><span class="line"><span class="comment">			 * do nothing in an orphaned pgrp, but SIGSTOP</span></span><br><span class="line"><span class="comment">			 * always works.  Note that siglock needs to be</span></span><br><span class="line"><span class="comment">			 * dropped during the call to is_orphaned_pgrp()</span></span><br><span class="line"><span class="comment">			 * because of lock ordering with tasklist_lock.</span></span><br><span class="line"><span class="comment">			 * This allows an intervening SIGCONT to be posted.</span></span><br><span class="line"><span class="comment">			 * We need to check for that and bail out if necessary.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">if</span> (signr != SIGSTOP) &#123;</span><br><span class="line">				spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">				<span class="comment">/* signals can be posted during this window */</span></span><br><span class="line"></span><br><span class="line">				<span class="keyword">if</span> (is_current_pgrp_orphaned())</span><br><span class="line">					<span class="keyword">goto</span> relock;</span><br><span class="line"></span><br><span class="line">				spin_lock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="keyword">if</span> (likely(do_signal_stop(ksig-&gt;info.si_signo))) &#123;</span><br><span class="line">				<span class="comment">/* It released the siglock.  */</span></span><br><span class="line">				<span class="keyword">goto</span> relock;</span><br><span class="line">			&#125;</span><br><span class="line"></span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * We didn't actually stop, due to a race</span></span><br><span class="line"><span class="comment">			 * with SIGCONT or something like that.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			<span class="keyword">continue</span>;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Anything else is fatal, maybe with a core dump.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		current-&gt;flags |= PF_SIGNALED;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//coredump相关的信号处理</span></span><br><span class="line">		<span class="keyword">if</span> (sig_kernel_coredump(signr)) &#123;</span><br><span class="line">			<span class="keyword">if</span> (print_fatal_signals)</span><br><span class="line">				print_fatal_signal(ksig-&gt;info.si_signo);</span><br><span class="line">			proc_coredump_connector(current);</span><br><span class="line">			<span class="comment">/*</span></span><br><span class="line"><span class="comment">			 * If it was able to dump core, this kills all</span></span><br><span class="line"><span class="comment">			 * other threads in the group and synchronizes with</span></span><br><span class="line"><span class="comment">			 * their demise.  If we lost the race with another</span></span><br><span class="line"><span class="comment">			 * thread getting here, it set group_exit_code</span></span><br><span class="line"><span class="comment">			 * first and our do_group_exit call below will use</span></span><br><span class="line"><span class="comment">			 * that value and ignore the one we pass it.</span></span><br><span class="line"><span class="comment">			 */</span></span><br><span class="line">			do_coredump(&amp;ksig-&gt;info);</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Death signals, no core dump.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		<span class="comment">//跑到这里说明，这个信号会使得进程被kill，进程退出</span></span><br><span class="line">		do_group_exit(ksig-&gt;info.si_signo);</span><br><span class="line">		<span class="comment">/* NOTREACHED */</span></span><br><span class="line">	&#125;</span><br><span class="line">	spin_unlock_irq(&amp;sighand-&gt;siglock);</span><br><span class="line"></span><br><span class="line">	ksig-&gt;sig = signr;</span><br><span class="line">	<span class="keyword">return</span> ksig-&gt;sig &gt; <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从这个函数可以看到处理的信号有以下几种情况：</p>
<p>1、信号处理机为SIG_IGN：在内核直接忽略，不做任何处理。</p>
<p>2、信号处理机不为SIG_DFL：说明用户注册了自定义处理机，这种信号需要到用户空间调用信号处理函数进行处理。</p>
<p>3、信号处理机为SIG_DFL：即为信号的默认处理，在内核处理。细分为：</p>
<ul>
<li><p>进程Stop/Continue信号，内核根据信号设置进程的状态。</p>
</li>
<li><p>内核默认忽略的一些信号，见SIG_KERNEL_IGNORE_MASK。</p>
</li>
<li><p>coredump相关的信号，见sig_kernel_coredump。</p>
</li>
<li><p>其他的默认处理是调用do_group_exit退出进程。</p>
</li>
</ul>
<p>第2点是用户注册了信号处理函数，需要在用户空间执行，见handle_signal函数。这个函数的实现涉及到不同CPU架构，对于栈帧的准备等看不太懂，以后能理解了在补充。</p>
<h4 id="消息队列（msgqueue）"><a href="#消息队列（msgqueue）" class="headerlink" title="消息队列（msgqueue）"></a>消息队列（msgqueue）</h4><p>待续….</p>
<h4 id="信号量（semaphore）"><a href="#信号量（semaphore）" class="headerlink" title="信号量（semaphore）"></a>信号量（semaphore）</h4><p>或者说信号灯，其他进程间通信方式不大相同，它主要提供对进程间共享资源访问控制机制。把它理解为对资源的引用计数，或者对资源进行互斥访问的机制；用于进程间同步。bionic/libc/bionic/sys_sem.cpp可以看到Android系统上的相关系统的调用。</p>
<p>待续….</p>
<h4 id="共享内存（sharedmemory）"><a href="#共享内存（sharedmemory）" class="headerlink" title="共享内存（sharedmemory）"></a>共享内存（sharedmemory）</h4><p>待续….</p>
<h4 id="网络通信（socket）"><a href="#网络通信（socket）" class="headerlink" title="网络通信（socket）"></a>网络通信（socket）</h4><p>socket不但可以用户本地进程间的通信，还可以用于远程进程间的通信。涉及到很多网络协议，没有专门做过网络通信相关的东西；暂不分析！</p>
<h4 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h4><p><a href="http://www.bubuko.com/infodetail-3060365.html" target="_blank" rel="noopener">http://www.bubuko.com/infodetail-3060365.html</a></p>
<p><a href="https://blog.csdn.net/ds1130071727/article/details/78519527" target="_blank" rel="noopener">https://blog.csdn.net/ds1130071727/article/details/78519527</a></p>
<p><a href="https://blog.csdn.net/u013298300/article/details/51214155" target="_blank" rel="noopener">https://blog.csdn.net/u013298300/article/details/51214155</a></p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/06/15/Linux-system-ipc/" data-id="cjzva4h3q002i6giilcs1g2yz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
    <a href="/2019/06/25/Android-Init-FBE/" id="article-nav-newer" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Newer</strong>
      <div class="article-nav-title">
        
          Android启动流程-FBE部分
        
      </div>
    </a>
  
  
    <a href="/2019/06/01/Android-hidl-sample-impletment/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">Android9.0 HIDL 学习</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AIDL/">AIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">13</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HIDL/">HIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">14</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/driver/">driver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">19</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实战/">实战</a><span class="tag-list-count">8</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稳定性/">稳定性</a><span class="tag-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AIDL/" style="font-size: 10px;">AIDL</a> <a href="/tags/Android/" style="font-size: 15px;">Android</a> <a href="/tags/HIDL/" style="font-size: 10px;">HIDL</a> <a href="/tags/Linux/" style="font-size: 17.5px;">Linux</a> <a href="/tags/driver/" style="font-size: 10px;">driver</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/实战/" style="font-size: 12.5px;">实战</a> <a href="/tags/稳定性/" style="font-size: 12.5px;">稳定性</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/08/">August 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/08/26/ARMv8-linux-spinlock-understanding/">Linux spinlock的底层实现</a>
          </li>
        
          <li>
            <a href="/2019/08/01/Arm-linux-exception-flows/">Linux-ARMv8异常相关知识</a>
          </li>
        
          <li>
            <a href="/2019/07/20/Android-gdb-extract-logs/">Android9.0 logd进程空间提取日志信息</a>
          </li>
        
          <li>
            <a href="/2019/07/15/Android-booting-time-spent/">Android开机时间分析</a>
          </li>
        
          <li>
            <a href="/2019/07/10/a-intentresolver-cts-issue/">关于IntentResolver的一个cts问题</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 JoyYoung<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>