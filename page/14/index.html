<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>JoyYoung&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JoyYoung&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/14/index.html">
<meta property="og:site_name" content="JoyYoung&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JoyYoung&#39;s blog">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoyYoung&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux-kernel-sync" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/26/Linux-kernel-sync/" class="article-date">
  <time datetime="2019-04-26T15:47:44.000Z" itemprop="datePublished">2019-04-26</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/26/Linux-kernel-sync/">Linux内核同步机制</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="同步机制"><a href="#同步机制" class="headerlink" title="同步机制"></a>同步机制</h2><p>多个执行单元在同个CPU上并发执行，或者多个执行单元在多个CPU并行执行；可能会同一时间访问到一些共享资源（如：硬件上的一些外设、软件上的全局变量等）形成竞争状态。竞态在多任务操作系统中几乎是无处不在的，竞态问题不加以规避的话，可能回导致程序得不到预期的执行结果或者其他更严重的问题。</p>
<p>解决竞态问题的方法是保证对共享资源的互斥访问 ，互斥访问就是指一个执行单元在访问共享资源的时候，其他的执行单元被禁止访问 ；访问共享资源的代码区域称为临界区（critical sections），临界区需要以某种互斥机制加以保护。</p>
<h4 id="内存屏障"><a href="#内存屏障" class="headerlink" title="内存屏障"></a>内存屏障</h4><p>防止编译器优化我们的代码，让我们代码的执行顺序与我们所写的保持一致！是一种编译器就对代码执行顺序进行保护的机制！</p>
<h4 id="禁止抢占"><a href="#禁止抢占" class="headerlink" title="禁止抢占"></a>禁止抢占</h4><p>禁止抢占某种程度上是保证互斥的一种方法。假设单cpu系统中，某个线程得到了cpu资源后调用得意执行，然后调用preempt_disable()禁止系统抢占，使得它可以完成所有（包括共享资源）的访问和操作。</p>
<h4 id="关闭中断"><a href="#关闭中断" class="headerlink" title="关闭中断"></a>关闭中断</h4><p>有时候关闭抢占可能不够，因为中断的优先级是比进程高的。那么及时在单cpu系统中关闭了抢占的情况下，也有可能被中断打断。</p>
<h4 id="原子操作"><a href="#原子操作" class="headerlink" title="原子操作"></a>原子操作</h4><p>在c语言写的程序中，即使是对一个变量做+1的操作，如a++，看是只有一条语句，其实汇编语句上通常是被翻译成3个步骤：</p>
<p>1、读一个位于memory中的变量的值到寄存器中</p>
<p>2、寄存器中的值进行+1操作</p>
<p>3、将寄存器中的数值写回memory中的变量值</p>
<p>这个过程中，如果1的步骤之后；另一个执行程序（另一个线程、中断等）抢占了CPU资源，并完成对a的修改，那么当前的执行程序重新执行后就会覆盖掉另一个程序的结果；这样就可能导致一些问题。原子操作就是对这种read-modify-write问题本质上保证了对内存read和write访问的原子性，也就是说对内存的读和写的访问不能被打断。以arm64实现的相关原子操作接口可以在kernel/arch/arm64/include/asm/atomic.h中查得。</p>
<h4 id="自旋锁"><a href="#自旋锁" class="headerlink" title="自旋锁"></a>自旋锁</h4><p>对于共享资源的互斥访问可能发生在进程上下文、中断上下文之间的各种组合之中；因为中断的参与，一些会导致休眠的锁机制就不能用，所以需要用到自旋锁。自旋锁定义如下：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//使用自选锁用spinlock_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">spinlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> <span class="title">rlock</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> LOCK_PADSIZE (offsetof(struct raw_spinlock, dep_map))</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">			u8 __padding[LOCK_PADSIZE];</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line">		&#125;;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	&#125;;</span><br><span class="line">&#125; <span class="keyword">spinlock_t</span>;</span><br><span class="line"><span class="comment">//重点是raw_spinlock_t</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">raw_spinlock</span> &#123;</span></span><br><span class="line">	<span class="keyword">arch_spinlock_t</span> raw_lock;<span class="comment">//不同架构实现</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_GENERIC_LOCKBREAK</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> break_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_SPINLOCK <span class="comment">//spinlock问题调试需要用到</span></span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> magic, owner_cpu;</span><br><span class="line">	<span class="keyword">void</span> *owner;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">raw_spinlock_t</span>;</span><br></pre></td></tr></table></figure>

<p>自选锁大概有以下特点：</p>
<p>1、只允许同时只有一个执行单元进入临界区。</p>
<p>2、执行时间短。由于spin lock死等这种特性，一般用在那些代码不是非常复杂的临界区，执行时间要求较高，不应太长。</p>
<p>3、可以在中断上下文中使用。</p>
<p>4、spin lock是一种死等的锁机制。当共享资源临界区已经被其他执行体持有的时候，后来者尝试持有的时候会不断的重新尝试直到获取锁进入临界区。</p>
<p>竞争者都在进程上下文中的时候，spin lock需要禁止本cpu抢占，以防止更高优先级的进程抢占了当前cpu并尝试spin lock时出现忙等的情况：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	preempt_disable();</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>竞争者有进程上下文和中断上下文的时候，还需要禁止本地中断，以防止中断处理函数抢占了当前的cpu并尝试spin lock的时候出现忙等的情况，从而引起后续其他cpu进程可能出现的spin lock忙等现象：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock_irq(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	local_irq_disable();</span><br><span class="line">	preempt_disable();</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于进程上下文和软中断上下文的场景，则不需要关闭中断那么大动作了，内核也提供了相应的接口，配合禁止中断下半部：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> __raw_spin_lock_bh(<span class="keyword">raw_spinlock_t</span> *lock)</span><br><span class="line">&#123;</span><br><span class="line">	__local_bh_disable_ip(_RET_IP_, SOFTIRQ_LOCK_OFFSET);</span><br><span class="line">	spin_acquire(&amp;lock-&gt;dep_map, <span class="number">0</span>, <span class="number">0</span>, _RET_IP_);</span><br><span class="line">	LOCK_CONTENDED(lock, do_raw_spin_trylock, do_raw_spin_lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="读写自旋锁"><a href="#读写自旋锁" class="headerlink" title="读写自旋锁"></a>读写自旋锁</h4><p>和通用自旋锁不同，读写自旋锁对共享资源互斥访问进行了细化，对读写进行了区分。比如某些场景下，多个线程可以同时对共享资源进行度操作的，就没有必要对读操作进行互斥了；给了reader更多机会，某种程度上减少了发生互斥的概率，提升了效率。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//--&gt; spinlock_types.h</span></span><br><span class="line"><span class="comment">//申明一个读写锁的方法</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_RWLOCK(x)	rwlock_t x = __RW_LOCK_UNLOCKED(x)</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//--&gt;rwlock.h</span></span><br><span class="line"><span class="comment">//操作集</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_trylock(lock)	__cond_lock(lock, _raw_read_trylock(lock))</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_trylock(lock)	__cond_lock(lock, _raw_write_trylock(lock))</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_lock(lock)	_raw_write_lock(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_lock(lock)		_raw_read_lock(lock)</span></span><br><span class="line">...</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_lock_irq(lock)		_raw_read_lock_irq(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_lock_bh(lock)		_raw_read_lock_bh(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_lock_irq(lock)		_raw_write_lock_irq(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_lock_bh(lock)		_raw_write_lock_bh(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_unlock(lock)		_raw_read_unlock(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_unlock(lock)		_raw_write_unlock(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> read_unlock_irq(lock)		_raw_read_unlock_irq(lock)</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> write_unlock_irq(lock)		_raw_write_unlock_irq(lock)</span></span><br></pre></td></tr></table></figure>

<p>读写自旋锁有以下特点，互斥关系的后者要等前者完成才能得到锁。</p>
<ul>
<li><p>读锁之间是共享的，即一个线程持有了读锁之后，其他线程也能够以读的方式持有这个锁。</p>
</li>
<li><p>写锁之间是互斥的，即一个线程持有了写锁之后，其他线程不能以读或者写的方式持有这个锁。</p>
</li>
<li><p>读写锁之间是互斥的，即已经有线程持有了读锁之后，其他线程不能以写的方式持有这个锁，直到所有的reader线程释放这个锁。</p>
</li>
</ul>
<h4 id="顺序锁"><a href="#顺序锁" class="headerlink" title="顺序锁"></a>顺序锁</h4><p>先看看相关的定义和接口：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//类型定义，顺序锁是spinlock加上seqcount计数</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">seqcount</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> sequence;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125; <span class="keyword">seqcount_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">seqcount</span> <span class="title">seqcount</span>;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span> lock;</span><br><span class="line">&#125; <span class="keyword">seqlock_t</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">//动态初始化</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> seqlock_init(x)					\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;						\</span><br><span class="line">		seqcount_init(&amp;(x)-&gt;seqcount);		\</span><br><span class="line">		spin_lock_init(&amp;(x)-&gt;lock);		\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">//静态申明</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SEQLOCK(x) \</span></span><br><span class="line">		<span class="keyword">seqlock_t</span> x = __SEQLOCK_UNLOCKED(x)</span><br><span class="line"></span><br><span class="line"><span class="comment">//操作集</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Read side functions for starting and finalizing a read side section.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> read_seqbegin(<span class="keyword">const</span> <span class="keyword">seqlock_t</span> *sl)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">return</span> read_seqcount_begin(&amp;sl-&gt;seqcount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> <span class="title">read_seqretry</span><span class="params">(<span class="keyword">const</span> <span class="keyword">seqlock_t</span> *sl, <span class="keyword">unsigned</span> start)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> read_seqcount_retry(&amp;sl-&gt;seqcount, start);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock out other writers and update the count.</span></span><br><span class="line"><span class="comment"> * Acts like a normal spin_lock/unlock.</span></span><br><span class="line"><span class="comment"> * Don't need preempt_disable() because that is in the spin_lock already.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_seqlock</span><span class="params">(<span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	spin_lock(&amp;sl-&gt;lock);<span class="comment">//自旋锁上锁，说明write互斥，只能有一个writer进入临界区</span></span><br><span class="line">    <span class="comment">//对计数+1，并且使用smp_wmb保护；</span></span><br><span class="line">	write_seqcount_begin(&amp;sl-&gt;seqcount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_sequnlock</span><span class="params">(<span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	write_seqcount_end(&amp;sl-&gt;seqcount);</span><br><span class="line">	spin_unlock(&amp;sl-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_seqlock_bh</span><span class="params">(<span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	spin_lock_bh(&amp;sl-&gt;lock);</span><br><span class="line">	write_seqcount_begin(&amp;sl-&gt;seqcount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_sequnlock_bh</span><span class="params">(<span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	write_seqcount_end(&amp;sl-&gt;seqcount);</span><br><span class="line">	spin_unlock_bh(&amp;sl-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_seqlock_irq</span><span class="params">(<span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	spin_lock_irq(&amp;sl-&gt;lock);</span><br><span class="line">	write_seqcount_begin(&amp;sl-&gt;seqcount);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span> <span class="title">write_sequnlock_irq</span><span class="params">(<span class="keyword">seqlock_t</span> *sl)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	write_seqcount_end(&amp;sl-&gt;seqcount);</span><br><span class="line">	spin_unlock_irq(&amp;sl-&gt;lock);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从上面的代码可以看到，顺序锁的一些特点；</p>
<p>1、对于writer来说，需要上自旋锁，是互斥的。也就是临界区只允许一个writer进入。</p>
<p>2、对于只有reader进入临界区的情况下，writer不受影响，可以直接进入临界区。</p>
<p>3、对于reader来说，情况就稍微复杂一点，需要配合read_seqbegin和read_seqretry来进行retry。我们先来看看函数read_weqbegin，最终会调用以下函数读取sequence，如果是奇数则代表有writer在临界区中，会反复retry判断知道writer退出临界区后返回sequence，进入临界区。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">unsigned</span> __read_seqcount_begin(<span class="keyword">const</span> <span class="keyword">seqcount_t</span> *s)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> ret;</span><br><span class="line"></span><br><span class="line">repeat:</span><br><span class="line">	ret = READ_ONCE(s-&gt;sequence);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(ret &amp; <span class="number">1</span>)) &#123;</span><br><span class="line">		cpu_relax();</span><br><span class="line">		<span class="keyword">goto</span> repeat;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>然后再退出临界区的时候，需要调用read_seqretry检查这个过程是否有writer进入临界区干扰；也就是对进入临界区时候的sequence和退出时的sequence进行对比，如果相等则直接退出临界区，不相等则继续跳转到进入临界区的read_weqbegin位置，重新开始。看看内核中一个例子：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">handle_path</span><span class="params">(<span class="keyword">const</span> struct dentry *dentry)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_AUDIT_TREE</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_context</span> *<span class="title">context</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_tree_refs</span> *<span class="title">p</span>;</span></span><br><span class="line">	<span class="keyword">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">dentry</span> *<span class="title">d</span>, *<span class="title">parent</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">audit_chunk</span> *<span class="title">drop</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> seq;</span><br><span class="line">	<span class="keyword">int</span> count;</span><br><span class="line"></span><br><span class="line">	context = current-&gt;audit_context;</span><br><span class="line">	p = context-&gt;trees;</span><br><span class="line">	count = context-&gt;tree_count;</span><br><span class="line">retry:</span><br><span class="line">	drop = <span class="literal">NULL</span>;</span><br><span class="line">	d = dentry;</span><br><span class="line">	rcu_read_lock();</span><br><span class="line">	seq = read_seqbegin(&amp;rename_lock);</span><br><span class="line">	<span class="keyword">for</span>(;;) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">inode</span> *<span class="title">inode</span> = <span class="title">d_backing_inode</span>(<span class="title">d</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (inode &amp;&amp; unlikely(!hlist_empty(&amp;inode-&gt;i_fsnotify_marks))) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">audit_chunk</span> *<span class="title">chunk</span>;</span></span><br><span class="line">			chunk = audit_tree_lookup(inode);</span><br><span class="line">			<span class="keyword">if</span> (chunk) &#123;</span><br><span class="line">				<span class="keyword">if</span> (unlikely(!put_tree_ref(context, chunk))) &#123;</span><br><span class="line">					drop = chunk;</span><br><span class="line">					<span class="keyword">break</span>;</span><br><span class="line">				&#125;</span><br><span class="line">			&#125;</span><br><span class="line">		&#125;</span><br><span class="line">		parent = d-&gt;d_parent;</span><br><span class="line">		<span class="keyword">if</span> (parent == d)</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line">		d = parent;</span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">if</span> (unlikely(read_seqretry(&amp;rename_lock, seq) || drop)) &#123;  <span class="comment">/* in this order */</span></span><br><span class="line">		rcu_read_unlock();</span><br><span class="line">		<span class="keyword">if</span> (!drop) &#123;</span><br><span class="line">			<span class="comment">/* just a race with rename */</span></span><br><span class="line">			unroll_tree_refs(context, p, count);</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		&#125;</span><br><span class="line">		audit_put_chunk(drop);</span><br><span class="line">		<span class="keyword">if</span> (grow_tree_refs(context)) &#123;</span><br><span class="line">			<span class="comment">/* OK, got more space */</span></span><br><span class="line">			unroll_tree_refs(context, p, count);</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* too bad */</span></span><br><span class="line">		pr_warn(<span class="string">"out of memory, audit has lost a tree reference\n"</span>);</span><br><span class="line">		unroll_tree_refs(context, p, count);</span><br><span class="line">		audit_set_auditable(context);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line">	rcu_read_unlock();</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="信号量"><a href="#信号量" class="headerlink" title="信号量"></a>信号量</h4><p>信号量都属于休眠锁，不可用在中断上下文中。</p>
<h5 id="普通信号量"><a href="#普通信号量" class="headerlink" title="普通信号量"></a>普通信号量</h5><p>定义如下，自旋锁 + 计数器 + 等待队列</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Please don't access any members of this structure directly */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> &#123;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span>		lock;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>申明方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//name是信号量的变量名字，计数默认为1</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> DEFINE_SEMAPHORE(name)	\</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore</span> <span class="title">name</span> = __<span class="title">SEMAPHORE_INITIALIZER</span>(<span class="title">name</span>, 1)</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">//自己申明，动态初始化，可以指定默认计数值</span></span><br><span class="line"><span class="class"><span class="title">static</span> <span class="title">inline</span> <span class="title">void</span> <span class="title">sema_init</span>(<span class="title">struct</span> <span class="title">semaphore</span> *<span class="title">sem</span>, <span class="title">int</span> <span class="title">val</span>)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span></span><br><span class="line">	*sem = (struct semaphore) __SEMAPHORE_INITIALIZER(*sem, val);</span><br><span class="line">	lockdep_init_map(&amp;sem-&gt;lock.dep_map, <span class="string">"semaphore-&gt;lock"</span>, &amp;__key, <span class="number">0</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PV操作中的P操作，down函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">down</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">    <span class="comment">//整个过程由自旋锁保护</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (likely(sem-&gt;count &gt; <span class="number">0</span>))<span class="comment">//计数器大于0，直接减一，获取成功</span></span><br><span class="line">		sem-&gt;count--;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__down(sem);<span class="comment">//否则</span></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//__down最终调用__down_common</span></span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __down(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//当前进程会进入D状态，但是有超时唤醒时间</span></span><br><span class="line">	__down_common(sem, TASK_UNINTERRUPTIBLE, MAX_SCHEDULE_TIMEOUT);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Because this function is inlined, the 'state' parameter will be</span></span><br><span class="line"><span class="comment"> * constant, and thus optimised away by the compiler.  Likewise the</span></span><br><span class="line"><span class="comment"> * 'timeout' parameter for the cases without timeouts.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">int</span> __sched __down_common(struct semaphore *sem, <span class="keyword">long</span> state,</span><br><span class="line">								<span class="keyword">long</span> timeout)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//加入等待队列</span></span><br><span class="line">	list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;sem-&gt;wait_list);</span><br><span class="line">	waiter.task = task;</span><br><span class="line">	waiter.up = <span class="literal">false</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;<span class="comment">//循环等待</span></span><br><span class="line">		<span class="keyword">if</span> (signal_pending_state(state, task))<span class="comment">//如果当前进程有挂起的信号未处理，直接返回</span></span><br><span class="line">			<span class="keyword">goto</span> interrupted;</span><br><span class="line">		<span class="keyword">if</span> (unlikely(timeout &lt;= <span class="number">0</span>))<span class="comment">//超时时间小于0，直接返回</span></span><br><span class="line">			<span class="keyword">goto</span> timed_out;</span><br><span class="line">		__set_task_state(task, state);<span class="comment">//设置进程状态为state，也就是TASK_UNINTERRUPTIBLE</span></span><br><span class="line">		raw_spin_unlock_irq(&amp;sem-&gt;lock);<span class="comment">//因为进程进入D状态后，先释放自旋锁</span></span><br><span class="line">		timeout = schedule_timeout(timeout);<span class="comment">//发起调度，并设置进程下次唤醒延迟时间</span></span><br><span class="line">		raw_spin_lock_irq(&amp;sem-&gt;lock);<span class="comment">//进程到这里已经被重新唤醒，需要重新持有自旋锁</span></span><br><span class="line">		<span class="keyword">if</span> (waiter.up)<span class="comment">//判断是否是因为V操作唤醒而不是超时唤醒</span></span><br><span class="line">			<span class="keyword">return</span> <span class="number">0</span>;<span class="comment">//因为V操作唤醒，返回成功</span></span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line"> timed_out:</span><br><span class="line">	list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> -ETIME;</span><br><span class="line"></span><br><span class="line"> interrupted:</span><br><span class="line">	list_del(&amp;waiter.<span class="built_in">list</span>);</span><br><span class="line">	<span class="keyword">return</span> -EINTR;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>PV操作中的V操作，up函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * up - release the semaphore</span></span><br><span class="line"><span class="comment"> * @sem: the semaphore to release</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Release the semaphore.  Unlike mutexes, up() may be called from any</span></span><br><span class="line"><span class="comment"> * context and even by tasks which have never called down().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">void</span> <span class="title">up</span><span class="params">(struct semaphore *sem)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//整个过程由自旋锁保护</span></span><br><span class="line">	raw_spin_lock_irqsave(&amp;sem-&gt;lock, flags);</span><br><span class="line">	<span class="keyword">if</span> (likely(list_empty(&amp;sem-&gt;wait_list)))<span class="comment">//如果等待队列为空，直接计数+1</span></span><br><span class="line">		sem-&gt;count++;</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		__up(sem);<span class="comment">//有等待者</span></span><br><span class="line">	raw_spin_unlock_irqrestore(&amp;sem-&gt;lock, flags);</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">static</span> noinline <span class="keyword">void</span> __sched __up(struct semaphore *sem)</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//唤醒第一个等待者</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">semaphore_waiter</span> *<span class="title">waiter</span> = <span class="title">list_first_entry</span>(&amp;<span class="title">sem</span>-&gt;<span class="title">wait_list</span>,</span></span><br><span class="line"><span class="class">						<span class="title">struct</span> <span class="title">semaphore_waiter</span>, <span class="title">list</span>);</span></span><br><span class="line">	list_del(&amp;waiter-&gt;<span class="built_in">list</span>);</span><br><span class="line">	waiter-&gt;up = <span class="literal">true</span>;</span><br><span class="line">	wake_up_process(waiter-&gt;task);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>可以看出，信号量允许指定数量的访问者进入临界区，超过指定数量时，访问者需要休眠等待。</p>
<h5 id="读写信号量"><a href="#读写信号量" class="headerlink" title="读写信号量"></a>读写信号量</h5><p>先看看rwsem.h中的定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// https://blog.csdn.net/coldsnow33/article/details/17924531</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RWSEM_GENERIC_SPINLOCK <span class="comment">//关注通用实现</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;linux/rwsem-spinlock.h&gt; /* use a generic implementation */</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __RWSEM_INIT_COUNT(name)	.count = RWSEM_UNLOCKED_VALUE</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="comment">/* All arch specific implementations share the same struct */</span></span><br><span class="line"><span class="comment">//特定cpu架构实现的通用抽象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">rw_semaphore</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> count;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">wait_list</span>;</span></span><br><span class="line">	<span class="keyword">raw_spinlock_t</span> wait_lock;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_RWSEM_SPIN_ON_OWNER</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* spinner MCS lock */</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Write owner. Used as a speculative check to see</span></span><br><span class="line"><span class="comment">	 * if the owner is running on the cpu.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>读写信号量实现相对复杂，阅读起来有点费劲。就不一一分析代码。直接摘抄总结：</p>
<p>1、读写信号量通常用于读多写少的场景</p>
<p>2、允许不受限制数量的reader持有</p>
<p>3、读写互斥</p>
<p>4、写写互斥</p>
<h5 id="互斥信号量"><a href="#互斥信号量" class="headerlink" title="互斥信号量"></a>互斥信号量</h5><p>互斥信号量也就是互斥锁。定义在kernel/include/linux/mutex.h中。可以说是一种二元的信号量，依赖于原子操作。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//定义</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Simple, straightforward mutexes with strict semantics:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - only one task can hold the mutex at a time</span></span><br><span class="line"><span class="comment"> * - only the owner can unlock the mutex</span></span><br><span class="line"><span class="comment"> * - multiple unlocks are not permitted</span></span><br><span class="line"><span class="comment"> * - recursive locking is not permitted</span></span><br><span class="line"><span class="comment"> * - a mutex object must be initialized via the API</span></span><br><span class="line"><span class="comment"> * - a mutex object must not be initialized via memset or copying</span></span><br><span class="line"><span class="comment"> * - task may not exit with mutex held</span></span><br><span class="line"><span class="comment"> * - memory areas where held locks reside must not be freed</span></span><br><span class="line"><span class="comment"> * - held mutexes must not be reinitialized</span></span><br><span class="line"><span class="comment"> * - mutexes may not be used in hardware or software interrupt</span></span><br><span class="line"><span class="comment"> *   contexts such as tasklets and timers</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * These semantics are fully enforced when DEBUG_MUTEXES is</span></span><br><span class="line"><span class="comment"> * enabled. Furthermore, besides enforcing the above rules, the mutex</span></span><br><span class="line"><span class="comment"> * debugging code also implements a number of additional features</span></span><br><span class="line"><span class="comment"> * that make lock debugging easier and faster:</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * - uses symbolic names of mutexes, whenever they are printed in debug output</span></span><br><span class="line"><span class="comment"> * - point-of-acquire tracking, symbolic lookup of function names</span></span><br><span class="line"><span class="comment"> * - list of all locks held in the system, printout of them</span></span><br><span class="line"><span class="comment"> * - owner tracking</span></span><br><span class="line"><span class="comment"> * - detects self-recursing locks and prints out all relevant info</span></span><br><span class="line"><span class="comment"> * - detects multi-task circular deadlocks and prints out all affected</span></span><br><span class="line"><span class="comment"> *   locks and tasks (and only those tasks)</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> &#123;</span></span><br><span class="line">	<span class="comment">/* 1: unlocked, 0: locked, negative: locked, possible waiters */</span></span><br><span class="line">    <span class="comment">//1代表不上锁、0代表上锁、负数代表上锁并且有等待者</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		count;</span><br><span class="line">	<span class="keyword">spinlock_t</span>		wait_lock;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">wait_list</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">if</span> defined(CONFIG_DEBUG_MUTEXES) || defined(CONFIG_MUTEX_SPIN_ON_OWNER)</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">owner</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">optimistic_spin_queue</span> <span class="title">osq</span>;</span> <span class="comment">/* Spinner MCS lock */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_MUTEXES</span></span><br><span class="line">	<span class="keyword">void</span>			*magic;</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_DEBUG_LOCK_ALLOC</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">dep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//初始化操作</span></span><br><span class="line"><span class="meta"># <span class="meta-keyword">define</span> mutex_init(mutex) \</span></span><br><span class="line"><span class="keyword">do</span> &#123;							\</span><br><span class="line">	<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span>		\</span><br><span class="line">							\</span><br><span class="line">	__mutex_init((mutex), #mutex, &amp;__key);		\</span><br><span class="line">&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">void</span> __mutex_init(struct mutex *lock, <span class="keyword">const</span> <span class="keyword">char</span> *name, struct lock_class_key *key)</span><br><span class="line">&#123;</span><br><span class="line">	atomic_set(&amp;lock-&gt;count, <span class="number">1</span>);<span class="comment">//计数为1</span></span><br><span class="line">	spin_lock_init(&amp;lock-&gt;wait_lock);<span class="comment">//等待队列自旋锁初始化</span></span><br><span class="line">	INIT_LIST_HEAD(&amp;lock-&gt;wait_list);<span class="comment">//初始化等待对垒</span></span><br><span class="line">	mutex_clear_owner(lock); <span class="comment">//清空owner</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_MUTEX_SPIN_ON_OWNER</span></span><br><span class="line">	osq_lock_init(&amp;lock-&gt;osq);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line">	debug_mutex_init(lock, name, key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>P操作，mutex_lock函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * mutex_lock - acquire the mutex</span></span><br><span class="line"><span class="comment"> * @lock: the mutex to be acquired</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Lock the mutex exclusively for this task. If the mutex is not</span></span><br><span class="line"><span class="comment"> * available right now, it will sleep until it can get it.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The mutex must later on be released by the same task that</span></span><br><span class="line"><span class="comment"> * acquired it. Recursive locking is not allowed. The task</span></span><br><span class="line"><span class="comment"> * may not exit without first unlocking the mutex. Also, kernel</span></span><br><span class="line"><span class="comment"> * memory where the mutex resides must not be freed with</span></span><br><span class="line"><span class="comment"> * the mutex still locked. The mutex must first be initialized</span></span><br><span class="line"><span class="comment"> * (or statically defined) before it can be locked. memset()-ing</span></span><br><span class="line"><span class="comment"> * the mutex to 0 is not allowed.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * ( The CONFIG_DEBUG_MUTEXES .config option turns on debugging</span></span><br><span class="line"><span class="comment"> *   checks that will enforce the restrictions and will also do</span></span><br><span class="line"><span class="comment"> *   deadlock debugging. )</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * This function is similar to (but not equivalent to) down().</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">void</span> __<span class="function">sched <span class="title">mutex_lock</span><span class="params">(struct mutex *lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	might_sleep();</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The locking fastpath is the 1-&gt;0 transition from</span></span><br><span class="line"><span class="comment">	 * 'unlocked' into 'locked' state.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	__mutex_fastpath_lock(&amp;lock-&gt;count, __mutex_lock_slowpath);</span><br><span class="line">	mutex_set_owner(lock);<span class="comment">//锁获取成功，设置持有者为当前进程</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//mutex-dec.h</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> *  __mutex_fastpath_lock - try to take the lock by moving the count</span></span><br><span class="line"><span class="comment"> *                          from 1 to a 0 value</span></span><br><span class="line"><span class="comment"> *  @count: pointer of type atomic_t</span></span><br><span class="line"><span class="comment"> *  @fail_fn: function to call if the original value was not 1</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Change the count from 1 to a value lower than 1, and call &lt;fail_fn&gt; if</span></span><br><span class="line"><span class="comment"> * it wasn't 1 originally. This function MUST leave the value lower than</span></span><br><span class="line"><span class="comment"> * 1 even when the "1" assertion wasn't true.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">void</span></span><br><span class="line">__mutex_fastpath_lock(<span class="keyword">atomic_t</span> *count, <span class="keyword">void</span> (*fail_fn)(<span class="keyword">atomic_t</span> *))</span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">//减一操作后count小于0，说明已经被持有；调用上锁失败的回调函数，即__mutex_lock_slowpath函数</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(atomic_dec_return_acquire(count) &lt; <span class="number">0</span>))</span><br><span class="line">		fail_fn(count);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//__mutex_lock_slowpath函数核心实现调用__mutex_lock_common</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Lock a mutex (possibly interruptible), slowpath:</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> __always_inline <span class="keyword">int</span> __sched</span><br><span class="line">__mutex_lock_common(struct mutex *lock, <span class="keyword">long</span> state, <span class="keyword">unsigned</span> <span class="keyword">int</span> subclass,</span><br><span class="line">		    struct lockdep_map *nest_lock, <span class="keyword">unsigned</span> <span class="keyword">long</span> ip,</span><br><span class="line">		    struct ww_acquire_ctx *ww_ctx, <span class="keyword">const</span> <span class="keyword">bool</span> use_ww_ctx)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> *<span class="title">task</span> = <span class="title">current</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex_waiter</span> <span class="title">waiter</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line">	<span class="keyword">int</span> ret;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (use_ww_ctx) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span> = <span class="title">container_of</span>(<span class="title">lock</span>, <span class="title">struct</span> <span class="title">ww_mutex</span>, <span class="title">base</span>);</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(ww_ctx == READ_ONCE(ww-&gt;ctx)))</span><br><span class="line">			<span class="keyword">return</span> -EALREADY;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	preempt_disable();<span class="comment">//</span></span><br><span class="line">	mutex_acquire_nest(&amp;lock-&gt;dep_map, subclass, <span class="number">0</span>, nest_lock, ip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (mutex_optimistic_spin(lock, ww_ctx, use_ww_ctx)) &#123;</span><br><span class="line">		<span class="comment">/* got the lock, yay! */</span></span><br><span class="line">		preempt_enable();</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Once more, try to acquire the lock. Only try-lock the mutex if</span></span><br><span class="line"><span class="comment">	 * it is unlocked to reduce unnecessary xchg() operations.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">if</span> (!mutex_is_locked(lock) &amp;&amp;</span><br><span class="line">	    (atomic_xchg_acquire(&amp;lock-&gt;count, <span class="number">0</span>) == <span class="number">1</span>))</span><br><span class="line">		<span class="keyword">goto</span> skip_wait;</span><br><span class="line"></span><br><span class="line">	debug_mutex_lock_common(lock, &amp;waiter);</span><br><span class="line">	debug_mutex_add_waiter(lock, &amp;waiter, task);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* add waiting tasks to the end of the waitqueue (FIFO): */</span></span><br><span class="line">    <span class="comment">//将自己添加到等待队列尾</span></span><br><span class="line">	list_add_tail(&amp;waiter.<span class="built_in">list</span>, &amp;lock-&gt;wait_list);</span><br><span class="line">	waiter.task = task;</span><br><span class="line"></span><br><span class="line">	lock_contended(&amp;lock-&gt;dep_map, ip);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">for</span> (;;) &#123;<span class="comment">//开始循环等待唤醒</span></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * Lets try to take the lock again - this is needed even if</span></span><br><span class="line"><span class="comment">		 * we get here for the first time (shortly after failing to</span></span><br><span class="line"><span class="comment">		 * acquire the lock), to make sure that we get a wakeup once</span></span><br><span class="line"><span class="comment">		 * it's unlocked. Later on, if we sleep, this is the</span></span><br><span class="line"><span class="comment">		 * operation that gives us the lock. We xchg it to -1, so</span></span><br><span class="line"><span class="comment">		 * that when we release the lock, we properly wake up the</span></span><br><span class="line"><span class="comment">		 * other waiters. We only attempt the xchg if the count is</span></span><br><span class="line"><span class="comment">		 * non-negative in order to avoid unnecessary xchg operations:</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">//如果计数已经不为负数，尝试重新上锁</span></span><br><span class="line">		<span class="keyword">if</span> (atomic_read(&amp;lock-&gt;count) &gt;= <span class="number">0</span> &amp;&amp;</span><br><span class="line">		    (atomic_xchg_acquire(&amp;lock-&gt;count, <span class="number">-1</span>) == <span class="number">1</span>))</span><br><span class="line">			<span class="keyword">break</span>;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * got a signal? (This code gets eliminated in the</span></span><br><span class="line"><span class="comment">		 * TASK_UNINTERRUPTIBLE case.)</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">        <span class="comment">//如果有挂起的信号阻止进程进入指定状态，我们分析的这个api对应的TASK_UNINTERRUPTIBLE</span></span><br><span class="line">		<span class="keyword">if</span> (unlikely(signal_pending_state(state, task))) &#123;</span><br><span class="line">			ret = -EINTR;</span><br><span class="line">			<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (use_ww_ctx &amp;&amp; ww_ctx-&gt;acquired &gt; <span class="number">0</span>) &#123;</span><br><span class="line">			ret = __ww_mutex_lock_check_stamp(lock, ww_ctx);</span><br><span class="line">			<span class="keyword">if</span> (ret)</span><br><span class="line">				<span class="keyword">goto</span> err;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		__set_task_state(task, state);<span class="comment">//进程进入指定的状态</span></span><br><span class="line"></span><br><span class="line">		<span class="comment">/* didn't get the lock, go to sleep: */</span></span><br><span class="line">		spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);<span class="comment">//释放自旋锁</span></span><br><span class="line">		schedule_preempt_disabled();<span class="comment">//发起调度</span></span><br><span class="line">		spin_lock_mutex(&amp;lock-&gt;wait_lock, flags);<span class="comment">//得到执行，重新获得自旋锁</span></span><br><span class="line">	&#125;</span><br><span class="line">	__set_task_state(task, TASK_RUNNING);<span class="comment">//设置进程为runing状态</span></span><br><span class="line"></span><br><span class="line">	mutex_remove_waiter(lock, &amp;waiter, task);<span class="comment">//将自己从等待队列中移除</span></span><br><span class="line">	<span class="comment">/* set it to 0 if there are no waiters left: */</span></span><br><span class="line">    <span class="comment">//如果当自己被唤醒的时候，等待队列为空，者count置为0；持有者是自己</span></span><br><span class="line">	<span class="keyword">if</span> (likely(list_empty(&amp;lock-&gt;wait_list)))</span><br><span class="line">		atomic_set(&amp;lock-&gt;count, <span class="number">0</span>);</span><br><span class="line">	debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line"></span><br><span class="line">skip_wait:</span><br><span class="line">	<span class="comment">/* got the lock - cleanup and rejoice! */</span></span><br><span class="line">	lock_acquired(&amp;lock-&gt;dep_map, ip);</span><br><span class="line">	mutex_set_owner(lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (use_ww_ctx) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">ww_mutex</span> *<span class="title">ww</span> = <span class="title">container_of</span>(<span class="title">lock</span>, <span class="title">struct</span> <span class="title">ww_mutex</span>, <span class="title">base</span>);</span></span><br><span class="line">		ww_mutex_set_context_slowpath(ww, ww_ctx);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">	preempt_enable();</span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">err:</span><br><span class="line">	mutex_remove_waiter(lock, &amp;waiter, task);</span><br><span class="line">	spin_unlock_mutex(&amp;lock-&gt;wait_lock, flags);</span><br><span class="line">	debug_mutex_free_waiter(&amp;waiter);</span><br><span class="line">	mutex_release(&amp;lock-&gt;dep_map, <span class="number">1</span>, ip);</span><br><span class="line">	preempt_enable();</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="完成量"><a href="#完成量" class="headerlink" title="完成量"></a>完成量</h4><p>完成量的定义如下，done为0代表未完成。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span> &#123;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> done;</span><br><span class="line">	<span class="keyword">wait_queue_head_t</span> wait;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>使用方法：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//申明完成量</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	<span class="title">done</span>;</span></span><br><span class="line"><span class="comment">//初始化完成量，done成员变量置为0，初始化等待队列</span></span><br><span class="line">init_completion(&amp;done);</span><br><span class="line"><span class="comment">//重新初始化，重置done成员变量为0</span></span><br><span class="line">reinit_completion（&amp;done）</span><br><span class="line"><span class="comment">//等待完成，调用者会被挂起到完成量的等待队列中</span></span><br><span class="line">wait_for_completion(&amp;done);</span><br><span class="line"><span class="comment">//完成，唤醒等待队列上的进程</span></span><br><span class="line">complete(&amp;barrdone);</span><br></pre></td></tr></table></figure>

<p>完成量使用方法也比较简单，值得注意的是调用wait_for_completion的进程挂起到等待队列上时，其进程状态是D状态，也就是TASK_UNINTERRUPTIBLE状态。</p>
<h4 id="RCU"><a href="#RCU" class="headerlink" title="RCU"></a>RCU</h4><p>RCU（Read-Copy Update）的意思是读-复制更新，RCU某种程度上来说是一种可以替代读写自旋锁（rwlock）的更好的方案。根据前面的学习可以知道读写锁只有读是共享的，但是读写是互斥的，某种程度上提高了读的效率。而RUC则直接保证了reader百分百畅通无阻的进入临界区，不受writer影响，最大程度的提升了reader的性能。</p>
<p>RCU的优点是reader没有任何同步开销，不需要获取任何锁，不需要执行原子指令，不需要执行内存屏障；但是写者的同步开销比较大，写者需要延迟对象的释放，复制被修改的对象，写者之间必须使用锁互斥。通常适用于如下场景：</p>
<p>1、RCU只能保护动态分配的数据结构，并且必须是通过指针访问该数据结构</p>
<p>2、读写不对称，对writer的性能没有特别要求，但是reader性能要求极高。</p>
<p>3、reader端对新旧数据不敏感。</p>
<p>writer修改对象的过程：首先复制生成一个副本，然后更新这个副本，最后使用新的对象替换旧的对象。在写者执行复制更新的时候读者可以读数据。</p>
<p>writer删除对象的过程：必须等到所有访问被删除对象的读者访问结束，才能执行销毁操作。RCU的关键技术是怎么判断所有读者已经完成访问。等待所有读者访问结束的时间称为宽限期（grace period）。</p>
<p>writer和writer在临界区更新修改数据时需要额外加锁互斥。</p>
<p>RCU的实现比较复杂，相关的使用方法和分析参考：</p>
<p><a href="https://blog.csdn.net/juS3Ve/article/details/80248811" target="_blank" rel="noopener">https://blog.csdn.net/juS3Ve/article/details/80248811</a></p>
<p><a href="https://blog.csdn.net/xueli1991/article/details/51741763" target="_blank" rel="noopener">https://blog.csdn.net/xueli1991/article/details/51741763</a></p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>对于spin lock和mutex这两种是全互斥机制，同一时间只允许一个访问者（不管是reader还是writer）进入临界区。</p>
<p>对于rw spin lock则是reader可以共享临界区，同时允许多个reader进入临界区，reader和writer、writer和writer互斥；给reader更多的机会，在读多写少的场景中可以提高一些性能。</p>
<p>对于seqlock来说，writer之间是绝对互斥的；只有reader进入临界区的情况下，writer不受影响，可以直接进入临界区，给了writer更多的机会；由于writer不受reader影响可以直接进入临界区修改内容，所以reader需要判断在read处理过程中是否受到writer干扰来决定是否退出临界区。在读少写多的的场景下也可以提高一些性能。</p>
<p>RCU用在读多写少、reader对新旧数据不敏感的场景中比较好，因为写者有个写入的宽限期，writer的更新不会很及时，reader则不需要考虑同步问题。</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/26/Linux-kernel-sync/" data-id="cjy7ayu70001reoiigito066u" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/13/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/12/">12</a><a class="page-number" href="/page/13/">13</a><span class="page-number current">14</span><a class="page-number" href="/page/15/">15</a><a class="page-number" href="/page/16/">16</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/15/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AIDL/">AIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HIDL/">HIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/driver/">driver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实战/">实战</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稳定性/">稳定性</a><span class="tag-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AIDL/" style="font-size: 10px;">AIDL</a> <a href="/tags/Android/" style="font-size: 16px;">Android</a> <a href="/tags/HIDL/" style="font-size: 10px;">HIDL</a> <a href="/tags/Linux/" style="font-size: 18px;">Linux</a> <a href="/tags/driver/" style="font-size: 10px;">driver</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/实战/" style="font-size: 12px;">实战</a> <a href="/tags/稳定性/" style="font-size: 14px;">稳定性</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/05/native-acess-javaservice-with-binder/">Android平台上native代码访问PackageManagerService</a>
          </li>
        
          <li>
            <a href="/2019/07/01/gdb_coredump_using/">Android平台上使用coredump+gdb</a>
          </li>
        
          <li>
            <a href="/2019/06/25/Android-Init-FBE/">Android启动流程-FBE部分</a>
          </li>
        
          <li>
            <a href="/2019/06/15/Linux-system-ipc/">Linux进程间通信机制</a>
          </li>
        
          <li>
            <a href="/2019/06/01/Android-hidl-sample-impletment/">Android9.0 HIDL 学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 JoyYoung<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>