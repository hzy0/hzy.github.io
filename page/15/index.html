<!DOCTYPE html>
<html>
<head><meta name="generator" content="Hexo 3.8.0">
  <meta charset="utf-8">
  

  
  <title>JoyYoung&#39;s blog</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta property="og:type" content="website">
<meta property="og:title" content="JoyYoung&#39;s blog">
<meta property="og:url" content="http://yoursite.com/page/15/index.html">
<meta property="og:site_name" content="JoyYoung&#39;s blog">
<meta property="og:locale" content="default">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="JoyYoung&#39;s blog">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
</head>
</html>
<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo">JoyYoung&#39;s blog</a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archives</a>
        
      </nav>
      <nav id="sub-nav">
        
        <a id="nav-search-btn" class="nav-icon" title="Search"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://yoursite.com"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main">
  
    <article id="post-Linux-irq-bh-workqueue" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2019/04/20/Linux-irq-bh-workqueue/" class="article-date">
  <time datetime="2019-04-20T15:47:44.000Z" itemprop="datePublished">2019-04-20</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 itemprop="name">
      <a class="article-title" href="/2019/04/20/Linux-irq-bh-workqueue/">Linux中断下半部之workqueue</a>
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <h2 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h2><p>工作队列（workqueue）通常也是用来实现bottom half的一种方式；内核子系统或者驱动可以通过工作队列将deferable task交给kworker线程去调度执行；和tasklet或者timer基于软中断的实现不同，workqueue完全运行在进程上下文中，允许被重新调度和睡眠。</p>
<h2 id="CMWQ"><a href="#CMWQ" class="headerlink" title="CMWQ"></a>CMWQ</h2><p>Concurrency Managed Workqueue，并发管理工作队列。cmwq 在实现上没有专有的线程与每个工作队列关联，事实上，现在变成了 Online CPU number个线程池来为工作队列服务，这样将线程的管理权实际上从工作队列的使用者交还给了内核。当一个工作项被创建以及排队，将在合适的时机被传递给其中一个线程；cmwq 最有意思的是：被提交到相同工作队列，相同 CPU 的工作任务可能并发执行，这也是命名为并发可管理工作队列的原因。</p>
<h2 id="基础"><a href="#基础" class="headerlink" title="基础"></a>基础</h2><p>这部分主要包含5部分主体对象：工作任务、工作队列、工作者线程、工作者线程池和PWQ。工作任务被挂在工作队列中；PWQ建立工作队列和线程池的联系把工作任务传递给某个线程池；工作线程通过遍历执行自己所在的线程池上所有的工作任务，工作者线程池则是根据工作任务负载情况动态工作者线程的数量是的工作任务可以被并发处理。</p>
<h4 id="工作任务"><a href="#工作任务" class="headerlink" title="工作任务"></a>工作任务</h4><p>一个工作任务对应一个work_struct或者delayed_work结构体，代表一项任务；其实工作任务都是延迟调度的：默认情况调度一个工作任务，延迟要看工作者线程什么时候被调度执行；也可以使用特定的延迟工作任务，指定多久后调度一个工作任务，然后才看工作者线程调度执行，延迟工作队列内部实现依赖于定时器。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//普通的工作任务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> &#123;</span></span><br><span class="line">	<span class="keyword">atomic_long_t</span> data; <span class="comment">//保存工作任务的信息，比如work任务的状态等</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">entry</span>;</span><span class="comment">//插入到工作队列链表需要的</span></span><br><span class="line">	<span class="keyword">work_func_t</span> func; <span class="comment">//工作任务对应的回调函数，work_func_t是一个函数指针，接收work_struct为参数</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//延迟调度的工作任务</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">delayed_work</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> <span class="title">work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span> <span class="title">timer</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* target workqueue and CPU -&gt;timer uses to queue -&gt;work */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="keyword">int</span> cpu;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建工作任务项通常有静态创建和动态创建两种方式：</p>
<p>1、以下是静态创建工作队列的方法，通常我们都是使用最外层的DECLARE_WORK、DECLARE_DELAYED_WORK或者DECLARE_DEFERRABLE_WORK，该系列宏动态初始化一个以 name 命名的工作项，并设置了回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * NB: because we have to copy the lockdep_map, setting _key</span></span><br><span class="line"><span class="comment"> * here is required, otherwise it could get initialised to the</span></span><br><span class="line"><span class="comment"> * copy of the lockdep_map!</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __WORK_INIT_LOCKDEP_MAP(n, k) \</span></span><br><span class="line">	.lockdep_map = STATIC_LOCKDEP_MAP_INIT(n, k),</span><br><span class="line">#<span class="keyword">else</span></span><br><span class="line">#define __WORK_INIT_LOCKDEP_MAP(n, k)</span><br><span class="line">#endif</span><br><span class="line"></span><br><span class="line">#define __WORK_INITIALIZER(n, f) &#123;					\</span><br><span class="line">	.data = WORK_DATA_STATIC_INIT(),				\</span><br><span class="line">	.entry	= &#123; &amp;(n).entry, &amp;(n).entry &#125;,				\</span><br><span class="line">	.func = (f),							\</span><br><span class="line">	__WORK_INIT_LOCKDEP_MAP(#n, &amp;(n))				\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#define __DELAYED_WORK_INITIALIZER(n, f, tflags) &#123;			\</span><br><span class="line">	.work = __WORK_INITIALIZER((n).work, (f)),			\</span><br><span class="line">	.timer = __TIMER_INITIALIZER(delayed_work_timer_fn,		\</span><br><span class="line">				     <span class="number">0</span>, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)&amp;(n),		\</span><br><span class="line">				     (tflags) | TIMER_IRQSAFE),		\</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">#define DECLARE_WORK(n, f)						\</span><br><span class="line">	struct work_struct n = __WORK_INITIALIZER(n, f)</span><br><span class="line"></span><br><span class="line">#define DECLARE_DELAYED_WORK(n, f)					\</span><br><span class="line">	struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line">#define DECLARE_DEFERRABLE_WORK(n, f)					\</span><br><span class="line">	struct delayed_work n = __DELAYED_WORK_INITIALIZER(n, f, TIMER_DEFERRABLE)</span><br></pre></td></tr></table></figure>

<p>2、以下是动态创建工作队列的方法，一般都是用INIT_WORK和INIT_DELAYED_WORK，该系列宏静态创建一个以 name 命名的工作项，并设置了回调函数。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * initialize all of a work item in one go</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * NOTE! No point in using "atomic_long_set()": using a direct</span></span><br><span class="line"><span class="comment"> * assignment of the work data initializer allows the compiler</span></span><br><span class="line"><span class="comment"> * to generate better code.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INIT_WORK(_work, _func, _onstack)				\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		<span class="keyword">static</span> <span class="class"><span class="keyword">struct</span> <span class="title">lock_class_key</span> __<span class="title">key</span>;</span>			\</span><br><span class="line">									\</span><br><span class="line">		__init_work((_work), _onstack);				\</span><br><span class="line">		(_work)-&gt;data = (<span class="keyword">atomic_long_t</span>) WORK_DATA_INIT();	\</span><br><span class="line">		lockdep_init_map(&amp;(_work)-&gt;lockdep_map, #_work, &amp;__key, <span class="number">0</span>); \</span><br><span class="line">		INIT_LIST_HEAD(&amp;(_work)-&gt;entry);			\</span><br><span class="line">		(_work)-&gt;func = (_func);				\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INIT_WORK(_work, _func, _onstack)				\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		__init_work((_work), _onstack);				\</span><br><span class="line">		(_work)-&gt;data = (<span class="keyword">atomic_long_t</span>) WORK_DATA_INIT();	\</span><br><span class="line">		INIT_LIST_HEAD(&amp;(_work)-&gt;entry);			\</span><br><span class="line">		(_work)-&gt;func = (_func);				\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_WORK(_work, _func)						\</span></span><br><span class="line">	__INIT_WORK((_work), (_func), <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_WORK_ONSTACK(_work, _func)					\</span></span><br><span class="line">	__INIT_WORK((_work), (_func), <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INIT_DELAYED_WORK(_work, _func, _tflags)			\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		INIT_WORK(&amp;(_work)-&gt;work, (_func));			\</span><br><span class="line">		__setup_timer(&amp;(_work)-&gt;timer, delayed_work_timer_fn,	\</span><br><span class="line">			      (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(_work),			\</span><br><span class="line">			      (_tflags) | TIMER_IRQSAFE);		\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> __INIT_DELAYED_WORK_ONSTACK(_work, _func, _tflags)		\</span></span><br><span class="line">	<span class="keyword">do</span> &#123;								\</span><br><span class="line">		INIT_WORK_ONSTACK(&amp;(_work)-&gt;work, (_func));		\</span><br><span class="line">		__setup_timer_on_stack(&amp;(_work)-&gt;timer,			\</span><br><span class="line">				       delayed_work_timer_fn,		\</span><br><span class="line">				       (<span class="keyword">unsigned</span> <span class="keyword">long</span>)(_work),		\</span><br><span class="line">				       (_tflags) | TIMER_IRQSAFE);	\</span><br><span class="line">	&#125; <span class="keyword">while</span> (<span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_DELAYED_WORK(_work, _func)					\</span></span><br><span class="line">	__INIT_DELAYED_WORK(_work, _func, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_DELAYED_WORK_ONSTACK(_work, _func)				\</span></span><br><span class="line">	__INIT_DELAYED_WORK_ONSTACK(_work, _func, <span class="number">0</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_DEFERRABLE_WORK(_work, _func)				\</span></span><br><span class="line">	__INIT_DELAYED_WORK(_work, _func, TIMER_DEFERRABLE)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> INIT_DEFERRABLE_WORK_ONSTACK(_work, _func)			\</span></span><br><span class="line">	__INIT_DELAYED_WORK_ONSTACK(_work, _func, TIMER_DEFERRABLE)</span><br></pre></td></tr></table></figure>

<h4 id="工作队列"><a href="#工作队列" class="headerlink" title="工作队列"></a>工作队列</h4><p>工作队列对应的结构体是workqueue_struct，所有的工作任务都会被挂在工作队列中。系统默认会创建一些共享的工作队列，内核也提供了相关的结构给开发者创建自己的工作队列。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The externally visible workqueue.  It relays the issued work items to</span></span><br><span class="line"><span class="comment"> * the appropriate worker_pool through its pool_workqueues.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs</span>;</span>		<span class="comment">/* WR: 工作队列可以拥有多个pwq，pwq通过pwqs_node挂在这个列表中 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">list</span>;</span>		<span class="comment">/* PR: 所有的工作队列形成链表 */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">mutex</span>;</span>		<span class="comment">/* 工作队列的互斥锁 */</span></span><br><span class="line">	<span class="keyword">int</span>			work_color;	<span class="comment">/* WQ: current work color */</span></span><br><span class="line">	<span class="keyword">int</span>			flush_color;	<span class="comment">/* WQ: current flush color */</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		nr_pwqs_to_flush; <span class="comment">/* flush in progress */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_flusher</span>	*<span class="title">first_flusher</span>;</span>	<span class="comment">/* WQ: first flusher */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_queue</span>;</span>	<span class="comment">/* WQ: flush waiters */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">flusher_overflow</span>;</span> <span class="comment">/* WQ: flush overflow list */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//对于WQ_MEM_RECLAIM的工作队列</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">maydays</span>;</span>	<span class="comment">/* MD: pwqs requesting rescue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">rescuer</span>;</span>	<span class="comment">/* I: rescue worker */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			nr_drainers;	<span class="comment">/* WQ: drain in progress */</span></span><br><span class="line">	<span class="keyword">int</span>			saved_max_active; <span class="comment">/* WQ: saved pwq max_active */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">unbound_attrs</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span>	*<span class="title">dfl_pwq</span>;</span>	<span class="comment">/* PW: only for unbound wqs */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//指定了WQ_SYSFS标志的工作队列，为其创建sysfs的设备节点</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_SYSFS</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_device</span>	*<span class="title">wq_dev</span>;</span>	<span class="comment">/* I: for sysfs interface */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">    <span class="comment">//用于死锁调试的</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span>	<span class="title">lockdep_map</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="keyword">char</span>			name[WQ_NAME_LEN]; <span class="comment">/* I: 工作队列的名字 */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Destruction of workqueue_struct is sched-RCU protected to allow</span></span><br><span class="line"><span class="comment">	 * walking the workqueues list without grabbing wq_pool_mutex.</span></span><br><span class="line"><span class="comment">	 * This is used to dump all workqueues from sysrq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* hot fields used during command issue, aligned to cacheline */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags ____cacheline_aligned; <span class="comment">/* WQ: WQ_* flags */</span></span><br><span class="line">    <span class="comment">//工作队列可以拥有多个pwq，bounded的工作队列每一个cpu对应一个</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">percpu</span> *<span class="title">cpu_pwqs</span>;</span> <span class="comment">/* I: per-cpu pwqs */</span></span><br><span class="line">    <span class="comment">//工作队列可以拥有多个pwq，bounded的工作队列每一个node对应一个</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> __<span class="title">rcu</span> *<span class="title">numa_pwq_tbl</span>[];</span> <span class="comment">/* PWR: unbound pwqs indexed by node */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>创建工作队列的方法，创建MT模式的通常使用create_workqueue，只需要指定name、其他的参数按系统默认；如果调用的是alloc_workqueue可以指定更多的参数来创建更符合自己要求的工作队列；创建ST模式的通常使用的是create_singlethread_workqueue。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_ordered_workqueue - allocate an ordered workqueue</span></span><br><span class="line"><span class="comment"> * @fmt: printf format for the name of the workqueue</span></span><br><span class="line"><span class="comment"> * @flags: WQ_* flags (only WQ_FREEZABLE and WQ_MEM_RECLAIM are meaningful)</span></span><br><span class="line"><span class="comment"> * @args...: args for @fmt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocate an ordered workqueue.  An ordered workqueue executes at</span></span><br><span class="line"><span class="comment"> * most one work item at any given time in the queued order.  They are</span></span><br><span class="line"><span class="comment"> * implemented as unbound workqueues with @max_active of one.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * Pointer to the allocated workqueue on success, %NULL on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_ordered_workqueue(fmt, flags, args...)			\</span></span><br><span class="line">	alloc_workqueue(fmt, WQ_UNBOUND | __WQ_ORDERED |		\</span><br><span class="line">			__WQ_ORDERED_EXPLICIT | (flags), <span class="number">1</span>, ##args)</span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> create_workqueue(name)						\</span></span><br><span class="line">	alloc_workqueue(<span class="string">"%s"</span>, __WQ_LEGACY | WQ_MEM_RECLAIM, <span class="number">1</span>, (name))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> create_freezable_workqueue(name)				\</span></span><br><span class="line">	alloc_workqueue(<span class="string">"%s"</span>, __WQ_LEGACY | WQ_FREEZABLE | WQ_UNBOUND |	\</span><br><span class="line">			WQ_MEM_RECLAIM, <span class="number">1</span>, (name))</span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> create_singlethread_workqueue(name)				\</span></span><br><span class="line">	alloc_ordered_workqueue(<span class="string">"%s"</span>, __WQ_LEGACY | WQ_MEM_RECLAIM, name)</span><br></pre></td></tr></table></figure>

<p>通常情况下创建工作队列时使用系统默认的接口创建，不需要指定特定的flags。Linux内核中我们可以看到有以下关于工作队列的flags定义：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Workqueue flags and constants.  For details, please refer to</span></span><br><span class="line"><span class="comment"> * Documentation/workqueue.txt.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">enum</span> &#123;</span><br><span class="line">    <span class="comment">// 不绑定到任何cpu,牺牲cpu亲和性、并发需求量大的时候不会造成工作线程泛滥</span></span><br><span class="line">	WQ_UNBOUND		= <span class="number">1</span> &lt;&lt; <span class="number">1</span>, <span class="comment">/* not bound to any cpu */</span></span><br><span class="line">    <span class="comment">// 可冻结的WQ在系统suspend操作的freeze阶段，暂停新的work执行直到解冻。</span></span><br><span class="line">	WQ_FREEZABLE		= <span class="number">1</span> &lt;&lt; <span class="number">2</span>, <span class="comment">/* freeze during suspend */</span></span><br><span class="line">    <span class="comment">// 可能用于内存回收路径的WQ必须设置该flag。在内存紧张的时候也会保证至少有一个可执行的上下文用于该WQ。</span></span><br><span class="line">	WQ_MEM_RECLAIM		= <span class="number">1</span> &lt;&lt; <span class="number">3</span>, <span class="comment">/* may be used for memory reclaim */</span></span><br><span class="line">    <span class="comment">// 高优先级的WQ的work会被放入GCWQ的高优先级线程池。</span></span><br><span class="line">	WQ_HIGHPRI		= <span class="number">1</span> &lt;&lt; <span class="number">4</span>, <span class="comment">/* high priority */</span></span><br><span class="line">    <span class="comment">/* 设置为CPU密集型的WQ的work不会影响并发级别，即CPU密集型的work执行时并不会阻止同一个线程池里其他WQ的work的执行。</span></span><br><span class="line"><span class="comment">     * 这对希望独占CPU周期的work非常有用，由系统调度程序调度他们的执行。如果不设置该标记，则独占CPU周期的work会导致同一个线程池里其他WQ的work得不到执行。</span></span><br><span class="line"><span class="comment">     * 由于同一由CMWQ的并发管理进行调度，当非密集型的WQ的work运行过程中，也会导致密集型的WQ的work被推迟。该flag仅适用于bound的WQ，对unbound的WQ无效。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	WQ_CPU_INTENSIVE	= <span class="number">1</span> &lt;&lt; <span class="number">5</span>, <span class="comment">/* cpu intensive workqueue */</span></span><br><span class="line">	WQ_SYSFS		= <span class="number">1</span> &lt;&lt; <span class="number">6</span>, <span class="comment">/* visible in sysfs, see wq_sysfs_register() */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Per-cpu workqueues are generally preferred because they tend to</span></span><br><span class="line"><span class="comment">	 * show better performance thanks to cache locality.  Per-cpu</span></span><br><span class="line"><span class="comment">	 * workqueues exclude the scheduler from choosing the CPU to</span></span><br><span class="line"><span class="comment">	 * execute the worker threads, which has an unfortunate side effect</span></span><br><span class="line"><span class="comment">	 * of increasing power consumption.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * The scheduler considers a CPU idle if it doesn't have any task</span></span><br><span class="line"><span class="comment">	 * to execute and tries to keep idle cores idle to conserve power;</span></span><br><span class="line"><span class="comment">	 * however, for example, a per-cpu work item scheduled from an</span></span><br><span class="line"><span class="comment">	 * interrupt handler on an idle CPU will force the scheduler to</span></span><br><span class="line"><span class="comment">	 * excute the work item on that CPU breaking the idleness, which in</span></span><br><span class="line"><span class="comment">	 * turn may lead to more scheduling choices which are sub-optimal</span></span><br><span class="line"><span class="comment">	 * in terms of power consumption.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * Workqueues marked with WQ_POWER_EFFICIENT are per-cpu by default</span></span><br><span class="line"><span class="comment">	 * but become unbound if workqueue.power_efficient kernel param is</span></span><br><span class="line"><span class="comment">	 * specified.  Per-cpu workqueues which are identified to</span></span><br><span class="line"><span class="comment">	 * contribute significantly to power-consumption are identified and</span></span><br><span class="line"><span class="comment">	 * marked with this flag and enabling the power_efficient mode</span></span><br><span class="line"><span class="comment">	 * leads to noticeable power saving at the cost of small</span></span><br><span class="line"><span class="comment">	 * performance disadvantage.</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 * http://thread.gmane.org/gmane.linux.kernel/1480396</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WQ_POWER_EFFICIENT	= <span class="number">1</span> &lt;&lt; <span class="number">7</span>,</span><br><span class="line"></span><br><span class="line">	__WQ_DRAINING		= <span class="number">1</span> &lt;&lt; <span class="number">16</span>, <span class="comment">/* internal: workqueue is draining */</span></span><br><span class="line">	__WQ_ORDERED		= <span class="number">1</span> &lt;&lt; <span class="number">17</span>, <span class="comment">/* internal: workqueue is ordered */</span></span><br><span class="line">	__WQ_LEGACY		= <span class="number">1</span> &lt;&lt; <span class="number">18</span>, <span class="comment">/* internal: create*_workqueue() */</span></span><br><span class="line">	__WQ_ORDERED_EXPLICIT	= <span class="number">1</span> &lt;&lt; <span class="number">19</span>, <span class="comment">/* internal: alloc_ordered_workqueue() */</span></span><br><span class="line"></span><br><span class="line">	WQ_MAX_ACTIVE		= <span class="number">512</span>,	  <span class="comment">/* I like 512, better ideas? */</span></span><br><span class="line">	WQ_MAX_UNBOUND_PER_CPU	= <span class="number">4</span>,	  <span class="comment">/* 4 * #cpus for unbound wq */</span></span><br><span class="line">	WQ_DFL_ACTIVE		= WQ_MAX_ACTIVE / <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="工作者线程"><a href="#工作者线程" class="headerlink" title="工作者线程"></a>工作者线程</h4><p>工作者指的就是工作者线程，就是用于执行工作队列中所有工作任务的内核线程。工作者线程通常有两种表现形式：</p>
<ul>
<li>single threaded(ST)：在系统范围内，只有一个工作者线程为工作队列服务</li>
<li>multi threaded(MT)：在多 CPU 系统上每个 CPU 上都有一个工作者线程为工作队列服务</li>
</ul>
<p>工作者线程的创建工作基本不需要开发人员关心，从工作队列的创建方式中顺带就会创建工作者线程的。只是需要注意需要的是ST还是MT。</p>
<p>为了实现工作者线程池，针对每个工作者线程，Linux内核封装了一个结构体 worker，用于工作者线程的管理。其定义在workqueue_internal.h中，从头文件的名字也能看出是内核内部使用，开发者不需要用到这个结构体。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The poor guys doing the actual heavy lifting.  All on-duty workers are</span></span><br><span class="line"><span class="comment"> * either serving the manager role, on idle list or on busy hash.  For</span></span><br><span class="line"><span class="comment"> * details on the locking annotation (L, I, X...), refer to workqueue.c.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Only to be used in workqueue and async.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker</span> &#123;</span></span><br><span class="line">	<span class="comment">/* on idle list while idle, on busy hash table while busy */</span></span><br><span class="line">    <span class="comment">//可能在线程池的空闲链表中或者忙碌哈希表中</span></span><br><span class="line">	<span class="keyword">union</span> &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">entry</span>;</span>	<span class="comment">/* L: while idle */</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">hentry</span>;</span>	<span class="comment">/* L: while busy */</span></span><br><span class="line">	&#125;;</span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	*<span class="title">current_work</span>;</span>	<span class="comment">/* L: 当前正在处理的工作任务 */</span></span><br><span class="line">	<span class="keyword">work_func_t</span>		current_func;	<span class="comment">/* L: 当前工作任务的回调函数 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span>	*<span class="title">current_pwq</span>;</span> <span class="comment">/* L: 当前处理的工作任务所属的pwq */</span></span><br><span class="line">	<span class="keyword">bool</span>			desc_valid;	<span class="comment">/* -&gt;desc is valid */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">scheduled</span>;</span>	<span class="comment">/* L: scheduled works */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 64 bytes boundary on 64bit, 32 on 32bit */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span>	*<span class="title">task</span>;</span>		<span class="comment">/* I: worker task */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span>	*<span class="title">pool</span>;</span>		<span class="comment">/* I: the associated pool */</span></span><br><span class="line">						<span class="comment">/* L: for rescuers */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">node</span>;</span>		<span class="comment">/* A: 用来连接到pool-&gt;workers链表中的节点 */</span></span><br><span class="line">						<span class="comment">/* A: runs through worker-&gt;node */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		last_active;	<span class="comment">/* L: 上一次活跃的时间戳 */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;		<span class="comment">/* X: flags */</span></span><br><span class="line">	<span class="keyword">int</span>			id;		<span class="comment">/* I: worker id */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Opaque string set with work_set_desc().  Printed out with task</span></span><br><span class="line"><span class="comment">	 * dump for debugging - WARN, BUG, panic or sysrq.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="keyword">char</span>			desc[WORKER_DESC_LEN];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* used only by rescuers to point to the target workqueue */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span>	*<span class="title">rescue_wq</span>;</span>	<span class="comment">/* I: the workqueue to rescue */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<h4 id="工作者线程池"><a href="#工作者线程池" class="headerlink" title="工作者线程池"></a>工作者线程池</h4><p>工作者线程池是工作者线程的集合，工作者线程的数量可以动态变化。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * Structure fields follow one of the following exclusion rules.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * I: Modifiable by initialization/destruction paths and read-only for</span></span><br><span class="line"><span class="comment"> *    everyone else.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * P: Preemption protected.  Disabling preemption is enough and should</span></span><br><span class="line"><span class="comment"> *    only be modified and accessed from the local cpu.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * L: pool-&gt;lock protected.  Access with pool-&gt;lock held.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * X: During normal operation, modification requires pool-&gt;lock and should</span></span><br><span class="line"><span class="comment"> *    be done only from local cpu.  Either disabling preemption on local</span></span><br><span class="line"><span class="comment"> *    cpu or grabbing pool-&gt;lock is enough for read access.  If</span></span><br><span class="line"><span class="comment"> *    POOL_DISASSOCIATED is set, it's identical to L.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * A: pool-&gt;attach_mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PL: wq_pool_mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PR: wq_pool_mutex protected for writes.  Sched-RCU protected for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PW: wq_pool_mutex and wq-&gt;mutex protected for writes.  Either for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * PWR: wq_pool_mutex and wq-&gt;mutex protected for writes.  Either or</span></span><br><span class="line"><span class="comment"> *      sched-RCU for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WQ: wq-&gt;mutex protected.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * WR: wq-&gt;mutex protected for writes.  Sched-RCU protected for reads.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * MD: wq_mayday_lock protected.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* struct worker is defined in workqueue_internal.h */</span></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> &#123;</span></span><br><span class="line">	<span class="keyword">spinlock_t</span>		lock;		<span class="comment">/* 线程池互斥锁 */</span></span><br><span class="line">	<span class="keyword">int</span>			cpu;		<span class="comment">/* I: 所属的cpu */</span></span><br><span class="line">	<span class="keyword">int</span>			node;		<span class="comment">/* I: 所属的cpu节点，通常和cpu的值是一样的 */</span></span><br><span class="line">	<span class="keyword">int</span>			id;		<span class="comment">/* I: 线程池id */</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span>		flags;		<span class="comment">/* X: 线程池的状态标志 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span>		watchdog_ts;	<span class="comment">/* L: watchdog timestamp */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//待处理的工作任务列表：各个 workqueue 把 work 挂载到这个链表上，让 worker_pool 对应的多个 worker 来执行</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">worklist</span>;</span></span><br><span class="line">	<span class="keyword">int</span>			nr_workers;	<span class="comment">/* L: 工作者线程总数 */</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">int</span>			nr_idle;	<span class="comment">/* L: 当前空闲的工作者数量，也就是idle_list链表中的数量*/</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//空闲的工作者线程列表：线程空闲时不会马上销毁，先进入 idle 状态备选</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">idle_list</span>;</span></span><br><span class="line">    <span class="comment">//工作者线程空闲超时定时器，判断是否需要销毁线程</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">idle_timer</span>;</span></span><br><span class="line">    <span class="comment">//在 worker_pool 创建新的工作者线程时，检查是否超时的timer</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">timer_list</span>	<span class="title">mayday_timer</span>;</span>	<span class="comment">/* L: SOS timer for workers */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* a workers is either on busy_hash or idle_list, or the manager */</span></span><br><span class="line">    <span class="comment">//当工作者线程忙碌是被挂在busy_hash中，空闲时则在空闲列表中</span></span><br><span class="line">	DECLARE_HASHTABLE(busy_hash, BUSY_WORKER_HASH_ORDER);</span><br><span class="line">						<span class="comment">/* L: hash of busy workers */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* see manage_workers() for details on the two manager mutexes */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span>		*<span class="title">manager</span>;</span>	<span class="comment">/* L: purely informational */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">mutex</span>		<span class="title">attach_mutex</span>;</span>	<span class="comment">/* 工作者线程attch和detach时候的互斥锁 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">workers</span>;</span>	<span class="comment">/* A: 线程池所有的工作者都挂在这个列表上 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">completion</span>	*<span class="title">detach_completion</span>;</span> <span class="comment">/* all workers detached */</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//用于给工作者线程起名的id集</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">ida</span>		<span class="title">worker_ida</span>;</span>	<span class="comment">/* worker IDs for task name */</span></span><br><span class="line"></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span>	*<span class="title">attrs</span>;</span>		<span class="comment">/* I: worker attributes 工作者线程属性集*/</span></span><br><span class="line">    </span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">hlist_node</span>	<span class="title">hash_node</span>;</span>	<span class="comment">/* PL: unbound_pool_hash node */</span></span><br><span class="line">	<span class="keyword">int</span>			refcnt;		<span class="comment">/* PL: refcnt for unbound pools */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The current concurrency level.  As it's likely to be accessed</span></span><br><span class="line"><span class="comment">	 * from other CPUs during try_to_wake_up(), put it in a separate</span></span><br><span class="line"><span class="comment">	 * cacheline.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//当前处于运行状态的工作者线程的数量</span></span><br><span class="line">	<span class="keyword">atomic_t</span>		nr_running ____cacheline_aligned_in_smp;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Destruction of pool is sched-RCU protected to allow dereferences</span></span><br><span class="line"><span class="comment">	 * from get_work_pool().</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125; ____cacheline_aligned_in_smp;</span><br></pre></td></tr></table></figure>

<h4 id="PWQ"><a href="#PWQ" class="headerlink" title="PWQ"></a>PWQ</h4><p>pwq起到了中介的作用，负责建立起 workqueue 和 worker_pool 之间的关系。workqueue 和 pwq 是一对多的关系，pwq 和 worker_pool 是一对一的关系。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * The per-pool workqueue.  While queued, the lower WORK_STRUCT_FLAG_BITS</span></span><br><span class="line"><span class="comment"> * of work_struct-&gt;data are used for flags and the remaining high bits</span></span><br><span class="line"><span class="comment"> * point to the pwq; thus, pwqs need to be aligned at two's power of the</span></span><br><span class="line"><span class="comment"> * number of flag bits.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> &#123;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span>	*<span class="title">pool</span>;</span>		<span class="comment">/* I: the associated pool */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span>		<span class="comment">/* I: the owning workqueue */</span></span><br><span class="line">	<span class="keyword">int</span>			work_color;	<span class="comment">/* L: current color */</span></span><br><span class="line">	<span class="keyword">int</span>			flush_color;	<span class="comment">/* L: flushing color */</span></span><br><span class="line">	<span class="keyword">int</span>			refcnt;		<span class="comment">/* L: reference count */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_in_flight[WORK_NR_COLORS];</span><br><span class="line">						<span class="comment">/* L: nr of in_flight works */</span></span><br><span class="line">	<span class="keyword">int</span>			nr_active;	<span class="comment">/* L: nr of active works */</span></span><br><span class="line">	<span class="keyword">int</span>			max_active;	<span class="comment">/* L: max active works */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">delayed_works</span>;</span>	<span class="comment">/* L: delayed works */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">pwqs_node</span>;</span>	<span class="comment">/* WR: node on wq-&gt;pwqs */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span>	<span class="title">mayday_node</span>;</span>	<span class="comment">/* MD: node on wq-&gt;maydays */</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Release of unbound pwq is punted to system_wq.  See put_pwq()</span></span><br><span class="line"><span class="comment">	 * and pwq_unbound_release_workfn() for details.  pool_workqueue</span></span><br><span class="line"><span class="comment">	 * itself is also sched-RCU protected so that the first pwq can be</span></span><br><span class="line"><span class="comment">	 * determined without grabbing wq-&gt;mutex.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span>	<span class="title">unbound_release_work</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">rcu_head</span>		<span class="title">rcu</span>;</span></span><br><span class="line">&#125; __aligned(<span class="number">1</span> &lt;&lt; WORK_STRUCT_FLAG_BITS);</span><br></pre></td></tr></table></figure>

<h4 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h4><h5 id="bound类型"><a href="#bound类型" class="headerlink" title="bound类型"></a>bound类型</h5><p>大部分的工作任务( 例如通过schedule_work()、schedule_work_on()压入到系统system_wq中的 work；或者压入由create_workqueue创建的工作队列中的work)，最后都是通过normal worker_pool中的 worker来执行的。这些worker是和某个CPU绑定的，work 一旦被worker开始执行，都是一直运行到某个CPU上的不会切换 CPU。</p>
<p>1、工作任务、工作队列、工作者线程、工作者线程池和PWQ这5部分主体之间总的关系如下：工作队列中为每个cpu创建一个pwq，pwq连接着对应所属的工作队列和目标线程池，线程池和cpu绑定。<img src="/2019/04/20/Linux-irq-bh-workqueue/all.PNG" alt="总关系图"></p>
<p>2、系统为每个cpu规划了两个线程池。工作者线程池-工作者线程-工作任务3者之间的关系：线程池维护了工作者线程列表和工作任务列表。<img src="/2019/04/20/Linux-irq-bh-workqueue/worker_pool-worker-work.PNG" alt="线程池侧"></p>
<h5 id="unbound类型"><a href="#unbound类型" class="headerlink" title="unbound类型"></a>unbound类型</h5><p>unbound worker_pool相对应的意思，就是 worker 可以在多个 CPU 上调度的。但是他其实也是绑定的，只不过它绑定的单位不是 CPU 而是 node。所谓的 node 是对 NUMA(Non Uniform Memory Access Architecture) 系统来说的，NUMA 可能存在多个 node，每个 node 可能包含一个或者多个 CPU。</p>
<h6 id="std"><a href="#std" class="headerlink" title="std"></a>std</h6><p>一个node对应一个线程池；这种工作度列有node+1个pwq，numa_pwq_tbl分别指向一个线程池，dfl_pwq为默认的pwq，对于std的来说没有用到。<img src="/2019/04/20/Linux-irq-bh-workqueue/std.PNG" alt="std"></p>
<h6 id="ordered"><a href="#ordered" class="headerlink" title="ordered"></a>ordered</h6><p>所有node对应一个线程池；这种工作度列只有1个pwq，numa_pwq_tbl全都指向一个线程池，也就是默认的dfl_pwq。<img src="/2019/04/20/Linux-irq-bh-workqueue/order.PNG" alt="std"></p>
<h2 id="工作流程"><a href="#工作流程" class="headerlink" title="工作流程"></a>工作流程</h2><h4 id="子系统初始化"><a href="#子系统初始化" class="headerlink" title="子系统初始化"></a>子系统初始化</h4><p>先看看内核初始化过程中的工作队列子系统的初始化工作，然后引申到工作队列、工作者、线程池和pwq的创建和连接的创建流程。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">static</span> <span class="keyword">int</span> __<span class="function">init <span class="title">init_workqueues</span><span class="params">(<span class="keyword">void</span>)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> std_nice[NR_STD_WORKER_POOLS] = &#123; <span class="number">0</span>, HIGHPRI_NICE_LEVEL &#125;;</span><br><span class="line">	<span class="keyword">int</span> i, cpu;</span><br><span class="line"></span><br><span class="line">	WARN_ON(__alignof__(struct pool_workqueue) &lt; __alignof__(<span class="keyword">long</span> <span class="keyword">long</span>));</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step1：允许用于未绑定的wq和工作项的cpus，以我们四个cpu的例子</span></span><br><span class="line"><span class="comment">     * p wq_unbound_cpumask</span></span><br><span class="line"><span class="comment">     * wq_unbound_cpumask = $11 = </span></span><br><span class="line"><span class="comment">     * &#123;&#123;</span></span><br><span class="line"><span class="comment">        bits = &#123;15&#125;</span></span><br><span class="line"><span class="comment">     * &#125;&#125;</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	BUG_ON(!alloc_cpumask_var(&amp;wq_unbound_cpumask, GFP_KERNEL));</span><br><span class="line">	cpumask_copy(wq_unbound_cpumask, cpu_possible_mask);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* step2：创建专门用于分配pool_workqueue对象的slub cache，创建失败则panic。</span></span><br><span class="line"><span class="comment">     * 可以在/sys/kernel/slab/pool_workqueue查看相关信息</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	pwq_cache = KMEM_CACHE(pool_workqueue, SLAB_PANIC);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step3：NUMA(Non-Uniform Memory Access)字面直译为“非一致性内存访问”,先忽略</span></span><br><span class="line">	wq_numa_init();</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step4：initialize CPU pools:</span></span><br><span class="line"><span class="comment">     * 如果系统有4个cpu，则对4个cpu的线程池都进行初始化；</span></span><br><span class="line"><span class="comment">     * 每个cpu有NR_STD_WORKER_POOLS标准线程池，一个是普通优先级，一个是高优先级</span></span><br><span class="line"><span class="comment">     * per-cpu类型的线程池是这样定义的：</span></span><br><span class="line"><span class="comment">       static DEFINE_PER_CPU_SHARED_ALIGNED(struct worker_pool [NR_STD_WORKER_POOLS], cpu_worker_pools);</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	for_each_possible_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		i = <span class="number">0</span>;</span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			BUG_ON(init_worker_pool(pool));</span><br><span class="line">            <span class="comment">//指定线程池所属的cpu</span></span><br><span class="line">			pool-&gt;cpu = cpu;</span><br><span class="line">			cpumask_copy(pool-&gt;attrs-&gt;cpumask, cpumask_of(cpu));</span><br><span class="line">            <span class="comment">//该线程池的线程默认的nice值</span></span><br><span class="line">			pool-&gt;attrs-&gt;nice = std_nice[i++];</span><br><span class="line">			pool-&gt;node = cpu_to_node(cpu);</span><br><span class="line"></span><br><span class="line">			<span class="comment">/* alloc pool ID 分配线程池id*/</span></span><br><span class="line">			mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line">			BUG_ON(worker_pool_assign_id(pool));</span><br><span class="line">			mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step5：create the initial worker 为线程池创建一个初始工作者</span></span><br><span class="line"><span class="comment">	 *</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	for_each_online_cpu(cpu) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">		for_each_cpu_worker_pool(pool, cpu) &#123;</span><br><span class="line">			pool-&gt;flags &amp;= ~POOL_DISASSOCIATED;</span><br><span class="line">			BUG_ON(!create_worker(pool));</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* step6：create default unbound and ordered wq attrs </span></span><br><span class="line"><span class="comment">	 * 创建非绑定和有序工作队列的属性集</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">    </span><br><span class="line">	<span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; NR_STD_WORKER_POOLS; i++) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">attrs</span>;</span></span><br><span class="line"></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		unbound_std_wq_attrs[i] = attrs;</span><br><span class="line"></span><br><span class="line">		<span class="comment">/*</span></span><br><span class="line"><span class="comment">		 * An ordered wq should have only one pwq as ordering is</span></span><br><span class="line"><span class="comment">		 * guaranteed by max_active which is enforced by pwqs.</span></span><br><span class="line"><span class="comment">		 * Turn off NUMA so that dfl_pwq is used for all nodes.</span></span><br><span class="line"><span class="comment">		 */</span></span><br><span class="line">		BUG_ON(!(attrs = alloc_workqueue_attrs(GFP_KERNEL)));</span><br><span class="line">		attrs-&gt;nice = std_nice[i];</span><br><span class="line">		attrs-&gt;no_numa = <span class="literal">true</span>;<span class="comment">//有序队列只能有一个pwq，所有no_numa设置成true</span></span><br><span class="line">		ordered_wq_attrs[i] = attrs;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//step7：创建默认的全局工作队列</span></span><br><span class="line">	system_wq = alloc_workqueue(<span class="string">"events"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_highpri_wq = alloc_workqueue(<span class="string">"events_highpri"</span>, WQ_HIGHPRI, <span class="number">0</span>);</span><br><span class="line">	system_long_wq = alloc_workqueue(<span class="string">"events_long"</span>, <span class="number">0</span>, <span class="number">0</span>);</span><br><span class="line">	system_unbound_wq = alloc_workqueue(<span class="string">"events_unbound"</span>, WQ_UNBOUND,</span><br><span class="line">					    WQ_UNBOUND_MAX_ACTIVE);</span><br><span class="line">	system_freezable_wq = alloc_workqueue(<span class="string">"events_freezable"</span>,</span><br><span class="line">					      WQ_FREEZABLE, <span class="number">0</span>);</span><br><span class="line">	system_power_efficient_wq = alloc_workqueue(<span class="string">"events_power_efficient"</span>,</span><br><span class="line">					      WQ_POWER_EFFICIENT, <span class="number">0</span>);</span><br><span class="line">	system_freezable_power_efficient_wq = alloc_workqueue(<span class="string">"events_freezable_power_efficient"</span>,</span><br><span class="line">					      WQ_FREEZABLE | WQ_POWER_EFFICIENT,</span><br><span class="line">					      <span class="number">0</span>);</span><br><span class="line">	BUG_ON(!system_wq || !system_highpri_wq || !system_long_wq ||</span><br><span class="line">	       !system_unbound_wq || !system_freezable_wq ||</span><br><span class="line">	       !system_power_efficient_wq ||</span><br><span class="line">	       !system_freezable_power_efficient_wq);</span><br><span class="line"></span><br><span class="line">	wq_watchdog_init();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h5 id="step4-线程池"><a href="#step4-线程池" class="headerlink" title="step4-线程池"></a>step4-线程池</h5><p>从step4中可以知道系统统一为每个CPU创建两个普通的worker_pool：一个 normal 优先级 (nice=0)、一个高优先级 (nice=HIGHPRI_NICE_LEVEL)，对应创建出来的 worker 的进程 nice 不一样的。</p>
<h5 id="step5-工作者"><a href="#step5-工作者" class="headerlink" title="step5-工作者"></a>step5-工作者</h5><p>init_workqueues函数的step4中，线程池的初始化工作在init_worker_pool完成，其流程简单，我们基本上只要了解worker_pool的各个成员即可。这里我们看看step5中如何在指定线程池上创建一个工作者线程的，其中关键函数create_worker：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * create_worker - create a new workqueue worker</span></span><br><span class="line"><span class="comment"> * @pool: pool the new worker will belong to</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Create and start a new worker which is attached to @pool.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * Might sleep.  Does GFP_KERNEL allocations.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * Pointer to the newly created worker.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct worker *<span class="title">create_worker</span><span class="params">(struct worker_pool *pool)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = <span class="title">NULL</span>;</span></span><br><span class="line">	<span class="keyword">int</span> id = <span class="number">-1</span>;</span><br><span class="line">	<span class="keyword">char</span> id_buf[<span class="number">16</span>];</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* ID is needed to determine kthread name */</span></span><br><span class="line">    <span class="comment">// 需要ID来确定工作者线程的名称</span></span><br><span class="line">	id = ida_simple_get(&amp;pool-&gt;worker_ida, <span class="number">0</span>, <span class="number">0</span>, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (id &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 从cpu对应的内存节点上分配工作者结构体，初始化相关用于链表的entry，设置flags为预备状态</span></span><br><span class="line"><span class="comment">     *通过/proc/buddyinfo可以看出有多少个内存节点，以下例子只有一个内存节点</span></span><br><span class="line"><span class="comment">     * XXX<span class="doctag">XXX:</span># cat /proc/buddyinfo</span></span><br><span class="line"><span class="comment">     * Node 0, zone      DMA   3998   2556    591     69      7      6      0      1      0      0      0</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	worker = alloc_worker(pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!worker)</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置工作者所属的线程池和对应的id</span></span><br><span class="line">	worker-&gt;pool = pool;</span><br><span class="line">	worker-&gt;id = id;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 工作者线程名规则：通过所在线程池的cpu和id确定线程的名字</span></span><br><span class="line"><span class="comment">     * "绑定"-&gt;CPU：id（H），对应的cpu，线程id，是否为高优先级</span></span><br><span class="line"><span class="comment">     * "非绑定"-&gt;u线程池id：线程id，u代表非绑定</span></span><br><span class="line"><span class="comment">     * 线程名 = kworker/"绑定" 或 kworker/"非绑定"</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (pool-&gt;cpu &gt;= <span class="number">0</span>)</span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"%d:%d%s"</span>, pool-&gt;cpu, id,</span><br><span class="line">			 pool-&gt;attrs-&gt;nice &lt; <span class="number">0</span>  ? <span class="string">"H"</span> : <span class="string">""</span>);</span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		<span class="built_in">snprintf</span>(id_buf, <span class="keyword">sizeof</span>(id_buf), <span class="string">"u%d:%d"</span>, pool-&gt;id, id);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//创建真正的内核线程，执行体为worker_thread</span></span><br><span class="line">	worker-&gt;task = kthread_create_on_node(worker_thread, worker, pool-&gt;node,</span><br><span class="line">					      <span class="string">"kworker/%s"</span>, id_buf);</span><br><span class="line">	<span class="keyword">if</span> (IS_ERR(worker-&gt;task))</span><br><span class="line">		<span class="keyword">goto</span> fail;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//设置线程的nice值</span></span><br><span class="line">	set_user_nice(worker-&gt;task, pool-&gt;attrs-&gt;nice);</span><br><span class="line">    <span class="comment">//设置允许线程在指定的cpu上调度</span></span><br><span class="line">	kthread_bind_mask(worker-&gt;task, pool-&gt;attrs-&gt;cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* successful, attach the worker to the pool */</span></span><br><span class="line">    <span class="comment">//将工作者attach到线程池中</span></span><br><span class="line">	worker_attach_to_pool(worker, pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* start the newly created worker */</span></span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line">	worker-&gt;pool-&gt;nr_workers++; <span class="comment">//池中的工作者数量+1</span></span><br><span class="line">	worker_enter_idle(worker);  <span class="comment">//使工作者进入空闲状态，见worker_enter_idle函数</span></span><br><span class="line">	wake_up_process(worker-&gt;task); <span class="comment">//尝试唤醒指定的进程并将其移动到就绪队列中</span></span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> worker;</span><br><span class="line"></span><br><span class="line">fail:</span><br><span class="line">	<span class="keyword">if</span> (id &gt;= <span class="number">0</span>)</span><br><span class="line">		ida_simple_remove(&amp;pool-&gt;worker_ida, id);</span><br><span class="line">	kfree(worker);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>worker_enter_idle函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * worker_enter_idle - enter idle state</span></span><br><span class="line"><span class="comment"> * @worker: worker which is entering idle state</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * @worker is entering idle state.  Update stats and idle timer if</span></span><br><span class="line"><span class="comment"> * necessary.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * LOCKING:</span></span><br><span class="line"><span class="comment"> * spin_lock_irq(pool-&gt;lock).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">worker_enter_idle</span><span class="params">(struct worker *worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON_ONCE(worker-&gt;flags &amp; WORKER_IDLE) ||</span><br><span class="line">	    WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry) &amp;&amp;</span><br><span class="line">			 (worker-&gt;hentry.next || worker-&gt;hentry.pprev)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* can't use worker_set_flags(), also called from create_worker() */</span></span><br><span class="line">    <span class="comment">//设置工作者空闲标志、线程池的空闲工作者数量+1、更新工作者最新的活动时间戳</span></span><br><span class="line">	worker-&gt;flags |= WORKER_IDLE;</span><br><span class="line">	pool-&gt;nr_idle++;</span><br><span class="line">	worker-&gt;last_active = jiffies;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* idle_list is LIFO */</span></span><br><span class="line">    <span class="comment">//添加到工作者线程池的空闲列表中</span></span><br><span class="line">	list_add(&amp;worker-&gt;entry, &amp;pool-&gt;idle_list);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 通过too_many_workers判断该池的工作者是否过多？</span></span><br><span class="line"><span class="comment">     * 判断标准：空闲数量大于2，并且空闲数量-2大于忙碌数量的1/4时，说明线程多</span></span><br><span class="line"><span class="comment">     * 如果工作者太多，并且idle_timer还没有超时，重置idle_timer定时器</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	<span class="keyword">if</span> (too_many_workers(pool) &amp;&amp; !timer_pending(&amp;pool-&gt;idle_timer))</span><br><span class="line">		mod_timer(&amp;pool-&gt;idle_timer, jiffies + IDLE_WORKER_TIMEOUT);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Sanity check nr_running.  Because unbind_workers() releases</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock between setting %WORKER_UNBOUND and zapping</span></span><br><span class="line"><span class="comment">	 * nr_running, the warning may trigger spuriously.  Check iff</span></span><br><span class="line"><span class="comment">	 * unbind is not in progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">		     pool-&gt;nr_workers == pool-&gt;nr_idle &amp;&amp;</span><br><span class="line">		     atomic_read(&amp;pool-&gt;nr_running));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>wake_up_process之后工作者线程就可能被调度，看看工作者线程的worker_thread执行流程：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * worker_thread - the worker thread function</span></span><br><span class="line"><span class="comment"> * @__worker: self</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The worker thread function.  All workers belong to a worker_pool -</span></span><br><span class="line"><span class="comment"> * either a per-cpu one or dynamic unbound one.  These workers process all</span></span><br><span class="line"><span class="comment"> * work items regardless of their specific target workqueue.  The only</span></span><br><span class="line"><span class="comment"> * exception is work items which belong to workqueues with a rescuer which</span></span><br><span class="line"><span class="comment"> * will be explained in rescuer_thread().</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: 0</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">worker_thread</span><span class="params">(<span class="keyword">void</span> *__worker)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span> = __<span class="title">worker</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* tell the scheduler that this is a workqueue worker */</span></span><br><span class="line">    <span class="comment">//设置该线程为工作队列的工作者线程</span></span><br><span class="line">	worker-&gt;task-&gt;flags |= PF_WQ_WORKER;</span><br><span class="line">woke_up:</span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* am I supposed to die? </span></span><br><span class="line"><span class="comment">	 * destroy_worker的时候回设置WORKER_DIE标志，代表工作者被销毁，对应的线程应该退出</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(worker-&gt;flags &amp; WORKER_DIE)) &#123;</span><br><span class="line">		spin_unlock_irq(&amp;pool-&gt;lock);</span><br><span class="line">		WARN_ON_ONCE(!list_empty(&amp;worker-&gt;entry));</span><br><span class="line">		worker-&gt;task-&gt;flags &amp;= ~PF_WQ_WORKER;</span><br><span class="line"></span><br><span class="line">		set_task_comm(worker-&gt;task, <span class="string">"kworker/dying"</span>);</span><br><span class="line">		ida_simple_remove(&amp;pool-&gt;worker_ida, worker-&gt;id);</span><br><span class="line">		worker_detach_from_pool(worker, pool);</span><br><span class="line">		kfree(worker);</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">/* 到这里工作者就要对出空闲状态了</span></span><br><span class="line"><span class="comment">     * 清楚WORKER_IDLE标志，线程池的空闲数-1，从线程池的空闲列表拿掉</span></span><br><span class="line"><span class="comment">     */</span></span><br><span class="line">	worker_leave_idle(worker);</span><br><span class="line">recheck:</span><br><span class="line">	<span class="comment">/* no more worker necessary? </span></span><br><span class="line"><span class="comment">	 * 当该线程池中等待被处理的工作任务队列不为空，并且正在运行的工作者数量为0时</span></span><br><span class="line"><span class="comment">	*/</span></span><br><span class="line">	<span class="keyword">if</span> (!need_more_worker(pool))</span><br><span class="line">		<span class="keyword">goto</span> sleep;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* do we need to manage? */</span></span><br><span class="line">    <span class="comment">//如果已经没有空闲的线程，启动一些备用线程</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!may_start_working(pool)) &amp;&amp; manage_workers(worker))</span><br><span class="line">		<span class="keyword">goto</span> recheck;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * -&gt;scheduled list can only be filled while a worker is</span></span><br><span class="line"><span class="comment">	 * preparing to process a work or actually processing it.</span></span><br><span class="line"><span class="comment">	 * Make sure nobody diddled with it while I was sleeping.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	WARN_ON_ONCE(!list_empty(&amp;worker-&gt;scheduled));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Finish PREP stage.  We're guaranteed to have at least one idle</span></span><br><span class="line"><span class="comment">	 * worker or that someone else has already assumed the manager</span></span><br><span class="line"><span class="comment">	 * role.  This is where @worker starts participating in concurrency</span></span><br><span class="line"><span class="comment">	 * management if applicable and concurrency management is restored</span></span><br><span class="line"><span class="comment">	 * after being rebound.  See rebind_workers() for details.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//进入循环之前清楚WORKER_PREP | WORKER_REBOUND标志位</span></span><br><span class="line">	worker_clr_flags(worker, WORKER_PREP | WORKER_REBOUND);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">do</span> &#123;</span><br><span class="line">        <span class="comment">//取出该线程池中worklist的第一项工作任务</span></span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">work_struct</span> *<span class="title">work</span> =</span></span><br><span class="line"><span class="class">			<span class="title">list_first_entry</span>(&amp;<span class="title">pool</span>-&gt;<span class="title">worklist</span>,</span></span><br><span class="line"><span class="class">					 <span class="title">struct</span> <span class="title">work_struct</span>, <span class="title">entry</span>);</span></span><br><span class="line"></span><br><span class="line">        <span class="comment">//设置看门狗时间戳</span></span><br><span class="line">		pool-&gt;watchdog_ts = jiffies;</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (likely(!(*work_data_bits(work) &amp; WORK_STRUCT_LINKED))) &#123;</span><br><span class="line">			<span class="comment">/* optimization path, not strictly necessary */</span></span><br><span class="line">            <span class="comment">//单独处理一个工作任务</span></span><br><span class="line">			process_one_work(worker, work);</span><br><span class="line">            <span class="comment">//处理scheduled列表上的工作任务</span></span><br><span class="line">			<span class="keyword">if</span> (unlikely(!list_empty(&amp;worker-&gt;scheduled)))</span><br><span class="line">				process_scheduled_works(worker);</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="comment">//如果当前work_struct置位WORK_STRUCT_LINKED表示work后面还串上其它work，把这些work迁移到woeker_pool-&gt;scheduled中，然后再用process_scheduled_works函数处理。</span></span><br><span class="line">			move_linked_works(work, &amp;worker-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">			process_scheduled_works(worker);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">while</span> (keep_working(pool));<span class="comment">//保持持续工作</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//重新进入就绪状态</span></span><br><span class="line">	worker_set_flags(worker, WORKER_PREP);</span><br><span class="line">sleep:</span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock is held and there's no work to process and no need to</span></span><br><span class="line"><span class="comment">	 * manage, sleep.  Workers are woken up only while holding</span></span><br><span class="line"><span class="comment">	 * pool-&gt;lock or from local cpu, so setting the current state</span></span><br><span class="line"><span class="comment">	 * before releasing pool-&gt;lock is enough to prevent losing any</span></span><br><span class="line"><span class="comment">	 * event.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	worker_enter_idle(worker); <span class="comment">//进入idle状态</span></span><br><span class="line">	__set_current_state(TASK_INTERRUPTIBLE);<span class="comment">//设置自己的状态为TASK_INTERRUPTIBLE</span></span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);<span class="comment">//释放线程池互斥锁</span></span><br><span class="line">	schedule();<span class="comment">//调度</span></span><br><span class="line">	<span class="keyword">goto</span> woke_up;<span class="comment">//到这里就代表该县城又重新被唤醒了</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>process_one_work这个函数的逻辑比较复杂！工作任务的回调函数就是在这里面执行的。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * process_one_work - process single work</span></span><br><span class="line"><span class="comment"> * @worker: self</span></span><br><span class="line"><span class="comment"> * @work: work to process</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Process @work.  This function contains all the logics necessary to</span></span><br><span class="line"><span class="comment"> * process a single work including synchronization against and</span></span><br><span class="line"><span class="comment"> * interaction with other workers on the same cpu, queueing and</span></span><br><span class="line"><span class="comment"> * flushing.  As long as context requirement is met, any worker can</span></span><br><span class="line"><span class="comment"> * call this function to process a work.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * spin_lock_irq(pool-&gt;lock) which is released and regrabbed.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">process_one_work</span><span class="params">(struct worker *worker, struct work_struct *work)</span></span></span><br><span class="line"><span class="function">__<span class="title">releases</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function">__<span class="title">acquires</span><span class="params">(&amp;pool-&gt;lock)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">//要处理的工作任务所属的pwq</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> = <span class="title">get_work_pwq</span>(<span class="title">work</span>);</span></span><br><span class="line">    <span class="comment">//处理工作任务的线程所属的线程池</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">worker</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line">    <span class="comment">//要处理的工作任务所属的工作队列是否是cpu密集型的</span></span><br><span class="line">	<span class="keyword">bool</span> cpu_intensive = pwq-&gt;wq-&gt;flags &amp; WQ_CPU_INTENSIVE;</span><br><span class="line">	<span class="keyword">int</span> work_color;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">collision</span>;</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * It is permissible to free the struct work_struct from</span></span><br><span class="line"><span class="comment">	 * inside the function that is called from it, this we need to</span></span><br><span class="line"><span class="comment">	 * take into account for lockdep too.  To avoid bogus "held</span></span><br><span class="line"><span class="comment">	 * lock freed" warnings as well as problems when looking into</span></span><br><span class="line"><span class="comment">	 * work-&gt;lockdep_map, make a copy and use that here.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">lockdep_map</span> <span class="title">lockdep_map</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_copy_map(&amp;lockdep_map, &amp;work-&gt;lockdep_map);</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br><span class="line">	<span class="comment">/* ensure we're on the correct CPU */</span></span><br><span class="line">	WARN_ON_ONCE(!(pool-&gt;flags &amp; POOL_DISASSOCIATED) &amp;&amp;</span><br><span class="line">		     raw_smp_processor_id() != pool-&gt;cpu);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * A single work shouldn't be executed concurrently by</span></span><br><span class="line"><span class="comment">	 * multiple workers on a single cpu.  Check whether anyone is</span></span><br><span class="line"><span class="comment">	 * already processing the work.  If so, defer the work to the</span></span><br><span class="line"><span class="comment">	 * currently executing one.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 一个工作任务不能同时被一个cpu上的不同线程处理。</span></span><br><span class="line"><span class="comment">     * 通过遍历pool的busy_hash看看是已经有线程在处理这个work。</span></span><br><span class="line"><span class="comment">     * 如果 work 已经在 worker_pool 的其他 worker 上执行，</span></span><br><span class="line"><span class="comment">     * 将 work 放入对应 worker 的 scheduled 队列中延后执行。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	collision = find_worker_executing_work(pool, work);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(collision)) &#123;</span><br><span class="line">		move_linked_works(work, &amp;collision-&gt;scheduled, <span class="literal">NULL</span>);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* claim and dequeue */</span></span><br><span class="line">	debug_work_deactivate(work);</span><br><span class="line">    <span class="comment">//工作者进入忙碌</span></span><br><span class="line">	hash_add(pool-&gt;busy_hash, &amp;worker-&gt;hentry, (<span class="keyword">unsigned</span> <span class="keyword">long</span>)work);</span><br><span class="line">	worker-&gt;current_work = work;</span><br><span class="line">	worker-&gt;current_func = work-&gt;func;</span><br><span class="line">	worker-&gt;current_pwq = pwq;</span><br><span class="line">	work_color = get_work_color(work);</span><br><span class="line">    <span class="comment">//work从任务列表中摘除</span></span><br><span class="line">	list_del_init(&amp;work-&gt;entry);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * CPU intensive works don't participate in concurrency management.</span></span><br><span class="line"><span class="comment">	 * They're the scheduler's responsibility.  This takes @worker out</span></span><br><span class="line"><span class="comment">	 * of concurrency management and the next code block will chain</span></span><br><span class="line"><span class="comment">	 * execution of the pending work items.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 如果work所在的工作队列是cpu密集型的WQ_CPU_INTENSIVE，</span></span><br><span class="line"><span class="comment">     * 则当前worker的执行脱离 worker_pool 的动态调度，成为一个独立的线程。</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_set_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Wake up another worker if necessary.  The condition is always</span></span><br><span class="line"><span class="comment">	 * false for normal per-cpu workers since nr_running would always</span></span><br><span class="line"><span class="comment">	 * be &gt;= 1 at this point.  This is used to chain execution of the</span></span><br><span class="line"><span class="comment">	 * pending work items for WORKER_NOT_RUNNING workers such as the</span></span><br><span class="line"><span class="comment">	 * UNBOUND and CPU_INTENSIVE ones.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//在 UNBOUND 或者 CPU_INTENSIVE workers 中判断是否需要唤醒 idle worker</span></span><br><span class="line">    <span class="comment">//对于正常的per-cpu worker，条件总是为false，因为此时nr_running总是&gt; = 1。</span></span><br><span class="line">	<span class="keyword">if</span> (need_more_worker(pool))</span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Record the last pool and clear PENDING which should be the last</span></span><br><span class="line"><span class="comment">	 * update to @work.  Also, do this inside @pool-&gt;lock so that</span></span><br><span class="line"><span class="comment">	 * PENDING and queued state changes happen together while IRQ is</span></span><br><span class="line"><span class="comment">	 * disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	set_work_pool_and_clear_pending(work, pool-&gt;id);</span><br><span class="line"></span><br><span class="line">	spin_unlock_irq(&amp;pool-&gt;lock);<span class="comment">//释放锁</span></span><br><span class="line"></span><br><span class="line">	lock_map_acquire_read(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line">	lock_map_acquire(&amp;lockdep_map);</span><br><span class="line">	trace_workqueue_execute_start(work);</span><br><span class="line">	worker-&gt;current_func(work);<span class="comment">//执行work的回调函数</span></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * While we must be careful to not use "work" after this, the trace</span></span><br><span class="line"><span class="comment">	 * point will only record its address.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	trace_workqueue_execute_end(work);</span><br><span class="line">	lock_map_release(&amp;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;pwq-&gt;wq-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (unlikely(in_atomic() || lockdep_depth(current) &gt; <span class="number">0</span>)) &#123;</span><br><span class="line">		pr_err(<span class="string">"BUG: workqueue leaked lock or atomic: %s/0x%08x/%d\n"</span></span><br><span class="line">		       <span class="string">"     last function: %pf\n"</span>,</span><br><span class="line">		       current-&gt;comm, preempt_count(), task_pid_nr(current),</span><br><span class="line">		       worker-&gt;current_func);</span><br><span class="line">		debug_show_held_locks(current);</span><br><span class="line">		BUG_ON(PANIC_CORRUPTION);</span><br><span class="line">		dump_stack();</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * The following prevents a kworker from hogging CPU on !PREEMPT</span></span><br><span class="line"><span class="comment">	 * kernels, where a requeueing work item waiting for something to</span></span><br><span class="line"><span class="comment">	 * happen could deadlock with stop_machine as such work item could</span></span><br><span class="line"><span class="comment">	 * indefinitely requeue itself while all other CPUs are trapped in</span></span><br><span class="line"><span class="comment">	 * stop_machine. At the same time, report a quiescent RCU state so</span></span><br><span class="line"><span class="comment">	 * the same condition doesn't freeze RCU.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	cond_resched_rcu_qs();</span><br><span class="line"></span><br><span class="line">	spin_lock_irq(&amp;pool-&gt;lock);<span class="comment">//重新上锁</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* clear cpu intensive status */</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpu_intensive))</span><br><span class="line">		worker_clr_flags(worker, WORKER_CPU_INTENSIVE);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we're done with it, release */</span></span><br><span class="line">	hash_del(&amp;worker-&gt;hentry);</span><br><span class="line">	worker-&gt;current_work = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_func = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;current_pwq = <span class="literal">NULL</span>;</span><br><span class="line">	worker-&gt;desc_valid = <span class="literal">false</span>;</span><br><span class="line">	pwq_dec_nr_in_flight(pwq, work_color);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>以上看到的是工作者线程的创建流程、从池中取出work进行处理的流程；接下来需要看下工作队列的创建。</p>
<h5 id="step7-工作队列"><a href="#step7-工作队列" class="headerlink" title="step7-工作队列"></a>step7-工作队列</h5><p>init_workqueues函数的step7中，可以看到系统默认创建了一些全局工作队列。我们看看创建工作队列的核心人物是什么，关键入口是alloc_workqueue这个宏：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * alloc_workqueue - allocate a workqueue</span></span><br><span class="line"><span class="comment"> * @fmt: printf format for the name of the workqueue</span></span><br><span class="line"><span class="comment"> * @flags: WQ_* flags</span></span><br><span class="line"><span class="comment"> * @max_active: max in-flight work items, 0 for default</span></span><br><span class="line"><span class="comment"> * @args...: args for @fmt</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Allocate a workqueue with the specified parameters.  For detailed</span></span><br><span class="line"><span class="comment"> * information on WQ_* flags, please refer to Documentation/workqueue.txt.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * The __lock_name macro dance is to guarantee that single lock_class_key</span></span><br><span class="line"><span class="comment"> * doesn't end up with different namesm, which isn't allowed by lockdep.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * RETURNS:</span></span><br><span class="line"><span class="comment"> * Pointer to the allocated workqueue on success, %NULL on failure.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">ifdef</span> CONFIG_LOCKDEP</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_workqueue(fmt, flags, max_active, args...)		\</span></span><br><span class="line">(&#123;									\</span><br><span class="line">	<span class="keyword">static</span> struct lock_class_key __key;				\</span><br><span class="line">	<span class="keyword">const</span> <span class="keyword">char</span> *__lock_name;					\</span><br><span class="line">									\</span><br><span class="line">	__lock_name = #fmt#args;					\</span><br><span class="line">									\</span><br><span class="line">	__alloc_workqueue_key((fmt), (flags), (max_active),		\</span><br><span class="line">			      &amp;__key, __lock_name, ##args);		\</span><br><span class="line">&#125;)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">else</span></span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">define</span> alloc_workqueue(fmt, flags, max_active, args...)		\</span></span><br><span class="line">	__alloc_workqueue_key((fmt), (flags), (max_active),		\</span><br><span class="line">			      <span class="literal">NULL</span>, <span class="literal">NULL</span>, ##args)</span><br><span class="line"><span class="meta">#<span class="meta-keyword">endif</span></span></span><br></pre></td></tr></table></figure>

<p>实质上所有的工作都是在__alloc_workqueue_key这个函数实现的：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// fmt是工作队列的名字</span></span><br><span class="line"><span class="comment">// flags是工作队列的一些功能特点，内核文档中可以查看相关flag的说明</span></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment"> * max_active用于指定WQ在每个CPU上最大的执行上下文个数，即并发处理的work个数。</span></span><br><span class="line"><span class="comment"> * 目前对于bound WQ，max_active最大可以设置为512，如果max_active入参为0，则使用默认值256。</span></span><br><span class="line"><span class="comment"> * 对于unbound WQ，最大值为512和4*cpu核数两个里面较大的值。</span></span><br><span class="line"><span class="comment"> *对于希望使用STWQ的使用者，可以设置max_active为1，并且设置WQ_UNBOUND标识。这样整个系统里只有一个该WQ上的work正在执行。</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *__<span class="title">alloc_workqueue_key</span>(<span class="title">const</span> <span class="title">char</span> *<span class="title">fmt</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">unsigned</span> <span class="title">int</span> <span class="title">flags</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">int</span> <span class="title">max_active</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">struct</span> <span class="title">lock_class_key</span> *<span class="title">key</span>,</span></span><br><span class="line"><span class="class">					       <span class="title">const</span> <span class="title">char</span> *<span class="title">lock_name</span>, ...)</span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">	<span class="keyword">size_t</span> tbl_size = <span class="number">0</span>;</span><br><span class="line">	va_list args;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_struct</span> *<span class="title">wq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Unbound &amp;&amp; max_active == 1 used to imply ordered, which is no</span></span><br><span class="line"><span class="comment">	 * longer the case on NUMA machines due to per-node pools.  While</span></span><br><span class="line"><span class="comment">	 * alloc_ordered_workqueue() is the right way to create an ordered</span></span><br><span class="line"><span class="comment">	 * workqueue, keep the previous behavior to avoid subtle breakages</span></span><br><span class="line"><span class="comment">	 * on NUMA.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">// unbound &amp; max_active==1 即为有序工作队列</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_UNBOUND) &amp;&amp; max_active == <span class="number">1</span>)</span><br><span class="line">		flags |= __WQ_ORDERED;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* see the comment above the definition of WQ_POWER_EFFICIENT */</span></span><br><span class="line">	<span class="keyword">if</span> ((flags &amp; WQ_POWER_EFFICIENT) &amp;&amp; wq_power_efficient)</span><br><span class="line">		flags |= WQ_UNBOUND;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* 分配workqueue_struct数据结构 并 格式化工作队列名字 */</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND)</span><br><span class="line">		tbl_size = nr_node_ids * <span class="keyword">sizeof</span>(wq-&gt;numa_pwq_tbl[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">	wq = kzalloc(<span class="keyword">sizeof</span>(*wq) + tbl_size, GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!wq)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">		wq-&gt;unbound_attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;unbound_attrs)</span><br><span class="line">			<span class="keyword">goto</span> err_free_wq;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	va_start(args, lock_name);</span><br><span class="line">	vsnprintf(wq-&gt;name, <span class="keyword">sizeof</span>(wq-&gt;name), fmt, args);</span><br><span class="line">	va_end(args);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// pwq最多可以放到worker_pool中的任务数</span></span><br><span class="line">	max_active = max_active ?: WQ_DFL_ACTIVE;</span><br><span class="line">	max_active = wq_clamp_max_active(max_active, flags, wq-&gt;name);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* init wq */</span></span><br><span class="line">	wq-&gt;flags = flags;</span><br><span class="line">	wq-&gt;saved_max_active = max_active;</span><br><span class="line">	mutex_init(&amp;wq-&gt;mutex);</span><br><span class="line">	atomic_set(&amp;wq-&gt;nr_pwqs_to_flush, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;pwqs);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_queue);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;flusher_overflow);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;maydays);</span><br><span class="line"></span><br><span class="line">	lockdep_init_map(&amp;wq-&gt;lockdep_map, lock_name, key, <span class="number">0</span>);</span><br><span class="line">	INIT_LIST_HEAD(&amp;wq-&gt;<span class="built_in">list</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 给工作队列分配对应的pool_workqueue（pwq）</span></span><br><span class="line">    <span class="comment">// pwq将workqueue和worker_pool链接起来</span></span><br><span class="line">    <span class="comment">// 后面详细分析alloc_and_link_pwqs函数</span></span><br><span class="line">	<span class="keyword">if</span> (alloc_and_link_pwqs(wq) &lt; <span class="number">0</span>)</span><br><span class="line">		<span class="keyword">goto</span> err_free_wq;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Workqueues which may be used during memory reclaim should</span></span><br><span class="line"><span class="comment">	 * have a rescuer to guarantee forward progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//如果是WQ_MEM_RECLAIM类型的workqueue，创建对应的rescuer_thread()内核进程</span></span><br><span class="line">	<span class="keyword">if</span> (flags &amp; WQ_MEM_RECLAIM) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">rescuer</span>;</span></span><br><span class="line"></span><br><span class="line">		rescuer = alloc_worker(NUMA_NO_NODE);</span><br><span class="line">		<span class="keyword">if</span> (!rescuer)</span><br><span class="line">			<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">		rescuer-&gt;rescue_wq = wq;</span><br><span class="line">		rescuer-&gt;task = kthread_create(rescuer_thread, rescuer, <span class="string">"%s"</span>,</span><br><span class="line">					       wq-&gt;name);</span><br><span class="line">		<span class="keyword">if</span> (IS_ERR(rescuer-&gt;task)) &#123;</span><br><span class="line">			kfree(rescuer);</span><br><span class="line">			<span class="keyword">goto</span> err_destroy;</span><br><span class="line">		&#125;</span><br><span class="line"></span><br><span class="line">		wq-&gt;rescuer = rescuer;</span><br><span class="line">		kthread_bind_mask(rescuer-&gt;task, cpu_possible_mask);</span><br><span class="line">		wake_up_process(rescuer-&gt;task);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//如果是WQ_SYSFS类型的工作队列，会创建sysfs下的设备节点。</span></span><br><span class="line">    <span class="comment">//通过/sys/bus/workqueue/目录可以查看信息</span></span><br><span class="line">	<span class="keyword">if</span> ((wq-&gt;flags &amp; WQ_SYSFS) &amp;&amp; workqueue_sysfs_register(wq))</span><br><span class="line">		<span class="keyword">goto</span> err_destroy;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * wq_pool_mutex protects global freeze state and workqueues list.</span></span><br><span class="line"><span class="comment">	 * Grab it, adjust max_active and add the new @wq to workqueues</span></span><br><span class="line"><span class="comment">	 * list.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	mutex_lock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历工作队列上所有的pwq，调整pwq的max_active</span></span><br><span class="line">	mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">	for_each_pwq(pwq, wq)</span><br><span class="line">		pwq_adjust_max_active(pwq);</span><br><span class="line">	mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	list_add_tail_rcu(&amp;wq-&gt;<span class="built_in">list</span>, &amp;workqueues);<span class="comment">//将工作队列全局列表中</span></span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> wq;</span><br><span class="line"></span><br><span class="line">err_free_wq:</span><br><span class="line">	free_workqueue_attrs(wq-&gt;unbound_attrs);</span><br><span class="line">	kfree(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">err_destroy:</span><br><span class="line">	destroy_workqueue(wq);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(__alloc_workqueue_key);</span><br></pre></td></tr></table></figure>

<p>关键函数alloc_and_link_pwqs：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">alloc_and_link_pwqs</span><span class="params">(struct workqueue_struct *wq)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> highpri = wq-&gt;flags &amp; WQ_HIGHPRI;</span><br><span class="line">	<span class="keyword">int</span> cpu, ret;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// normal，也就是bounded的工作队列，对于bounded的工作队列会有多个pwq</span></span><br><span class="line">    <span class="comment">// pwq的个数和cpu的个数一样</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND)) &#123;</span><br><span class="line">		wq-&gt;cpu_pwqs = alloc_percpu(struct pool_workqueue);</span><br><span class="line">		<span class="keyword">if</span> (!wq-&gt;cpu_pwqs)</span><br><span class="line">			<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">		for_each_possible_cpu(cpu) &#123;</span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span> =</span></span><br><span class="line"><span class="class">				<span class="title">per_cpu_ptr</span>(<span class="title">wq</span>-&gt;<span class="title">cpu_pwqs</span>, <span class="title">cpu</span>);</span></span><br><span class="line">			<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">cpu_pools</span> =</span></span><br><span class="line"><span class="class">				<span class="title">per_cpu</span>(<span class="title">cpu_worker_pools</span>, <span class="title">cpu</span>);</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">// 分配pool_workqueue，</span></span><br><span class="line">            <span class="comment">// 并将初始化时已经创建好的normal worker_pool和当前的wq，赋值给 pool_workqueue</span></span><br><span class="line">			init_pwq(pwq, wq, &amp;cpu_pools[highpri]);</span><br><span class="line"></span><br><span class="line">            <span class="comment">//同步一些workqueue状态到pool_workqueue，并将它们链接起来</span></span><br><span class="line">            <span class="comment">//所谓的连接就是：pwq通过pwqs_node挂到wq-&gt;pwqs列表中</span></span><br><span class="line">			mutex_lock(&amp;wq-&gt;mutex);</span><br><span class="line">			link_pwq(pwq);</span><br><span class="line">			mutex_unlock(&amp;wq-&gt;mutex);</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> <span class="keyword">if</span> (wq-&gt;flags &amp; __WQ_ORDERED) &#123;<span class="comment">//unbound有序工作队列</span></span><br><span class="line">		ret = apply_workqueue_attrs(wq, ordered_wq_attrs[highpri]);</span><br><span class="line">		<span class="comment">/* there should only be single pwq for ordering guarantee */</span></span><br><span class="line">        <span class="comment">//order的必须只能有一个pwq，即只有一个worker_pool</span></span><br><span class="line">		WARN(!ret &amp;&amp; (wq-&gt;pwqs.next != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node ||</span><br><span class="line">			      wq-&gt;pwqs.prev != &amp;wq-&gt;dfl_pwq-&gt;pwqs_node),</span><br><span class="line">		     <span class="string">"ordering guarantee broken for workqueue %s\n"</span>, wq-&gt;name);</span><br><span class="line">		<span class="keyword">return</span> ret;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//unbound标准作队列</span></span><br><span class="line">		<span class="keyword">return</span> apply_workqueue_attrs(wq, unbound_std_wq_attrs[highpri]);</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>对于unbound的有序队列和标准队列，workqueue_struct、pool_workqueue和worker_pool三者建立连接是通过apply_workqueue_attrs-&gt;apply_workqueue_attrs_locked中实现的，这里会根据初始化时创建好的对应属性集合ordered_wq_attrs/unbound_std_wq_attrs创建对应的pool_workqueue和worker_pool，并建立链接。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">int</span> <span class="title">apply_workqueue_attrs_locked</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">apply_wqattrs_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* only unbound workqueues can change attributes */</span></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!(wq-&gt;flags &amp; WQ_UNBOUND)))</span><br><span class="line">		<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* creating multiple pwqs breaks ordering guarantee */</span></span><br><span class="line">	<span class="keyword">if</span> (!list_empty(&amp;wq-&gt;pwqs)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (WARN_ON(wq-&gt;flags &amp; __WQ_ORDERED_EXPLICIT))</span><br><span class="line">			<span class="keyword">return</span> -EINVAL;</span><br><span class="line"></span><br><span class="line">		wq-&gt;flags &amp;= ~__WQ_ORDERED;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过调用alloc_unbound_pwq函数</span></span><br><span class="line">    <span class="comment">//为该工作队列创建1+node（当前系统的node数）个pwq</span></span><br><span class="line">	ctx = apply_wqattrs_prepare(wq, attrs);</span><br><span class="line">	<span class="keyword">if</span> (!ctx)</span><br><span class="line">		<span class="keyword">return</span> -ENOMEM;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* the ctx has been prepared successfully, let's commit it */</span></span><br><span class="line">    <span class="comment">//pwq建立为工作队列和线程池的链接</span></span><br><span class="line">	apply_wqattrs_commit(ctx);</span><br><span class="line">	apply_wqattrs_cleanup(ctx);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>从前面的流程可以知道，unbound的std工作队列没有限制pwq的个数，order的则只能有一个pwq，所以我们看看这个是怎么限制的。apply_wqattrs_prepare函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br></pre></td><td class="code"><pre><span class="line">apply_wqattrs_prepare(struct workqueue_struct *wq,</span><br><span class="line">		      <span class="keyword">const</span> struct workqueue_attrs *attrs)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">apply_wqattrs_ctx</span> *<span class="title">ctx</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">workqueue_attrs</span> *<span class="title">new_attrs</span>, *<span class="title">tmp_attrs</span>;</span></span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">	ctx = kzalloc(<span class="keyword">sizeof</span>(*ctx) + nr_node_ids * <span class="keyword">sizeof</span>(ctx-&gt;pwq_tbl[<span class="number">0</span>]),</span><br><span class="line">		      GFP_KERNEL);</span><br><span class="line"></span><br><span class="line">	new_attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line">	tmp_attrs = alloc_workqueue_attrs(GFP_KERNEL);</span><br><span class="line">	<span class="keyword">if</span> (!ctx || !new_attrs || !tmp_attrs)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Calculate the attrs of the default pwq.</span></span><br><span class="line"><span class="comment">	 * If the user configured cpumask doesn't overlap with the</span></span><br><span class="line"><span class="comment">	 * wq_unbound_cpumask, we fallback to the wq_unbound_cpumask.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	copy_workqueue_attrs(new_attrs, attrs);</span><br><span class="line">	cpumask_and(new_attrs-&gt;cpumask, new_attrs-&gt;cpumask, wq_unbound_cpumask);</span><br><span class="line">	<span class="keyword">if</span> (unlikely(cpumask_empty(new_attrs-&gt;cpumask)))</span><br><span class="line">		cpumask_copy(new_attrs-&gt;cpumask, wq_unbound_cpumask);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * We may create multiple pwqs with differing cpumasks.  Make a</span></span><br><span class="line"><span class="comment">	 * copy of @new_attrs which will be modified and used to obtain</span></span><br><span class="line"><span class="comment">	 * pools.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	copy_workqueue_attrs(tmp_attrs, new_attrs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If something goes wrong during CPU up/down, we'll fall back to</span></span><br><span class="line"><span class="comment">	 * the default pwq covering whole @attrs-&gt;cpumask.  Always create</span></span><br><span class="line"><span class="comment">	 * it even if we don't use it immediately.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//创建当前工作队列默认的pwq</span></span><br><span class="line">	ctx-&gt;dfl_pwq = alloc_unbound_pwq(wq, new_attrs);</span><br><span class="line">	<span class="keyword">if</span> (!ctx-&gt;dfl_pwq)</span><br><span class="line">		<span class="keyword">goto</span> out_free;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//遍历当前系统所有的node</span></span><br><span class="line">	for_each_node(node) &#123;</span><br><span class="line">        <span class="comment">//std的属性集合no_numa是false，wq_calc_node_cpumask返回true</span></span><br><span class="line">		<span class="keyword">if</span> (wq_calc_node_cpumask(new_attrs, node, <span class="number">-1</span>, tmp_attrs-&gt;cpumask)) &#123;</span><br><span class="line">			ctx-&gt;pwq_tbl[node] = alloc_unbound_pwq(wq, tmp_attrs);</span><br><span class="line">			<span class="keyword">if</span> (!ctx-&gt;pwq_tbl[node])</span><br><span class="line">				<span class="keyword">goto</span> out_free;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123; <span class="comment">//order的属性集合no_numa是true，wq_calc_node_cpumask返回fase</span></span><br><span class="line">			ctx-&gt;dfl_pwq-&gt;refcnt++;</span><br><span class="line">			ctx-&gt;pwq_tbl[node] = ctx-&gt;dfl_pwq;</span><br><span class="line">		&#125;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* save the user configured attrs and sanitize it. */</span></span><br><span class="line">	copy_workqueue_attrs(new_attrs, attrs);</span><br><span class="line">	cpumask_and(new_attrs-&gt;cpumask, new_attrs-&gt;cpumask, cpu_possible_mask);</span><br><span class="line">	ctx-&gt;attrs = new_attrs;</span><br><span class="line"></span><br><span class="line">	ctx-&gt;wq = wq;</span><br><span class="line">	free_workqueue_attrs(tmp_attrs);</span><br><span class="line">	<span class="keyword">return</span> ctx;</span><br><span class="line"></span><br><span class="line">out_free:</span><br><span class="line">	free_workqueue_attrs(tmp_attrs);</span><br><span class="line">	free_workqueue_attrs(new_attrs);</span><br><span class="line">	apply_wqattrs_cleanup(ctx);</span><br><span class="line">	<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>pwq和线程池的创建：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* obtain a pool matching @attr and create a pwq associating the pool and @wq */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> struct pool_workqueue *<span class="title">alloc_unbound_pwq</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">					<span class="keyword">const</span> struct workqueue_attrs *attrs)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line"></span><br><span class="line">	lockdep_assert_held(&amp;wq_pool_mutex);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//通过get_unbound_pool获取线程池；</span></span><br><span class="line">    <span class="comment">//在unbound_pool_hash中查找，如果查不到到匹配的pool</span></span><br><span class="line">    <span class="comment">//如果找不到就创建新的pool和worker</span></span><br><span class="line">	pool = get_unbound_pool(attrs);</span><br><span class="line">	<span class="keyword">if</span> (!pool)</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//分配pwq空间</span></span><br><span class="line">	pwq = kmem_cache_alloc_node(pwq_cache, GFP_KERNEL, pool-&gt;node);</span><br><span class="line">	<span class="keyword">if</span> (!pwq) &#123;</span><br><span class="line">		put_unbound_pool(pool);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//将创建好unbound worker_pool和当前的wq，赋值给pool_workqueue</span></span><br><span class="line">	init_pwq(pwq, wq, pool);</span><br><span class="line">	<span class="keyword">return</span> pwq;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p>3者连接的建立，apply_wqattrs_commit函数：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* set attrs and install prepared pwqs, @ctx points to old pwqs on return */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">apply_wqattrs_commit</span><span class="params">(struct apply_wqattrs_ctx *ctx)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">int</span> node;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* all pwqs have been created successfully, let's install'em */</span></span><br><span class="line">	mutex_lock(&amp;ctx-&gt;wq-&gt;mutex);</span><br><span class="line"></span><br><span class="line">	copy_workqueue_attrs(ctx-&gt;wq-&gt;unbound_attrs, ctx-&gt;attrs);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* save the previous pwq and install the new one */</span></span><br><span class="line">    <span class="comment">//对应node的pwq链接</span></span><br><span class="line">	for_each_node(node)</span><br><span class="line">		ctx-&gt;pwq_tbl[node] = numa_pwq_tbl_install(ctx-&gt;wq, node,</span><br><span class="line">							  ctx-&gt;pwq_tbl[node]);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* @dfl_pwq might not have been used, ensure it's linked */</span></span><br><span class="line">    <span class="comment">//默认的pwq也要确保链接</span></span><br><span class="line">	link_pwq(ctx-&gt;dfl_pwq);</span><br><span class="line">	swap(ctx-&gt;wq-&gt;dfl_pwq, ctx-&gt;dfl_pwq);</span><br><span class="line"></span><br><span class="line">	mutex_unlock(&amp;ctx-&gt;wq-&gt;mutex);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h4 id="任务的入队与分发"><a href="#任务的入队与分发" class="headerlink" title="任务的入队与分发"></a>任务的入队与分发</h4><p>各个主体部分都已经准备就绪，写下来看看工作任务从入队-&gt;分发-&gt;处理的整个流程。这里面分普通work和延迟work；延迟work就是启动一个定时器来将work压入队列，其他的跟普通work没有差别；所以这里只看普通work入列的流程：queue_work-&gt;queue_work_on-&gt;__queue_work。</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// workqueue.h</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queue_work - queue work on a workqueue</span></span><br><span class="line"><span class="comment"> * @wq: workqueue to use</span></span><br><span class="line"><span class="comment"> * @work: work to queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Returns %false if @work was already on a queue, %true otherwise.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We queue the work to the CPU on which it was submitted, but if the CPU dies</span></span><br><span class="line"><span class="comment"> * it can be processed by another CPU.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">inline</span> <span class="keyword">bool</span> <span class="title">queue_work</span><span class="params">(struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">			      struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">return</span> queue_work_on(WORK_CPU_UNBOUND, wq, work);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// workqueue.c</span></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * insert_work - insert a work into a pool</span></span><br><span class="line"><span class="comment"> * @pwq: pwq @work belongs to</span></span><br><span class="line"><span class="comment"> * @work: work to insert</span></span><br><span class="line"><span class="comment"> * @head: insertion point</span></span><br><span class="line"><span class="comment"> * @extra_flags: extra WORK_STRUCT_* flags to set</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Insert @work which belongs to @pwq after @head.  @extra_flags is or'd to</span></span><br><span class="line"><span class="comment"> * work_struct flags.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * CONTEXT:</span></span><br><span class="line"><span class="comment"> * spin_lock_irq(pool-&gt;lock).</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> <span class="keyword">void</span> <span class="title">insert_work</span><span class="params">(struct pool_workqueue *pwq, struct work_struct *work,</span></span></span><br><span class="line"><span class="function"><span class="params">			struct list_head *head, <span class="keyword">unsigned</span> <span class="keyword">int</span> extra_flags)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">pool</span> = <span class="title">pwq</span>-&gt;<span class="title">pool</span>;</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/* we own @work, set data and link */</span></span><br><span class="line">	set_work_pwq(work, pwq, extra_flags);<span class="comment">//设置work的pwq跟标志位到data</span></span><br><span class="line">	list_add_tail(&amp;work-&gt;entry, head);<span class="comment">//加入链表的尾部</span></span><br><span class="line">	get_pwq(pwq);<span class="comment">//增加pwq的引用数</span></span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * Ensure either wq_worker_sleeping() sees the above</span></span><br><span class="line"><span class="comment">	 * list_add_tail() or we see zero nr_running to avoid workers lying</span></span><br><span class="line"><span class="comment">	 * around lazily while there are works to be processed.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">	smp_mb();</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (__need_more_worker(pool))<span class="comment">//如果需要更多的work来工作，则唤醒额外的线程</span></span><br><span class="line">		wake_up_worker(pool);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">void</span> __queue_work(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span><br><span class="line">			 struct work_struct *work)</span><br><span class="line">&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">pool_workqueue</span> *<span class="title">pwq</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">worker_pool</span> *<span class="title">last_pool</span>;</span></span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">worklist</span>;</span></span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> work_flags;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">int</span> req_cpu = cpu;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * While a work item is PENDING &amp;&amp; off queue, a task trying to</span></span><br><span class="line"><span class="comment">	 * steal the PENDING will busy-loop waiting for it to either get</span></span><br><span class="line"><span class="comment">	 * queued or lose PENDING.  Grabbing PENDING and queueing should</span></span><br><span class="line"><span class="comment">	 * happen with IRQ disabled.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//入队过程需要禁止中断，否则trace警告</span></span><br><span class="line">	WARN_ON_ONCE(!irqs_disabled());</span><br><span class="line"></span><br><span class="line">	debug_work_activate(work);</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* if draining, only works from the same workqueue are allowed */</span></span><br><span class="line">    <span class="comment">//可以通过调用drain_workqueue给某个工作队列排水，这时候工作队列就设置了__WQ_DRAINING标志</span></span><br><span class="line">    <span class="comment">//如果当前队列正在排水，那么只允许队列上自己的work压入另一个work。</span></span><br><span class="line">    <span class="comment">//is_chained_work是如何判断发起work入队的线程是否处理这个工作队列？</span></span><br><span class="line">    <span class="comment">//首先当前执行环境是进程上下文、并且当前线程设置了PF_WQ_WORKER标志，然后获取线程的data成员</span></span><br><span class="line">    <span class="comment">//进而找出其正在处理的任务所对应的的工作队列</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(wq-&gt;flags &amp; __WQ_DRAINING) &amp;&amp;</span><br><span class="line">	    WARN_ON_ONCE(!is_chained_work(wq)))</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">retry:</span><br><span class="line">	<span class="keyword">if</span> (req_cpu == WORK_CPU_UNBOUND)<span class="comment">//没有指定cpu，则使用当前cpu</span></span><br><span class="line">		cpu = wq_select_unbound_cpu(raw_smp_processor_id());</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pwq which will be used unless @work is executing elsewhere */</span></span><br><span class="line">    <span class="comment">// normal的工作队列从cpu_pwqs找到对应cpu的pwq</span></span><br><span class="line">	<span class="keyword">if</span> (!(wq-&gt;flags &amp; WQ_UNBOUND))</span><br><span class="line">		pwq = per_cpu_ptr(wq-&gt;cpu_pwqs, cpu);</span><br><span class="line">    <span class="comment">// unbound的工作队列通过cpu对应的node从numa_pwq_tbl找到对应的pwq</span></span><br><span class="line">	<span class="keyword">else</span></span><br><span class="line">		pwq = unbound_pwq_by_node(wq, cpu_to_node(cpu));</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * If @work was previously on a different pool, it might still be</span></span><br><span class="line"><span class="comment">	 * running there, in which case the work needs to be queued on that</span></span><br><span class="line"><span class="comment">	 * pool to guarantee non-reentrancy.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//如果@work以前在另一个池上，它可能仍然在那里运行，在这种情况下，工作需要在该池上排队以保证不可重入。</span></span><br><span class="line">	last_pool = get_work_pool(work);</span><br><span class="line">	<span class="keyword">if</span> (last_pool &amp;&amp; last_pool != pwq-&gt;pool) &#123;</span><br><span class="line">		<span class="class"><span class="keyword">struct</span> <span class="title">worker</span> *<span class="title">worker</span>;</span></span><br><span class="line"></span><br><span class="line">		spin_lock(&amp;last_pool-&gt;lock);</span><br><span class="line"></span><br><span class="line">		worker = find_worker_executing_work(last_pool, work);</span><br><span class="line"></span><br><span class="line">		<span class="keyword">if</span> (worker &amp;&amp; worker-&gt;current_pwq-&gt;wq == wq) &#123;</span><br><span class="line">			pwq = worker-&gt;current_pwq;</span><br><span class="line">		&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">			<span class="comment">/* meh... not running there, queue here */</span></span><br><span class="line">			spin_unlock(&amp;last_pool-&gt;lock);</span><br><span class="line">			spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">		&#125;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		spin_lock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/*</span></span><br><span class="line"><span class="comment">	 * pwq is determined and locked.  For unbound pools, we could have</span></span><br><span class="line"><span class="comment">	 * raced with pwq release and it could already be dead.  If its</span></span><br><span class="line"><span class="comment">	 * refcnt is zero, repeat pwq selection.  Note that pwqs never die</span></span><br><span class="line"><span class="comment">	 * without another pwq replacing it in the numa_pwq_tbl or while</span></span><br><span class="line"><span class="comment">	 * work items are executing on it, so the retrying is guaranteed to</span></span><br><span class="line"><span class="comment">	 * make forward-progress.</span></span><br><span class="line"><span class="comment">	 */</span></span><br><span class="line">    <span class="comment">//对于unbond的wq，目标的pwq的引用数可能为0；出现这种情况的话retry</span></span><br><span class="line">	<span class="keyword">if</span> (unlikely(!pwq-&gt;refcnt)) &#123;</span><br><span class="line">		<span class="keyword">if</span> (wq-&gt;flags &amp; WQ_UNBOUND) &#123;</span><br><span class="line">			spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">			cpu_relax();</span><br><span class="line">			<span class="keyword">goto</span> retry;</span><br><span class="line">		&#125;</span><br><span class="line">		<span class="comment">/* oops */</span></span><br><span class="line">		WARN_ONCE(<span class="literal">true</span>, <span class="string">"workqueue: per-cpu pwq for %s on cpu%d has 0 refcnt"</span>,</span><br><span class="line">			  wq-&gt;name, cpu);</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	<span class="comment">/* pwq determined, queue */</span></span><br><span class="line">    <span class="comment">//pwq已经确认，开始入队</span></span><br><span class="line">	trace_workqueue_queue_work(req_cpu, pwq, work);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (WARN_ON(!list_empty(&amp;work-&gt;entry))) &#123;</span><br><span class="line">		spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">		<span class="keyword">return</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">	pwq-&gt;nr_in_flight[pwq-&gt;work_color]++;</span><br><span class="line">	work_flags = work_color_to_flags(pwq-&gt;work_color);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//pwq上活跃的work没有超过max_active，直接压入线程池的worklist</span></span><br><span class="line">	<span class="keyword">if</span> (likely(pwq-&gt;nr_active &lt; pwq-&gt;max_active)) &#123;</span><br><span class="line">		trace_workqueue_activate_work(work);</span><br><span class="line">		pwq-&gt;nr_active++;</span><br><span class="line">		worklist = &amp;pwq-&gt;pool-&gt;worklist;</span><br><span class="line">		<span class="keyword">if</span> (list_empty(worklist))</span><br><span class="line">			pwq-&gt;pool-&gt;watchdog_ts = jiffies;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;<span class="comment">//否则设置成延迟work，压入pwq的delayed_works</span></span><br><span class="line">		work_flags |= WORK_STRUCT_DELAYED;</span><br><span class="line">		worklist = &amp;pwq-&gt;delayed_works;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//真正的压入队列</span></span><br><span class="line">	insert_work(pwq, work, worklist, work_flags);</span><br><span class="line"></span><br><span class="line">	spin_unlock(&amp;pwq-&gt;pool-&gt;lock);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * queue_work_on - queue work on specific cpu</span></span><br><span class="line"><span class="comment"> * @cpu: CPU number to execute work on</span></span><br><span class="line"><span class="comment"> * @wq: workqueue to use</span></span><br><span class="line"><span class="comment"> * @work: work to queue</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * We queue the work to a specific CPU, the caller must ensure it</span></span><br><span class="line"><span class="comment"> * can't go away.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return: %false if @work was already on a queue, %true otherwise.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">queue_work_on</span><span class="params">(<span class="keyword">int</span> cpu, struct workqueue_struct *wq,</span></span></span><br><span class="line"><span class="function"><span class="params">		   struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="keyword">bool</span> ret = <span class="literal">false</span>;</span><br><span class="line">	<span class="keyword">unsigned</span> <span class="keyword">long</span> flags;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//保存当前中断状态到flags中，然后禁用当前处理器上的中断</span></span><br><span class="line">	local_irq_save(flags);</span><br><span class="line"></span><br><span class="line">    <span class="comment">/*</span></span><br><span class="line"><span class="comment">     * 测试work的data成员的WORK_STRUCT_PENDING_BIT是否为0，然后将对应为设置为1</span></span><br><span class="line"><span class="comment">     * 如果返回0则说明work还没有入列，继续__queue_work流程</span></span><br><span class="line"><span class="comment">    */</span></span><br><span class="line">	<span class="keyword">if</span> (!test_and_set_bit(WORK_STRUCT_PENDING_BIT, work_data_bits(work))) &#123;</span><br><span class="line">		__queue_work(cpu, wq, work);</span><br><span class="line">		ret = <span class="literal">true</span>;</span><br><span class="line">	&#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//恢复flags到中断状态寄存器中，然后使能当前处理器上的中断</span></span><br><span class="line">	local_irq_restore(flags);</span><br><span class="line">	<span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL(queue_work_on);</span><br></pre></td></tr></table></figure>

<p>至此，work入队成功。所有的入队其实就是通过workqueue找到目标pwq再找到对应的worker pool，然后压入到worker pool的任务列表中。然后worker开始处理列表上的work。</p>
<h4 id="等待work完成"><a href="#等待work完成" class="headerlink" title="等待work完成"></a>等待work完成</h4><p>有时候schedue 一个work后，需要等待这个work执行完成。那么调用flush_work可以达到这个目标。主要是通过向目标work所在的池中压入一个wq_barrier（带有一个完成量，当他的回调执行完成时）</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * flush_work - wait for a work to finish executing the last queueing instance</span></span><br><span class="line"><span class="comment"> * @work: the work to flush</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Wait until @work has finished execution.  @work is guaranteed to be idle</span></span><br><span class="line"><span class="comment"> * on return if it hasn't been requeued since flush started.</span></span><br><span class="line"><span class="comment"> *</span></span><br><span class="line"><span class="comment"> * Return:</span></span><br><span class="line"><span class="comment"> * %true if flush_work() waited for the work to finish execution,</span></span><br><span class="line"><span class="comment"> * %false if it was already idle.</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function"><span class="keyword">bool</span> <span class="title">flush_work</span><span class="params">(struct work_struct *work)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">	<span class="class"><span class="keyword">struct</span> <span class="title">wq_barrier</span> <span class="title">barr</span>;</span></span><br><span class="line"></span><br><span class="line">	lock_map_acquire(&amp;work-&gt;lockdep_map);</span><br><span class="line">	lock_map_release(&amp;work-&gt;lockdep_map);</span><br><span class="line"></span><br><span class="line">	<span class="keyword">if</span> (start_flush_work(work, &amp;barr)) &#123;</span><br><span class="line">		wait_for_completion(&amp;barr.done);</span><br><span class="line">		destroy_work_on_stack(&amp;barr.work);</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">	&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">		<span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br><span class="line">EXPORT_SYMBOL_GPL(flush_work);</span><br></pre></td></tr></table></figure>

<p>当然也可以调用flush_workqueue来flush整个工作队列。</p>
<h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>基本上把工作队列的流程大体上捋了一遍，仍然有很多细节可能没有注意到，不过这个很多细节也不太可能一次完全搞清楚的；把握整体的工作流程和原理即可！因为细节太多很容易忘记，写下来方便以后查阅！</p>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://yoursite.com/2019/04/20/Linux-irq-bh-workqueue/" data-id="cjy7ayu9o002ceoii2a8e8qgh" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/Linux/">Linux</a></li><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/学习/">学习</a></li></ul>

    </footer>
  </div>
  
</article>


  


  <nav id="page-nav">
    
    <a class="extend prev" rel="prev" href="/page/14/">&laquo; Prev</a><a class="page-number" href="/">1</a><span class="space">&hellip;</span><a class="page-number" href="/page/13/">13</a><a class="page-number" href="/page/14/">14</a><span class="page-number current">15</span><a class="page-number" href="/page/16/">16</a><a class="page-number" href="/page/17/">17</a><span class="space">&hellip;</span><a class="page-number" href="/page/24/">24</a><a class="extend next" rel="next" href="/page/16/">Next &raquo;</a>
  </nav>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tags</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/AIDL/">AIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Android/">Android</a><span class="tag-list-count">10</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/HIDL/">HIDL</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/Linux/">Linux</a><span class="tag-list-count">12</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/driver/">driver</a><span class="tag-list-count">1</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/学习/">学习</a><span class="tag-list-count">16</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/实战/">实战</a><span class="tag-list-count">6</span></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/稳定性/">稳定性</a><span class="tag-list-count">8</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Tag Cloud</h3>
    <div class="widget tagcloud">
      <a href="/tags/AIDL/" style="font-size: 10px;">AIDL</a> <a href="/tags/Android/" style="font-size: 16px;">Android</a> <a href="/tags/HIDL/" style="font-size: 10px;">HIDL</a> <a href="/tags/Linux/" style="font-size: 18px;">Linux</a> <a href="/tags/driver/" style="font-size: 10px;">driver</a> <a href="/tags/学习/" style="font-size: 20px;">学习</a> <a href="/tags/实战/" style="font-size: 12px;">实战</a> <a href="/tags/稳定性/" style="font-size: 14px;">稳定性</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Archives</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/07/">July 2019</a><span class="archive-list-count">2</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/06/">June 2019</a><span class="archive-list-count">3</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/05/">May 2019</a><span class="archive-list-count">8</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/04/">April 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/03/">March 2019</a><span class="archive-list-count">5</span></li><li class="archive-list-item"><a class="archive-list-link" href="/archives/2019/02/">February 2019</a><span class="archive-list-count">1</span></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">Recent Posts</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2019/07/01/native-acess-javaservice-with-binder/">Android平台上native代码访问PackageManagerService</a>
          </li>
        
          <li>
            <a href="/2019/07/01/gdb_coredump_using/">Android平台上使用coredump+gdb</a>
          </li>
        
          <li>
            <a href="/2019/06/25/Android-Init-FBE/">Android启动流程-FBE部分</a>
          </li>
        
          <li>
            <a href="/2019/06/15/Linux-system-ipc/">Linux进程间通信机制</a>
          </li>
        
          <li>
            <a href="/2019/06/01/Android-hidl-sample-impletment/">Android9.0 HIDL 学习</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2019 JoyYoung<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archives</a>
  
</nav>
    

<script src="//ajax.googleapis.com/ajax/libs/jquery/2.0.3/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>



  </div>
</body>
</html>